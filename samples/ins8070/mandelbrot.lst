          0 :                            cpu     ins8070
          0 :                            include "ins8070.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; INS8070
(1)       0 :                    ;;; Status Register
(1)       0 : =80                S_CY    =       X'80            ; Carry bit
(1)       0 : =80                S_L     =       X'80            ; Link bit
(1)       0 : =40                S_OV    =       X'40            ; Overflow bit
(1)       0 : =20                S_SB    =       X'20            ; Sense B bit
(1)       0 : =10                S_SA    =       X'10            ; Sense A bit
(1)       0 : =8                 S_F3    =       X'08            ; Flag 3 bit
(1)       0 : =4                 S_F2    =       X'04            ; Flag 2 bit
(1)       0 : =2                 S_F1    =       X'02            ; Flag 1 bit
(1)       0 : =1                 S_IE    =       X'01            ; Interrupt Enable bit
(1)       0 :
(1)       0 :                    ;;; Transfer locations
(1)       0 : =1                 ORG_RESTART     =       X'0001  ; Restart transfer location
(1)       0 : =4                 ORG_INTA        =       X'0004  ; Interrupt A transfer location
(1)       0 : =7                 ORG_INTB        =       X'0007  ; Interrupt B transfer location
(1)       0 : =A                 ORG_END         =       X'000A
(1)       0 :
(1)       0 :                    ;;; Call vectors
(1)       0 : =20                VEC_CALL0       =       X'0020  ; Call 0 vector
(1)       0 : =22                VEC_CALL1       =       X'0022  ; Call 0 vector
(1)       0 : =24                VEC_CALL2       =       X'0024  ; Call 0 vector
(1)       0 : =26                VEC_CALL3       =       X'0026  ; Call 0 vector
(1)       0 : =28                VEC_CALL4       =       X'0028  ; Call 0 vector
(1)       0 : =2A                VEC_CALL5       =       X'002A  ; Call 0 vector
(1)       0 : =2C                VEC_CALL6       =       X'002C  ; Call 0 vector
(1)       0 : =2E                VEC_CALL7       =       X'002E  ; Call 0 vector
(1)       0 : =30                VEC_CALL8       =       X'0030  ; Call 0 vector
(1)       0 : =32                VEC_CALL9       =       X'0032  ; Call 0 vector
(1)       0 : =34                VEC_CALL10      =       X'0034  ; Call 0 vector
(1)       0 : =36                VEC_CALL11      =       X'0036  ; Call 0 vector
(1)       0 : =38                VEC_CALL12      =       X'0038  ; Call 0 vector
(1)       0 : =3A                VEC_CALL13      =       X'003A  ; Call 0 vector
(1)       0 : =3C                VEC_CALL14      =       X'003C  ; Call 0 vector
(1)       0 : =3E                VEC_CALL15      =       X'003E  ; Call 0 vector
(1)       0 : =40                VEC_END         =       X'0040
          0 :
          0 :                    ;;; MC6850 Asynchronous Communication Interface Adapter
          0 : =DF00              ACIA    =       X'DF00
          0 :                            include "mc6850.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; MC6850
(1)       0 :                    ;;; Asynchronous Communication Interface Adapter
(1)       0 :
(1)       0 :                    ;;; Control register
(1)       0 : =DF00              ACIA_control    =       ACIA+0
(1)       0 :                            ;; Counter Divider Select Bits
(1)       0 : =3                 CDS_gm          =       X'03   ; Group mask
(1)       0 : =0                 CDS_DIV1_gc     =       X'00   ; /1
(1)       0 : =1                 CDS_DIV16_gc    =       X'01   ; /16
(1)       0 : =2                 CDS_DIV64_gc    =       X'02   ; /64
(1)       0 : =3                 CDS_RESET_gc    =       X'03   ; Master Reset
(1)       0 :                            ;; Word Select Bits
(1)       0 : =1C                WSB_gm          =       X'1C   ; Group mask
(1)       0 : =0                 WSB_7E2_gc      =       X'00   ; 7 Bits + Even Parity + 2 Stop Bits
(1)       0 : =4                 WSB_7O2_gc      =       X'04   ; 7 bits + Odd Parity  + 2 Stop Bits
(1)       0 : =8                 WSB_7E1_gc      =       X'08   ; 7 bits + Even Parity + 1 Stop Bits
(1)       0 : =C                 WSB_7O1_gc      =       X'0C   ; 7 bits + Odd Parity  + 1 Stop Bits
(1)       0 : =10                WSB_8N2_gc      =       X'10   ; 8 bits + No Parity   + 2 Stop Bits
(1)       0 : =14                WSB_8N1_gc      =       X'14   ; 8 bits + No Parity   + 1 Stop Bits
(1)       0 : =18                WSB_8E1_gc      =       X'18   ; 8 bits + Even Parity + 1 Stop Bits
(1)       0 : =1C                WSB_8O1_gc      =       X'1C   ; 8 bits + Odd Parity  + 1 Stop Bits
(1)       0 :                            ;; Transmit Control Bits
(1)       0 : =60                TCB_gm          =       X'60   ; Group mask
(1)       0 : =0                 TCB_DI_gc       =       X'00   ; RTS=Low,  Tx Interrupt Disabled
(1)       0 : =20                TCB_EI_gc       =       X'20   ; RTS=Low,  Tx Interrupt Enabled
(1)       0 : =40                TCB_RTS_gc      =       X'40   ; RTS=High, Tx Interrupt Disabled
(1)       0 : =60                TCB_BREAK_gc    =       X'60   ; RTS=Low,  Tx Interrupt Disabled
(1)       0 :                                                    ; Transmit Break Level
(1)       0 : =80                RIEB_bm         =       X'80   ; Receive Interrupt Enable Bit mask
(1)       0 :
(1)       0 :                    ;;; Status register
(1)       0 : =DF00              ACIA_status     =       ACIA+0
(1)       0 : =1                 RDRF_bm         =       X'01   ; Receive Data Register Full
(1)       0 : =2                 TDRE_bm         =       X'02   ; Transmit Data Register Empty
(1)       0 : =4                 DCDF_bm         =       X'04   ; Data Carrier Detect Flag
(1)       0 : =8                 CTSF_bm         =       X'08   ; Clear To Send Flag
(1)       0 : =10                FERR_bm         =       X'10   ; Frame Error Flag
(1)       0 : =20                OVRN_bm         =       X'20   ; Receiver Overrun Flag
(1)       0 : =40                PERR_bm         =       X'40   ; Parity Error Flag
(1)       0 : =80                IRQF_bm         =       X'80   ; Interrupt Request Flag
(1)       0 :
(1)       0 :                    ;;; Data register
(1)       0 : =DF01              ACIA_data       =       ACIA+1  ; Data register
          0 : =0                 ACIA_C  =       0               ; ACIA control offset
          0 : =0                 ACIA_S  =       0               ; ACIA status offset
          0 : =1                 ACIA_D  =       1               ; ACIA data register offset
          0 :
          0 : =10                rx_queue_size   =       16
          0 : =30                tx_queue_size   =       48
          0 : =94                RX_INT_TX_NO    =       WSB_8N1_gc|RIEB_bm
          0 : =B4                RX_INT_TX_INT   =       WSB_8N1_gc|RIEB_bm|TCB_EI_gc
          0 :
       2000 :                            .=      X'2000
       2000 :                    rx_queue:
       2010 :                            .=      .+rx_queue_size
       2010 :                    tx_queue:
       2040 :                            .=      .+tx_queue_size
       2040 :
          1 :                            .=      ORG_RESTART
          1 : 24 FF 0F                   jmp     initialize
          4 :
          4 :                            .=      ORG_INTA
          4 : 24 AD 12                   jmp     isr_irq
          7 :
         3E :                            .=      VEC_CALL15
         3E : 00 00                      .dbyte  0               ; halt to system
         40 :
       1000 :                            .=      X'1000
       1000 :                    stack:
       1000 :                    initialize:
       1000 : 25 00 10                   ld      SP, =stack
       1003 :                            ;; initialize queues
       1003 : 26 00 20                   ld      P2, =rx_queue
       1006 : C4 10                      ld      A, =rx_queue_size
       1008 : 20 4D 12                   jsr     queue_init
       100B : 26 10 20                   ld      P2, =tx_queue
       100E : C4 30                      ld      A, =tx_queue_size
       1010 : 20 4D 12                   jsr     queue_init
       1013 :
       1013 :                            ;; initialize ACIA
       1013 : 26 00 DF                   ld      P2, =ACIA
       1016 : C4 03                      ld      A, =CDS_RESET_gc ; master reset
       1018 : CA 00                      st      A, ACIA_C, P2
       101A : C4 94                      ld      A, =RX_INT_TX_NO
       101C : CA 00                      st      A, ACIA_C, P2
       101E : 3B 01                      or      S, =S_IE          ; enable IRQ
       1020 :
       1020 :                    loop:
       1020 : 20 2B 11                   jsr     mandelbrot
       1023 : 20 57 10                   jsr     newline
       1026 : 24 1F 10                   jmp     loop
       1029 :
       1029 :                    ;;; Get character
       1029 :                    ;;; @return E char
       1029 :                    ;;; @return A 0 if no char received
       1029 :                    getchar:
       1029 : 22 00 20                   pli     P2, =rx_queue
       102C : 39 FE                      and     S, =~S_IE       ; disable IRQ
       102E : 20 92 12                   jsr     queue_remove
       1031 : 3B 01                      or      S, =S_IE        ; enable IRQ
       1033 : 5E                         pop     P2
       1034 : 5C                         ret
       1035 :
       1035 :                    ;;; Put character
       1035 :                    ;;; @param A char
       1035 :                    putchar:
       1035 : 08                         push    EA
       1036 : 22 10 20                   pli     P2, =tx_queue
       1039 : 48                         ld      E, A
       103A :                    putchar_retry:
       103A : 40                         ld      A, E
       103B : 39 FE                      and     S, =~S_IE       ; disable IRQ
       103D : 20 74 12                   jsr     queue_add
       1040 : 3B 01                      or      S, =S_IE        ; enable IRQ
       1042 : 6C F6                      bz      putchar_retry   ; queue is full
       1044 : 39 FE                      and     S, =~S_IE       ; disable IRQ
       1046 : 26 00 DF                   ld      P2, =ACIA
       1049 : C2 00                      ld      A, ACIA_C, P2
       104B : D4 20                      and     A, =TCB_EI_gc
       104D : 7C 04                      bnz     putchar_exit
       104F : C4 B4                      ld      A, =RX_INT_TX_INT ; enable Tx interrupt
       1051 : CA 00                      st      A, ACIA_C, P2
       1053 :                    putchar_exit:
       1053 : 5E                         pop     P2
       1054 : 3A                         pop     EA
       1055 : 3B 01                      or      S, =S_IE        ; enable IRQ
       1057 : 5C                         ret
       1058 :
       1058 :                    ;;; Put newline
       1058 :                    ;;; @clobber A
       1058 :                    newline:
       1058 : C4 0D                      ld      A, =X'0D
       105A : 20 34 10                   jsr     putchar
       105D : C4 0A                      ld      A, =X'0A
       105F : 74 D4                      bra     putchar
       1061 :
       1061 :                    ;;; Put space
       1061 :                    ;;; @clobber A
       1061 :                    putspace:
       1061 : C4 20                      ld      A, =' '
       1063 : 74 D0                      bra     putchar
       1065 :
       1065 :                            include "arith.inc"
(1)    1065 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    1065 :
(1)    1065 :                    ;;; Print signed 16-bit integer as decimal
(1)    1065 :                    ;;; @param EA: value
(1)    1065 :                    print_int16:
(1)    1065 : 57                         push    P3
(1)    1066 : 08                         push    EA
(1)    1067 : 47                         ld      P3, EA          ; P3=value
(1)    1068 : 40                         ld      A, E            ; A=high(value)
(1)    1069 : 64 0B                      bp      print_int16_plus
(1)    106B : C4 2D                      ld      A, ='-'
(1)    106D : 20 34 10                   jsr     putchar         ; print '-'
(1)    1070 : 84 00 00                   ld      EA, =0
(1)    1073 : B9 00                      sub     EA, 0, SP       ; negate value
(1)    1075 : 47                         ld      P3, EA          ; P3=|value|
(1)    1076 :                    print_int16_plus:
(1)    1076 : 20 7B 10                   jsr     print_uint16
(1)    1079 : 3A                         pop     EA
(1)    107A : 5F                         pop     P3
(1)    107B : 5C                         ret
(1)    107C :                    ;;; Print unsigned 16-bit integer
(1)    107C :                    ;;; @param P3 value
(1)    107C :                    print_uint16:
(1)    107C : 33                         ld      EA, P3
(1)    107D : 58                         or      A, E
(1)    107E : 6C 0C                      bz      print_uint16_zero
(1)    1080 :                    print_uint16_loop:
(1)    1080 : 33                         ld      EA, P3
(1)    1081 : 58                         or      A, E
(1)    1082 : 6C 0D                      bz      print_uint16_end
(1)    1084 : 20 91 10                   jsr     divmod10        ; P3=value/10, EA=value%10
(1)    1087 : 0A                         push    A               ; push reminder
(1)    1088 : 20 7F 10                   jsr     print_uint16_loop
(1)    108B : 38                         pop     A
(1)    108C :                    print_uint16_zero:
(1)    108C : DC 30                      or      A, ='0'
(1)    108E : 20 34 10                   jsr     putchar
(1)    1091 :                    print_uint16_end:
(1)    1091 : 5C                         ret
(1)    1092 :
(1)    1092 :                    ;;; Divide by 10
(1)    1092 :                    ;;; @param P3 value
(1)    1092 :                    ;;; @return P3 value/10
(1)    1092 :                    ;;; @return EA value%10
(1)    1092 :                    divmod10:
(1)    1092 : 33                         ld      EA, P3
(1)    1093 : A4 0A 00                   ld      T, =10
(1)    1096 : 0D                         div     EA, T
(1)    1097 : 08                         push    EA              ; save value/10
(1)    1098 : A4 0A 00                   ld      T, =10
(1)    109B : 2C                         mpy     EA, T           ; T=(value/10)*10
(1)    109C : 0B                         ld      EA, T
(1)    109D : 08                         push    EA              ; local variable
(1)    109E : 33                         ld      EA, P3          ; EA=value
(1)    109F : B9 00                      sub     EA, 0, SP       ; EA=value-(value/10)*10
(1)    10A1 : 5F                         pop     P3              ; discard local
(1)    10A2 : 5F                         pop     P3              ; restore value/10
(1)    10A3 : 5C                         ret
(1)    10A4 :
(1)    10A4 :                    ;;; Signed comparison: minuend - subtrahend
(1)    10A4 :                    ;;; @param EA minuend
(1)    10A4 :                    ;;; @param T  subtrahend
(1)    10A4 :                    ;;; @return A=0  BZ (minuend == subtrahend)
(1)    10A4 :                    ;;;         A=1  BP (minuend > subtrahend)
(1)    10A4 :                    ;;;         A=-1    (minuend < subtrahend)
(1)    10A4 :                    ;;; @clobber EA
(1)    10A4 :                    cmpsi2:
(1)    10A4 : 08                         push    EA              ; S[1:0]=minuend
(1)    10A5 : 0B                         ld      EA, T           ; EA=subtrahend
(1)    10A6 : B9 00                      sub     EA, 0, SP       ; EA=subtrahend-minuend
(1)    10A8 : 89 00                      st      EA, 0, SP
(1)    10AA : 58                         or      A, E
(1)    10AB : 6C 16                      bz      cmpsi2_equal    ; branch if A=0
(1)    10AD : C1 01                      ld      A, 1, SP
(1)    10AF : 64 09                      bp      cmpsi2_plus     ; branch if A>0 (N=0)
(1)    10B1 :                    cmpsi2_minus:                   ; A<0 (N=1)
(1)    10B1 : 06                         ld      A, S
(1)    10B2 : D4 40                      and     A, =S_OV
(1)    10B4 : 7C 09                      bnz     cmpsi2_less     ; branch if V=1
(1)    10B6 :                            ;; V=0, N=1
(1)    10B6 :                    cmpsi2_great:                   ; N^V=1
(1)    10B6 : 3A                         pop     EA
(1)    10B7 : C4 01                      ld      A, =1
(1)    10B9 : 5C                         ret
(1)    10BA :                    cmpsi2_plus:                    ; N=0
(1)    10BA : 06                         ld      A, S
(1)    10BB : D4 40                      and     A, =S_OV
(1)    10BD : 7C F7                      bnz     cmpsi2_great    ; branch if V=1, N=0
(1)    10BF :                            ;; V=0, N=0
(1)    10BF :                    cmpsi2_less:                    ; N^V=0
(1)    10BF : 3A                         pop     EA
(1)    10C0 : C4 FF                      ld      A, =-1
(1)    10C2 : 5C                         ret
(1)    10C3 :                    cmpsi2_equal:
(1)    10C3 : 3A                         pop     EA
(1)    10C4 : C4 00                      ld      A, =0
(1)    10C6 : 5C                         ret
(1)    10C7 :
(1)    10C7 :                    ;;; Signed multiplication: product = multiplicand * multiplier
(1)    10C7 :                    ;;; @param EA: multiplicand
(1)    10C7 :                    ;;; @param T: multiplier
(1)    10C7 :                    ;;; @return EA: product
(1)    10C7 :                    ;;; @local SP[4:3] multiplicand
(1)    10C7 :                    ;;; @local SP[2:1] multiplier
(1)    10C7 :                    ;;; @local SP[0] sign(product)
(1)    10C7 :                    ;;; @discard T
(1)    10C7 :                    mulsi2:
(1)    10C7 : 08                         push    EA             ; save multiplicand
(1)    10C8 : 0B                         ld      EA, T          ; EA=multiplier
(1)    10C9 : 08                         push    EA             ; save multiplier
(1)    10CA : 40                         ld      A, E           ; A=high(multiplier)
(1)    10CB : E1 03                      xor     A, 3, SP       ; A=sign(product)
(1)    10CD : 0A                         push    A              ; save sign(product)
(1)    10CE : C1 02                      ld      A, 2, SP       ; A=high(multiplier)
(1)    10D0 : 64 07                      bp      mulsi2_multiplicand
(1)    10D2 : 84 00 00                   ld      EA, =0
(1)    10D5 : B9 01                      sub     EA, 1, SP
(1)    10D7 : 89 01                      st      EA, 1, SP       ; negate multiplier
(1)    10D9 :                    mulsi2_multiplicand:
(1)    10D9 : C1 04                      ld      A, 4, SP        ; A=high(multiplicand)
(1)    10DB : 64 07                      bp      mulsi2_multiply
(1)    10DD : 84 00 00                   ld      EA, =0
(1)    10E0 : B9 03                      sub     EA, 3, SP
(1)    10E2 : 89 03                      st      EA, 3, SP       ; negate multiplicand
(1)    10E4 :                    mulsi2_multiply:
(1)    10E4 : 81 03                      ld      EA, 3, SP       ; EA=|multiplicand|
(1)    10E6 : A1 01                      ld      T, 1, SP        ; T=|multiplier|
(1)    10E8 : 2C                         mpy     EA, T           ; T=product
(1)    10E9 : 0B                         ld      EA, T
(1)    10EA : 89 03                      st      EA, 3, SP       ; store product
(1)    10EC : 38                         pop     A               ; A=high(multiplicand^multiplier)
(1)    10ED : 64 07                      bp      mulsi2_exit
(1)    10EF : 84 00 00                   ld      EA, =0
(1)    10F2 : B9 02                      sub     EA, 2, SP       ; negate product
(1)    10F4 : 89 02                      st      EA, 2, SP       ; store product
(1)    10F6 :                    mulsi2_exit:
(1)    10F6 : 3A                         pop     EA
(1)    10F7 : 09                         ld      T, EA           ; T=multiplier
(1)    10F8 : 3A                         pop     EA              ; EA=product
(1)    10F9 : 5C                         ret
(1)    10FA :
(1)    10FA :                    ;;; Signed division: quotient = dividend * divisor
(1)    10FA :                    ;;; @param EA: dividend
(1)    10FA :                    ;;; @param T: divisor
(1)    10FA :                    ;;; @return EA: quotient
(1)    10FA :                    ;;; @discard T
(1)    10FA :                    ;;; @local SP[4:3] dividend
(1)    10FA :                    ;;; @local SP[2:1] divisor
(1)    10FA :                    ;;; @local SP[0] sign(quotient)
(1)    10FA :                    divsi2:
(1)    10FA : 08                         push    EA              ; save dividend
(1)    10FB : 0B                         ld      EA, T           ; EA=divisor
(1)    10FC : 08                         push    EA              ; save divisor
(1)    10FD : 40                         ld      A, E            ; A=high(divisor)
(1)    10FE : E1 03                      xor     A, 3, SP        ; A=sign(quotient)
(1)    1100 : 0A                         push    A               ; save sign(quotient)
(1)    1101 : C1 02                      ld      A, 2, SP        ; A=high(divisor)
(1)    1103 : 64 07                      bp      divsi2_dividend
(1)    1105 : 84 00 00                   ld      EA, =0
(1)    1108 : B9 01                      sub     EA, 1, SP
(1)    110A : 89 01                      st      EA, 1, SP       ; negate divisor
(1)    110C :                    divsi2_dividend:
(1)    110C : C1 04                      ld      A, 4, SP        ; A=high(dividend)
(1)    110E : 64 07                      bp      divsi2_divide
(1)    1110 : 84 00 00                   ld      EA, =0
(1)    1113 : B9 03                      sub     EA, 3, SP
(1)    1115 : 89 03                      st      EA, 3, SP       ; negate dividend
(1)    1117 :                    divsi2_divide:
(1)    1117 : 81 03                      ld      EA, 3, SP       ; EA=|dividend|
(1)    1119 : A1 01                      ld      T, 1, SP        ; T=|divisor|
(1)    111B : 0D                         div     EA, T           ; EA=quotient
(1)    111C : 89 03                      st      EA, 3, SP       ; store quotient
(1)    111E : 38                         pop     A               ; A=sign(quotient)
(1)    111F : 64 07                      bp      divsi2_exit
(1)    1121 : 84 00 00                   ld      EA, =0
(1)    1124 : B9 02                      sub     EA, 2, SP       ; negate quotient
(1)    1126 : 89 02                      st      EA, 2, SP       ; store quotient
(1)    1128 :                    divsi2_exit:
(1)    1128 : 3A                         pop     EA
(1)    1129 : 09                         ld      T, EA           ; T=divisor
(1)    112A : 3A                         pop     EA              ; EA=quotient
(1)    112B : 5C                         ret
       112C :                            include "mandelbrot.inc"
(1)    112C :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    112C :                    mandelbrot:
(1)    112C : 26 34 12                   ld      P2, =mandelbrot_work
(1)    112F :
(1)    112F : 84 32 00                   ld      EA, =50
(1)    1132 : 8A 00                      st      EA, vF, P2      ; F=50
(1)    1134 : 84 F4 FF                   ld      EA, =-12
(1)    1137 : 8A 12                      st      EA, vY, P2      ; Y=-12
(1)    1139 :                    loop_y:
(1)    1139 : 84 CF FF                   ld      EA, =-49
(1)    113C : 8A 14                      st      EA, vX, P2      ; X=-49
(1)    113E :                    loop_x:
(1)    113E : 82 14                      ld      EA, vX, P2
(1)    1140 : A4 E5 00                   ld      T, =229
(1)    1143 : 20 C6 10                   jsr     mulsi2
(1)    1146 : A4 64 00                   ld      T, =100
(1)    1149 : 20 F9 10                   jsr     divsi2
(1)    114C : 8A 02                      st      EA, vC, P2      ; C=X*229/100
(1)    114E : 82 12                      ld      EA, vY, P2
(1)    1150 : A4 A0 01                   ld      T, =416
(1)    1153 : 20 C6 10                   jsr     mulsi2
(1)    1156 : A4 64 00                   ld      T, =100
(1)    1159 : 20 F9 10                   jsr     divsi2          ; D=Y*416/100
(1)    115C : 8A 04                      st      EA, vD, P2
(1)    115E : 82 02                      ld      EA, vC, P2
(1)    1160 : 8A 06                      st      EA, vA, P2      ; A=C
(1)    1162 : 82 04                      ld      EA, vD, P2
(1)    1164 : 8A 08                      st      EA, vB, P2      ; B=D
(1)    1166 : 84 00 00                   ld      EA, =0
(1)    1169 : 8A 16                      st      EA, vI, P2      ; I=0
(1)    116B :
(1)    116B :                            ;; ld      A, ='Y'
(1)    116B :                            ;; ld      T, vY, P2
(1)    116B :                            ;; jsr     print
(1)    116B :                            ;; ld      A, ='X'
(1)    116B :                            ;; ld      T, vX, P2
(1)    116B :                            ;; jsr     print
(1)    116B :                            ;; ld      A, ='C'
(1)    116B :                            ;; ld      T, vC, P2
(1)    116B :                            ;; jsr     print
(1)    116B :                            ;; ld      A, ='D'
(1)    116B :                            ;; ld      T, vD, P2
(1)    116B :                            ;; jsr     print
(1)    116B :                            ;; jsr     newline
(1)    116B :
(1)    116B :                    loop_i:
(1)    116B : 82 08                      ld      EA, vB, P2
(1)    116D : A2 00                      ld      T, vF, P2
(1)    116F : 20 F9 10                   jsr     divsi2          ; Q=B/F
(1)    1172 : 8A 0C                      st      EA, vQ, P2
(1)    1174 : A2 00                      ld      T, -vF, P2
(1)    1176 : 20 C6 10                   jsr     mulsi2          ; -Q*F
(1)    1179 : B2 08                      add     EA, vB, P2      ; B-Q*F
(1)    117B : 8A 0E                      st      EA, vS, P2      ; S=B-Q*F
(1)    117D : 82 08                      ld      EA, vB, P2
(1)    117F : 09                         ld      T, EA
(1)    1180 : 20 C6 10                   jsr     mulsi2          ; tmp=B*B
(1)    1183 : 8A 18                      st      EA, tmp, P2
(1)    1185 : 82 06                      ld      EA, vA, P2
(1)    1187 : 09                         ld      T, EA
(1)    1188 : 20 C6 10                   jsr     mulsi2          ; A*A
(1)    118B : BA 18                      sub     EA, tmp, P2     ; A*A-B*B
(1)    118D : A2 00                      ld      T, vF, P2
(1)    118F : 20 F9 10                   jsr     divsi2          ; T=(A*A-B*B)/F
(1)    1192 : B2 02                      add     EA, vC, P2
(1)    1194 : 8A 10                      st      EA, vT, P2      ; T=(A*A-B*B)/F+C
(1)    1196 : 82 06                      ld      EA, vA, P2
(1)    1198 : A2 0E                      ld      T, vS, P2
(1)    119A : 20 C6 10                   jsr     mulsi2          ; tmp=A*S
(1)    119D : A2 00                      ld      T, vF, P2
(1)    119F : 20 F9 10                   jsr     divsi2          ; tmp=A*S/F
(1)    11A2 : 8A 18                      st      EA, tmp, P2
(1)    11A4 : 82 06                      ld      EA, vA, P2
(1)    11A6 : A2 0C                      ld      T, vQ, P2
(1)    11A8 : 20 C6 10                   jsr     mulsi2          ; B=A*Q
(1)    11AB : B2 18                      add     EA, tmp, P2     ; B=A*Q+A*S/F
(1)    11AD : 0F                         sl      EA              ; B=2*(A*Q+A*S/F)
(1)    11AE : B2 04                      add     EA, vD, P2
(1)    11B0 : 8A 08                      st      EA, vB, P2      ; B=2*(A*Q+A*S/F)+D
(1)    11B2 : 82 10                      ld      EA, vT, P2
(1)    11B4 : 8A 06                      st      EA, vA, P2      ; A=T
(1)    11B6 : A2 00                      ld      T, vF, P2
(1)    11B8 : 20 F9 10                   jsr     divsi2          ; P=A/F
(1)    11BB : 8A 0A                      st      EA, vP, P2
(1)    11BD : 82 08                      ld      EA, vB, P2
(1)    11BF : A2 00                      ld      T, vF, P2
(1)    11C1 : 20 F9 10                   jsr     divsi2          ; Q=B/F
(1)    11C4 : 8A 0C                      st      EA, vQ, P2
(1)    11C6 : 09                         ld      T, EA
(1)    11C7 : 20 C6 10                   jsr     mulsi2          ; tmp=Q*Q
(1)    11CA : 8A 18                      st      EA, tmp, P2
(1)    11CC : 82 0A                      ld      EA, vP, P2
(1)    11CE : 09                         ld      T, EA
(1)    11CF : 20 C6 10                   jsr     mulsi2          ; T=P*P
(1)    11D2 : B2 18                      add     EA, tmp, P2     ; T=P*P+Q*Q
(1)    11D4 : 8A 10                      st      EA, vT, P2
(1)    11D6 :
(1)    11D6 :                            ;; jsr     putspace
(1)    11D6 :                            ;; ld      A, ='I'
(1)    11D6 :                            ;; ld      T, vI, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; ld      A, ='A'
(1)    11D6 :                            ;; ld      T, vA, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; ld      A, ='B'
(1)    11D6 :                            ;; ld      T, vB, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; ld      A, ='P'
(1)    11D6 :                            ;; ld      T, vP, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; ld      A, ='Q'
(1)    11D6 :                            ;; ld      T, vQ, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; ld      A, ='T'
(1)    11D6 :                            ;; ld      T, vT, P2
(1)    11D6 :                            ;; jsr     print
(1)    11D6 :                            ;; jsr     newline
(1)    11D6 :
(1)    11D6 : 84 04 00                   ld      EA, =4
(1)    11D9 : BA 10                      sub     EA, vT, P2      ; 4-T
(1)    11DB : 01                         xch     A, E
(1)    11DC : 64 0C                      bp      next_i          ; if 4>=T
(1)    11DE :                    print_i:
(1)    11DE : C2 16                      ld      A, vI, P2
(1)    11E0 : FC 0A                      sub     A, =10
(1)    11E2 : 64 02                      bp      print_i2        ; if I<10
(1)    11E4 : F4 F9                      add     A, =10+'0'-'A'
(1)    11E6 :                    print_i2:
(1)    11E6 : F4 41                      add     A, ='A'
(1)    11E8 : 74 0B                      bra     print_char
(1)    11EA :                    next_i:
(1)    11EA : 92 16                      ild     A, vI, P2       ; I+=1
(1)    11EC : FC 10                      sub     A, =16
(1)    11EE : 64 03                      bp      print_space     ; if I>=16
(1)    11F0 : 24 6A 11                   jmp     loop_i
(1)    11F3 :                    print_space:
(1)    11F3 : C4 20                      ld      A, =' '
(1)    11F5 :                    print_char:
(1)    11F5 : 20 34 10                   jsr     putchar
(1)    11F8 :
(1)    11F8 :                            ;; push    A
(1)    11F8 :                            ;; ld      A, ='@'
(1)    11F8 :                            ;; jsr     putchar
(1)    11F8 :                            ;; ld      A, ='='
(1)    11F8 :                            ;; jsr     putchar
(1)    11F8 :                            ;; pop     A
(1)    11F8 :                            ;; jsr     putchar
(1)    11F8 :                            ;; jsr     newline
(1)    11F8 :
(1)    11F8 : 20 28 10                   jsr     getchar
(1)    11FB : 6C 04                      bz      next_x
(1)    11FD : 40                         ld      A, E
(1)    11FE : 7C 01                      bnz     next_x
(1)    1200 : 1F                         call    15              ; halt to system
(1)    1201 :                    next_x:
(1)    1201 : 82 14                      ld      EA, vX, P2
(1)    1203 : B4 01 00                   add     EA, =1
(1)    1206 : 8A 14                      st      EA, vX, P2      ; X+=1
(1)    1208 : BC 1E 00                   sub     EA, =30
(1)    120B : 01                         xch     A, E
(1)    120C : 64 03                      bp      next_y          ; if X>=30
(1)    120E : 24 3D 11                   jmp     loop_x
(1)    1211 :                    next_y: 
(1)    1211 : 20 57 10                   jsr     newline
(1)    1214 : 82 12                      ld      EA, vY, P2
(1)    1216 : B4 01 00                   add     EA, =1
(1)    1219 : 8A 12                      st      EA, vY, P2
(1)    121B : BC 0D 00                   sub     EA, =13
(1)    121E : 01                         xch     A, E
(1)    121F : 64 03                      bp      mandelbrot_end  ; if Y>=13
(1)    1221 : 24 38 11                   jmp     loop_y
(1)    1224 :                    mandelbrot_end: 
(1)    1224 : 5C                         ret
(1)    1225 :
(1)    1225 :                    ;;; Print variable
(1)    1225 :                    ;;; @param A variable name
(1)    1225 :                    ;;; @param T variable value
(1)    1225 :                    print:
(1)    1225 : 20 34 10                   jsr     putchar
(1)    1228 : C4 3D                      ld      A, ='='
(1)    122A : 20 34 10                   jsr     putchar
(1)    122D : 0B                         ld      EA, T
(1)    122E : 20 64 10                   jsr     print_int16
(1)    1231 : 24 60 10                   jmp     putspace
(1)    1234 :
(1)    1234 :                    mandelbrot_work:
(1)    1234 : =0                 vF      =       .-mandelbrot_work
(1)    1234 : 00 00                      .dbyte  0
(1)    1236 : =2                 vC      =       .-mandelbrot_work
(1)    1236 : 00 00              	.dbyte	0
(1)    1238 : =4                 vD      =       .-mandelbrot_work
(1)    1238 : 00 00              	.dbyte	0
(1)    123A : =6                 vA      =       .-mandelbrot_work
(1)    123A : 00 00              	.dbyte	0
(1)    123C : =8                 vB      =       .-mandelbrot_work
(1)    123C : 00 00              	.dbyte	0
(1)    123E : =A                 vP      =       .-mandelbrot_work
(1)    123E : 00 00              	.dbyte	0
(1)    1240 : =C                 vQ      =       .-mandelbrot_work
(1)    1240 : 00 00              	.dbyte	0
(1)    1242 : =E                 vS      =       .-mandelbrot_work
(1)    1242 : 00 00              	.dbyte	0
(1)    1244 : =10                vT      =       .-mandelbrot_work
(1)    1244 : 00 00              	.dbyte	0
(1)    1246 : =12                vY      =       .-mandelbrot_work
(1)    1246 : 00 00              	.dbyte	0
(1)    1248 : =14                vX      =       .-mandelbrot_work
(1)    1248 : 00 00              	.dbyte	0
(1)    124A : =16                vI      =       .-mandelbrot_work
(1)    124A : 00 00              	.dbyte	0
(1)    124C : =18                tmp     =       .-mandelbrot_work
(1)    124C : 00 00                      .dbyte  0
       124E :                            include "queue.inc"
(1)    124E :                    ;;; [queue] queue structure
(1)    124E : =0                 queue_len       =       0       ; queue length
(1)    124E : =1                 queue_size      =       1       ; buffer size
(1)    124E : =2                 queue_put       =       2       ; queue put index
(1)    124E : =3                 queue_get       =       3       ; queue get index
(1)    124E : =4                 queue_buf       =       4       ; buffer start offset
(1)    124E :
(1)    124E :                    ;;; [queue] Initialize queue
(1)    124E :                    ;;; @param P2 queue work space pointer
(1)    124E :                    ;;; @param A queue work space size
(1)    124E :                    ;;; @clobber A
(1)    124E :                    queue_init:
(1)    124E : 48                         ld      E, A
(1)    124F : C4 00                      ld      A, =0
(1)    1251 : CA 00                      st      A, queue_len, P2
(1)    1253 : CA 02                      st      A, queue_put, P2
(1)    1255 : CA 03                      st      A, queue_get, P2
(1)    1257 : 01                         xch     A, E            ; E=0, A=space size
(1)    1258 : FC 04                      sub     A, =queue_buf
(1)    125A : CA 01                      st      A, queue_size, P2
(1)    125C : 0A                         push    A               ; 0,SP=counter
(1)    125D : C6 04                      ld      A, @queue_buf, P2
(1)    125F :                    queue_init_loop:
(1)    125F : 40                         ld      A, E            ; E=0
(1)    1260 : CE 01                      st      A, @1, P2
(1)    1262 : 99 00                      dld     A, 0, SP
(1)    1264 : 7C F9                      bnz     queue_init_loop
(1)    1266 : 38                         pop     A               ; discard counter
(1)    1267 : 5C                         ret
(1)    1268 :
(1)    1268 :                    ;;; [add_p2_a] Add A to P2
(1)    1268 :                    ;;; @param P2
(1)    1268 :                    ;;; @param A
(1)    1268 :                    ;;; @return P3=P2+A
(1)    1268 :                    add_p2_a:
(1)    1268 : 08                         push    ea              ; save EA
(1)    1269 : 01                         xch     A, E
(1)    126A : C4 00                      ld      A, =0
(1)    126C : 01                         xch     A, E
(1)    126D : 08                         push    ea              ; 0:E
(1)    126E : 32                         ld      ea, P2
(1)    126F : B1 00                      add     ea, 0, SP       ; EA=P2+E
(1)    1271 : 47                         ld      P3, ea
(1)    1272 : 3A                         pop     ea
(1)    1273 : 3A                         pop     ea              ; restore EA
(1)    1274 : 5C                         ret
(1)    1275 :
(1)    1275 :                    ;;; [queue] Add an element to queue
(1)    1275 :                    ;;; @param P2 queue work space pointer
(1)    1275 :                    ;;; @param A an element
(1)    1275 :                    ;;; @return E an element
(1)    1275 :                    ;;; @return A 0 if queue is full
(1)    1275 :                    queue_add:
(1)    1275 : 57                         push    P3
(1)    1276 : 48                         ld      E, A            ; save element in E
(1)    1277 : C2 00                      ld      A, queue_len, P2
(1)    1279 : FA 01                      sub     A, queue_size, P2
(1)    127B : 6C 14                      bz      queue_add_return ; A=0
(1)    127D : C2 02                      ld      A, queue_put, P2 ; 8 bits offset
(1)    127F : 20 67 12                   jsr     add_p2_a
(1)    1282 : 40                         ld      A, E
(1)    1283 : CB 04                      st      A, queue_buf, P3 ; store an element
(1)    1285 : 92 00                      ild     A, queue_len, P2
(1)    1287 : 92 02                      ild     A, queue_put, P2
(1)    1289 : FA 01                      sub     A, queue_size, P2
(1)    128B : 7C 04                      bnz     queue_add_return ; A is not zero
(1)    128D : CA 02                      st      A, queue_put, P2
(1)    128F : C4 01                      ld      A, =1           ; A is not zero
(1)    1291 :                    queue_add_return:
(1)    1291 : 5F                         pop     P3
(1)    1292 : 5C                         ret
(1)    1293 :
(1)    1293 :                    ;;; [queue] Remove an element from queue
(1)    1293 :                    ;;; @param P2 queue work space pointer
(1)    1293 :                    ;;; @return E an element
(1)    1293 :                    ;;; @return A 0 if queue is empty
(1)    1293 :                    queue_remove:
(1)    1293 : 57                         push    P3
(1)    1294 : C2 00                      ld      A, queue_len, P2
(1)    1296 : 6C 14                      bz      queue_remove_return ; A is zero
(1)    1298 :                    queue_remove_elem
(1)    1298 : C2 03                      ld      A, queue_get, P2 ; 8 bits offset
(1)    129A : 20 67 12                   jsr     add_p2_a
(1)    129D : C3 04                      ld      A, queue_buf, P3 ; read an element
(1)    129F : 48                         ld      E, A
(1)    12A0 : 9A 00                      dld     A, queue_len, P2
(1)    12A2 : 92 03                      ild     A, queue_get, P2
(1)    12A4 : FA 01                      sub     A, queue_size, P2
(1)    12A6 : 7C 04                      bnz     queue_remove_return ; A is not zero
(1)    12A8 : CA 03                      st      A, queue_get, P2 ; A is zero
(1)    12AA : C4 01                      ld      A, =1            ; A is not zero
(1)    12AC :                    queue_remove_return:
(1)    12AC : 5F                         pop     P3
(1)    12AD : 5C                         ret
(1)    12AE :
(1)    12AE :                    ;;; Local Variables:
(1)    12AE :                    ;;; mode: asm
(1)    12AE :                    ;;; End:
(1)    12AE :                    ;;; vim: set ft=asm et ts=4 sw=4:
       12AE :
       12AE :                    isr_irq:
       12AE : 08                         push    ea
       12AF : 22 00 DF                   pli     P2, =ACIA
       12B2 : C2 00                      ld      A, ACIA_S, P2
       12B4 : 48                         ld      E, A            ; save ACIA status in E
       12B5 : D4 80                      and     A, =IRQF_bm
       12B7 : 6C 2E                      bz      isr_irq_exit
       12B9 : 40                         ld      A, E
       12BA : D4 70                      and     A, =FERR_bm|OVRN_bm|PERR_bm
       12BC : 6C 02                      bz      isr_irq_receive
       12BE : C2 01                      ld      A, ACIA_D, P2   ; clear errors
       12C0 :                    isr_irq_receive:
       12C0 : 40                         ld      A, E
       12C1 : 0A                         push    A               ; save ACIA status
       12C2 : D4 01                      and     A, =RDRF_bm
       12C4 : 6C 08                      bz      isr_irq_send
       12C6 : C2 01                      ld      A, ACIA_D, P2   ; receive character
       12C8 : 26 00 20                   ld      P2, =rx_queue
       12CB : 20 74 12                   jsr     queue_add
       12CE :                    isr_irq_send:
       12CE : 38                         pop     A               ; restore ACIA status
       12CF : D4 02                      and     A, =TDRE_bm
       12D1 : 6C 14                      bz      isr_irq_exit
       12D3 : 26 10 20                   ld      P2, =tx_queue
       12D6 : 20 92 12                   jsr     queue_remove
       12D9 : 26 00 DF                   ld      P2, =ACIA
       12DC : 6C 05                      bz      isr_irq_send_empty
       12DE : 40                         ld      A, E
       12DF : CA 01                      st      A, ACIA_D, P2   ; send character
       12E1 : 74 04                      bra     isr_irq_exit
       12E3 :                    isr_irq_send_empty:
       12E3 : C4 94                      ld      A, =RX_INT_TX_NO
       12E5 : CA 00                      st      A, ACIA_C, P2   ; disable Tx interrupt
       12E7 :                    isr_irq_exit:
       12E7 : 5E                         pop     P2
       12E8 : 3A                         pop     ea
       12E9 : 3B 01                      or      S, =S_IE
       12EB : 5C                         ret
       12EC :
       12EC :                            end
