          0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
          0 :                            cpu     ins8060
          0 :                            include "ins8060.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                    ;;; INS8060
(1)       0 :                    ;;; Status Register
(1)       0 : =80                S_CY    =       X'80           ; Carry bit
(1)       0 : =80                S_L     =       X'80           ; Link bit
(1)       0 : =40                S_OV    =       X'40           ; Overflow bit
(1)       0 : =20                S_SB    =       X'20           ; Sense B bit
(1)       0 : =10                S_SA    =       X'10           ; Sense A bit
(1)       0 : =8                 S_IE    =       X'08           ; Interrupt Enable bit
(1)       0 : =4                 S_F2    =       X'04           ; Flag 2 bit
(1)       0 : =2                 S_F1    =       X'02           ; Flag 1 bit
(1)       0 : =1                 S_F0    =       X'01           ; flag 0 bit
(1)       0 :
(1)       0 :                    ;;; Dynamic Offset by E register
(1)       0 : =80                OFFSET_E        =       X'80    ; offset by E register
(1)       0 :
(1)       0 :                    ;;; Transfer locations
(1)       0 : =1                 ORG_RESTART     =       X'0001  ; Restart transfer location
          0 :
          0 :                    ;;; MC6850 Asynchronous Communication Interface Adapter
          0 : =DF00              ACIA    =       X'DF00
          0 :                            include "mc6850.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; MC6850
(1)       0 :                    ;;; Asynchronous Communication Interface Adapter
(1)       0 :
(1)       0 :                    ;;; Control register
(1)       0 : =DF00              ACIA_control    =       ACIA+0
(1)       0 :                            ;; Counter Divider Select Bits
(1)       0 : =3                 CDS_gm          =       X'03   ; Group mask
(1)       0 : =0                 CDS_DIV1_gc     =       X'00   ; /1
(1)       0 : =1                 CDS_DIV16_gc    =       X'01   ; /16
(1)       0 : =2                 CDS_DIV64_gc    =       X'02   ; /64
(1)       0 : =3                 CDS_RESET_gc    =       X'03   ; Master Reset
(1)       0 :                            ;; Word Select Bits
(1)       0 : =1C                WSB_gm          =       X'1C   ; Group mask
(1)       0 : =0                 WSB_7E2_gc      =       X'00   ; 7 Bits + Even Parity + 2 Stop Bits
(1)       0 : =4                 WSB_7O2_gc      =       X'04   ; 7 bits + Odd Parity  + 2 Stop Bits
(1)       0 : =8                 WSB_7E1_gc      =       X'08   ; 7 bits + Even Parity + 1 Stop Bits
(1)       0 : =C                 WSB_7O1_gc      =       X'0C   ; 7 bits + Odd Parity  + 1 Stop Bits
(1)       0 : =10                WSB_8N2_gc      =       X'10   ; 8 bits + No Parity   + 2 Stop Bits
(1)       0 : =14                WSB_8N1_gc      =       X'14   ; 8 bits + No Parity   + 1 Stop Bits
(1)       0 : =18                WSB_8E1_gc      =       X'18   ; 8 bits + Even Parity + 1 Stop Bits
(1)       0 : =1C                WSB_8O1_gc      =       X'1C   ; 8 bits + Odd Parity  + 1 Stop Bits
(1)       0 :                            ;; Transmit Control Bits
(1)       0 : =60                TCB_gm          =       X'60   ; Group mask
(1)       0 : =0                 TCB_DI_gc       =       X'00   ; RTS=Low,  Tx Interrupt Disabled
(1)       0 : =20                TCB_EI_gc       =       X'20   ; RTS=Low,  Tx Interrupt Enabled
(1)       0 : =40                TCB_RTS_gc      =       X'40   ; RTS=High, Tx Interrupt Disabled
(1)       0 : =60                TCB_BREAK_gc    =       X'60   ; RTS=Low,  Tx Interrupt Disabled
(1)       0 :                                                    ; Transmit Break Level
(1)       0 : =80                RIEB_bm         =       X'80   ; Receive Interrupt Enable Bit mask
(1)       0 :
(1)       0 :                    ;;; Status register
(1)       0 : =DF00              ACIA_status     =       ACIA+0
(1)       0 : =1                 RDRF_bm         =       X'01   ; Receive Data Register Full
(1)       0 : =2                 TDRE_bm         =       X'02   ; Transmit Data Register Empty
(1)       0 : =4                 DCDF_bm         =       X'04   ; Data Carrier Detect Flag
(1)       0 : =8                 CTSF_bm         =       X'08   ; Clear To Send Flag
(1)       0 : =10                FERR_bm         =       X'10   ; Frame Error Flag
(1)       0 : =20                OVRN_bm         =       X'20   ; Receiver Overrun Flag
(1)       0 : =40                PERR_bm         =       X'40   ; Parity Error Flag
(1)       0 : =80                IRQF_bm         =       X'80   ; Interrupt Request Flag
(1)       0 :
(1)       0 :                    ;;; Data register
(1)       0 : =DF01              ACIA_data       =       ACIA+1  ; Data register
          0 : =0                 ACIA_C  =       0               ; ACIA control offset
          0 : =0                 ACIA_S  =       0               ; ACIA status offset
          0 : =1                 ACIA_D  =       1               ; ACIA data register offset
          0 :
          0 : =10                rx_queue_size   =       16
          0 : =30                tx_queue_size   =       48
          0 : =94                RX_INT_TX_NO    =       WSB_8N1_gc|RIEB_bm
          0 : =B4                RX_INT_TX_INT   =       WSB_8N1_gc|RIEB_bm|TCB_EI_gc
          0 :
       2000 :                            .=      X'2000
       2000 :                    rx_queue:
       2010 :                            .=      .+rx_queue_size
       2010 :                    tx_queue:
       2040 :                            .=      .+tx_queue_size
       2040 :
          1 :                            .=      ORG_RESTART
          1 : C4 FF                      ldi     L(stack)
          3 : 32                         xpal    P2
          4 : C4 0F                      ldi     H(stack)
          6 : 36                         xpah    P2
          7 : C4 6A                      ldi     L(ADDR(isr_sensea))
          9 : 33                         xpal    P3              ; setup interrupt entry P3
          A : C4 17                      ldi     H(ADDR(isr_sensea))
          C : 37                         xpah    P3
          D : C4 FF                      ldi     L(ADDR(initialize))
          F : 31                         xpal    P1
         10 : C4 1F                      ldi     H(ADDR(initialize))
         12 : 35                         xpah    P1
         13 : 3D                         xppc    P1
         14 :
       1000 :                            .=      X'1000
       1000 : =FFF               stack   =       .-1
       1000 :                    initialize:
       1000 : C4 94                      ldi     L(ADDR(queue_init))
       1002 : 31                         xpal    P1
       1003 : C4 16                      ldi     H(ADDR(queue_init))
       1005 : 35                         xpah    P1              ; P1=queue_init
       1006 : C4 10                      ldi     rx_queue_size
       1008 : 3D                         xppc    P1              ; call queue_init
       1009 : 00 20                      .dbyte  rx_queue
       100B : C4 30                      ldi     tx_queue_size
       100D : 3D                         xppc    P1              ; call queue init
       100E : 10 20                      .dbyte  tx_queue
       1010 :
       1010 :                            ;; initialize ACIA
       1010 : C4 00                      ldi     L(ACIA)
       1012 : 31                         xpal    P1
       1013 : C4 DF                      ldi     H(ACIA)
       1015 : 35                         xpah    P1
       1016 : C4 03                      ldi     CDS_RESET_gc    ; Master reset
       1018 : C9 00                      st      ACIA_C(P1)
       101A : C4 94                      ldi     RX_INT_TX_NO    ; 8 bits + No Parity + 1 Stop Bits
       101C :                                                    ; Transmit, Receive interrupts disabled
       101C : C9 00                      st      ACIA_C(P1)      ;
       101E : 05                         ien                     ; enable interrupt
       101F :
       101F :                    loop:
       101F : C4 EB                      ldi     L(ADDR(mandelbrot))
       1021 : 31                         xpal    P1
       1022 : C4 10                      ldi     H(ADDR(mandelbrot))
       1024 : 35                         xpah    P1
       1025 : 3D                         xppc    P1              ; call mandelbrot
       1026 : C4 74                      ldi     L(ADDR(newline))
       1028 : 31                         xpal    P1
       1029 : C4 16                      ldi     H(ADDR(newline))
       102B : 35                         xpah    P1
       102C : 3D                         xppc    P1              ; call mandelbrot
       102D : 90 F0                      jmp     loop
       102F :
       102F :                            include "mandelbrot.inc"
(1)    102F :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    102F :
(1)    102F : 32 00              cF:     .dbyte  50              ; constant
(1)    1031 : F4 FF              c_12:   .dbyte  -12
(1)    1033 : CF FF              c_49:   .dbyte  -49
(1)    1035 : E5 00              c229:   .dbyte  229
(1)    1037 : 64 00              c100:   .dbyte  100
(1)    1039 : A0 01              c416:   .dbyte  416
(1)    103B : 1E 00              c30:    .dbyte  30
(1)    103D : 0D 00              c13:    .dbyte  13
(1)    103F : =103F              vBASE   =       .
(1)    103F : 00 00              vC:     .dbyte  0
(1)    1041 : 00 00              vD:     .dbyte  0
(1)    1043 : 00 00              vA:     .dbyte  0
(1)    1045 : 00 00              vB:     .dbyte  0
(1)    1047 : 00 00              vS:     .dbyte  0
(1)    1049 : 00 00              vP:     .dbyte  0
(1)    104B : 00 00              vQ:     .dbyte  0
(1)    104D : 00 00              vT:     .dbyte  0
(1)    104F : 00 00              vT1:    .dbyte  0
(1)    1051 : 00 00              vT2:    .dbyte  0
(1)    1053 : 00                 vY:     .byte  0
(1)    1054 : 00                 vX:     .byte  0
(1)    1055 : 00                 vI:     .byte  0
(1)    1056 :
(1)    1056 :                    ;;; Print variable "vname=value "
(1)    1056 :                    ;;;   xppc   P1
(1)    1056 :                    ;;;   .byte  vname
(1)    1056 :                    ;;;   .dbyte &value
(1)    1056 :                    ;;; @local P[1:0] &value
(1)    1056 :                    ;;; @local P[3:2] return address
(1)    1056 :                    print_exit:
(1)    1056 : C6 02                      ld      @2(P2)          ; discard local
(1)    1058 : C6 01                      ld      @1(P2)
(1)    105A : 31                         xpal    P1
(1)    105B : C6 01                      ld      @1(P2)
(1)    105D : 35                         xpah    P1
(1)    105E : 3D                         xppc    P1              ; return
(1)    105F :                    print:
(1)    105F : C5 01                      ld      @1(P1)          ; point vname
(1)    1061 : C5 01                      ld      @1(P1)
(1)    1063 : 01                         xae                     ; E=vname
(1)    1064 : C5 01                      ld      @1(P1)
(1)    1066 : CE FC                      st      @-4(P2)         ; P2[1:0]=&value
(1)    1068 : C1 00                      ld      0(P1)           ; P1=return address
(1)    106A : CA 01                      st      1(P2)
(1)    106C : C2 00                      ld      0(P2)           ; P2[1:0]=&value
(1)    106E : 31                         xpal    P1
(1)    106F : CA 02                      st      2(P2)           ; P2[3:2]=return address
(1)    1071 : C2 01                      ld      1(P2)
(1)    1073 : 35                         xpah    P1              ; P1=&value
(1)    1074 : CA 03                      st      3(P2)
(1)    1076 : C1 00                      ld      0(P1)           ; vDEBUG=value
(1)    1078 : C8 24                      st      vDEBUG
(1)    107A : C1 01                      ld      1(P1)
(1)    107C : C8 21                      st      vDEBUG+1
(1)    107E : C4 4F                      ldi     L(ADDR(putchar))
(1)    1080 : 31                         xpal    P1
(1)    1081 : C4 16                      ldi     H(ADDR(putchar))
(1)    1083 : 35                         xpah    P1              ; P1=ADDR(putchar)
(1)    1084 : 40                         lde                     ; A=vname
(1)    1085 : 3D                         xppc    P1              ; print vname
(1)    1086 : C4 3D                      ldi     '='
(1)    1088 : 3D                         xppc    P1              ; print '='
(1)    1089 : C4 FD                      ldi     L(ADDR(print_int16))
(1)    108B : 31                         xpal    P1
(1)    108C : C4 12                      ldi     H(ADDR(print_int16))
(1)    108E : 35                         xpah    P1
(1)    108F : 3D                         xppc    P1
(1)    1090 : 9D 10                      .dbyte  vDEBUG
(1)    1092 : C4 4F                      ldi     L(ADDR(putchar))
(1)    1094 : 31                         xpal    P1
(1)    1095 : C4 16                      ldi     H(ADDR(putchar))
(1)    1097 : 35                         xpah    P1              ; P1=ADDR(putchar)
(1)    1098 : C4 20                      ldi     ' '
(1)    109A : 3D                         xppc    P1              ; print space
(1)    109B : 90 B9                      jmp     print_exit
(1)    109D : 02 00              vDEBUG: .dbyte  2
(1)    109F :
(1)    109F :                    ;;; Print variable "vname=value "
(1)    109F :                    ;;;   xppc   P1
(1)    109F :                    ;;;   .byte  vname
(1)    109F :                    ;;;   .dbyte &value
(1)    109F :                    ;;; @local P[1:0] &value
(1)    109F :                    ;;; @local P[3:2] return address
(1)    109F :                    print_int8_exit:
(1)    109F : C6 02                      ld      @2(P2)          ; discard local
(1)    10A1 : C6 01                      ld      @1(P2)
(1)    10A3 : 31                         xpal    P1
(1)    10A4 : C6 01                      ld      @1(P2)
(1)    10A6 : 35                         xpah    P1
(1)    10A7 : 3D                         xppc    P1              ; return
(1)    10A8 :                    print_int8:
(1)    10A8 : C5 01                      ld      @1(P1)          ; point vname
(1)    10AA : C5 01                      ld      @1(P1)
(1)    10AC : 01                         xae                     ; E=vname
(1)    10AD : C5 01                      ld      @1(P1)
(1)    10AF : CE FC                      st      @-4(P2)         ; P2[1:0]=&value
(1)    10B1 : C1 00                      ld      0(P1)           ; P1=return address
(1)    10B3 : CA 01                      st      1(P2)
(1)    10B5 : C2 00                      ld      0(P2)           ; P2[1:0]=&value
(1)    10B7 : 31                         xpal    P1
(1)    10B8 : CA 02                      st      2(P2)           ; P2[3:2]=return address
(1)    10BA : C2 01                      ld      1(P2)
(1)    10BC : 35                         xpah    P1              ; P1=&value
(1)    10BD : CA 03                      st      3(P2)
(1)    10BF : C1 00                      ld      0(P1)           ; vDEBUG=value
(1)    10C1 : C8 DB                      st      vDEBUG
(1)    10C3 : 98 04                      jz      print_int8_plus
(1)    10C5 : C4 FF                      ldi     -1
(1)    10C7 : 90 02                      jmp     print_int8_extend
(1)    10C9 :                    print_int8_plus:
(1)    10C9 : C4 00                      ldi     0
(1)    10CB :                    print_int8_extend:
(1)    10CB : C8 D2                      st      vDEBUG+1
(1)    10CD : C4 4F                      ldi     L(ADDR(putchar))
(1)    10CF : 31                         xpal    P1
(1)    10D0 : C4 16                      ldi     H(ADDR(putchar))
(1)    10D2 : 35                         xpah    P1              ; P1=ADDR(putchar)
(1)    10D3 : 40                         lde                     ; A=vname
(1)    10D4 : 3D                         xppc    P1              ; print vname
(1)    10D5 : C4 3D                      ldi     '='
(1)    10D7 : 3D                         xppc    P1              ; print '='
(1)    10D8 : C4 FD                      ldi     L(ADDR(print_int16))
(1)    10DA : 31                         xpal    P1
(1)    10DB : C4 12                      ldi     H(ADDR(print_int16))
(1)    10DD : 35                         xpah    P1
(1)    10DE : 3D                         xppc    P1
(1)    10DF : 9D 10                      .dbyte  vDEBUG
(1)    10E1 : C4 4F                      ldi     L(ADDR(putchar))
(1)    10E3 : 31                         xpal    P1
(1)    10E4 : C4 16                      ldi     H(ADDR(putchar))
(1)    10E6 : 35                         xpah    P1              ; P1=ADDR(putchar)
(1)    10E7 : C4 20                      ldi     ' '
(1)    10E9 : 3D                         xppc    P1              ; print space
(1)    10EA : 90 B3                      jmp     print_int8_exit
(1)    10EC :
(1)    10EC :                    mandelbrot:
(1)    10EC : C4 10                      ldi     H(vY)
(1)    10EE : 35                         xpah    P1
(1)    10EF : CE FF                      st      @-1(P2)
(1)    10F1 : C4 53                      ldi     L(vY)
(1)    10F3 : 31                         xpal    P1
(1)    10F4 : CE FF                      st      @-1(P2)         ; save return address
(1)    10F6 : C4 F4                      ldi     -12
(1)    10F8 : C9 00                      st      0(P1)           ; Y=-12
(1)    10FA :                    loop_y:
(1)    10FA : C4 54                      ldi     L(vX)
(1)    10FC : 31                         xpal    P1
(1)    10FD : C4 10                      ldi     H(vX)
(1)    10FF : 35                         xpah    P1
(1)    1100 : C4 CF                      ldi     -49
(1)    1102 : C9 00                      st      0(P1)           ; X=-49
(1)    1104 :                    loop_x:
(1)    1104 : C4 3F                      ldi     L(vBASE)
(1)    1106 : 31                         xpal    P1
(1)    1107 : C4 10                      ldi     H(vBASE)
(1)    1109 : 35                         xpah    P1              ; P1=vBASE
(1)    110A : C1 15                      ld      (vX-vBASE)(P1)
(1)    110C : C9 00                      st      (vC-vBASE)(P1)  ; C=X
(1)    110E : 94 04                      jp      X_plus
(1)    1110 : C4 FF                      ldi     -1
(1)    1112 : 90 02                      jmp     X_extend
(1)    1114 : C4 00              X_plus: ldi     0
(1)    1116 :                    X_extend:
(1)    1116 : C9 01                      st      (vC-vBASE+1)(P1)
(1)    1118 : C1 14                      ld      (vY-vBASE)(P1)
(1)    111A : C9 02                      st      (vD-vBASE)(P1)  ; D=Y
(1)    111C : 94 04                      jp      Y_plus
(1)    111E : C4 FF                      ldi     -1
(1)    1120 : 90 02                      jmp     Y_extend
(1)    1122 : C4 00              Y_plus: ldi     0
(1)    1124 :                    Y_extend:
(1)    1124 : C9 03                      st      (vD-vBASE+1)(P1)
(1)    1126 : C4 6D                      ldi     L(ADDR(mulsi2))
(1)    1128 : 31                         xpal    P1
(1)    1129 : C4 14                      ldi     H(ADDR(mulsi2))
(1)    112B : 35                         xpah    P1              ; P1=ADDR(mulsi2)
(1)    112C : 3D                         xppc    P1              ; C=X*229
(1)    112D : 35 10                      .dbyte  c229
(1)    112F : 3F 10                      .dbyte  vC
(1)    1131 : 3D                         xppc    P1              ; D=Y*416
(1)    1132 : 39 10                      .dbyte  c416
(1)    1134 : 41 10                      .dbyte  vD
(1)    1136 : C4 1D                      ldi     L(ADDR(divsi2))
(1)    1138 : 31                         xpal    P1
(1)    1139 : C4 15                      ldi     H(ADDR(divsi2))
(1)    113B : 35                         xpah    P1              ; P1=ADDR(divsi2)
(1)    113C : 3D                         xppc    P1              ; C=X*229/100
(1)    113D : 37 10                      .dbyte  c100
(1)    113F : 3F 10                      .dbyte  vC
(1)    1141 : 3D                         xppc    P1              ; D=Y*416/100
(1)    1142 : 37 10                      .dbyte  c100
(1)    1144 : 41 10                      .dbyte  vD
(1)    1146 : C4 3F                      ldi     L(vBASE)
(1)    1148 : 31                         xpal    P1
(1)    1149 : C4 10                      ldi     H(vBASE)
(1)    114B : 35                         xpah    P1              ; P1=vBASE
(1)    114C : C1 00                      ld      (vC-vBASE)(P1)
(1)    114E : C9 04                      st      (vA-vBASE)(P1)  ; A=C
(1)    1150 : C1 01                      ld      (vC-vBASE+1)(P1)
(1)    1152 : C9 05                      st      (vA-vBASE+1)(P1)
(1)    1154 : C1 02                      ld      (vD-vBASE)(P1)
(1)    1156 : C9 06                      st      (vB-vBASE)(P1)  ; B=D
(1)    1158 : C1 03                      ld      (vD-vBASE+1)(P1)
(1)    115A : C9 07                      st      (vB-vBASE+1)(P1)
(1)    115C : C4 00                      ldi     0
(1)    115E : C9 16                      st      (vI-vBASE)(P1)  ; I=0
(1)    1160 :
(1)    1160 :                            ;; ldi     L(ADDR(print_int8))
(1)    1160 :                            ;; xpal    P1
(1)    1160 :                            ;; ldi     H(ADDR(print_int8))
(1)    1160 :                            ;; xpah    P1              ; P1=ADDR(print)
(1)    1160 :                            ;; xppc    P1              ; print Y
(1)    1160 :                            ;; .byte   'Y'
(1)    1160 :                            ;; .dbyte  vY
(1)    1160 :                            ;; xppc    P1              ; print X
(1)    1160 :                            ;; .byte   'X'
(1)    1160 :                            ;; .dbyte  vX
(1)    1160 :                            ;; ldi     L(ADDR(print))
(1)    1160 :                            ;; xpal    P1
(1)    1160 :                            ;; ldi     H(ADDR(print))
(1)    1160 :                            ;; xpah    P1              ; P1=ADDR(print)
(1)    1160 :                            ;; xppc    P1              ; print C
(1)    1160 :                            ;; .byte   'C'
(1)    1160 :                            ;; .dbyte  vC
(1)    1160 :                            ;; xppc    P1              ; print D
(1)    1160 :                            ;; .byte   'D'
(1)    1160 :                            ;; .dbyte  vD
(1)    1160 :                            ;; ldi     L(ADDR(newline))
(1)    1160 :                            ;; xpal    P1
(1)    1160 :                            ;; ldi     H(ADDR(newline))
(1)    1160 :                            ;; xpah    P1              ; P1=ADDR(newline)
(1)    1160 :                            ;; xppc    P1
(1)    1160 :
(1)    1160 :                    loop_i:
(1)    1160 : C4 3F                      ldi     L(vBASE)
(1)    1162 : 31                         xpal    P1
(1)    1163 : C4 10                      ldi     H(vBASE)
(1)    1165 : 35                         xpah    P1              ; P1=vBASE
(1)    1166 : C1 06                      ld      (vB-vBASE)(P1)
(1)    1168 : C9 0C                      st      (vQ-vBASE)(P1)  ; Q=B
(1)    116A : C9 10                      st      (vT1-vBASE)(P1) ; T1=B
(1)    116C : C1 07                      ld      (vB-vBASE+1)(P1)
(1)    116E : C9 0D                      st      (vQ-vBASE+1)(P1)
(1)    1170 : C9 11                      st      (vT1-vBASE+1)(P1)
(1)    1172 : C4 1D                      ldi     L(ADDR(divsi2))
(1)    1174 : 31                         xpal    P1
(1)    1175 : C4 15                      ldi     H(ADDR(divsi2))
(1)    1177 : 35                         xpah    P1              ; P1=ADDR(divsi2)
(1)    1178 : 3D                         xppc    P1              ; Q=B/F
(1)    1179 : 2F 10                      .dbyte  cF
(1)    117B : 4B 10                      .dbyte  vQ
(1)    117D : C4 3F                      ldi     L(vBASE)
(1)    117F : 31                         xpal    P1
(1)    1180 : C4 10                      ldi     H(vBASE)
(1)    1182 : 35                         xpah    P1              ; P1=vBASE
(1)    1183 : C1 0C                      ld      (vQ-vBASE)(P1)
(1)    1185 : C9 0E                      st      (vT-vBASE)(P1)  ; T=Q=B/F
(1)    1187 : C1 0D                      ld      (vQ-vBASE+1)(P1)
(1)    1189 : C9 0F                      st      (vT-vBASE+1)(P1)
(1)    118B : C1 04                      ld      (vA-vBASE)(P1)
(1)    118D : C9 12                      st      (vT2-vBASE)(P1) ; T2=A
(1)    118F : C1 05                      ld      (vA-vBASE+1)(P1)
(1)    1191 : C9 13                      st      (vT2-vBASE+1)(P1)
(1)    1193 : C4 6D                      ldi     L(ADDR(mulsi2))
(1)    1195 : 31                         xpal    P1
(1)    1196 : C4 14                      ldi     H(ADDR(mulsi2))
(1)    1198 : 35                         xpah    P1              ; P1=ADDR(mulsi2)
(1)    1199 : 3D                         xppc    P1              ; T=Q*F
(1)    119A : 2F 10                      .dbyte  cF
(1)    119C : 4D 10                      .dbyte  vT
(1)    119E : 3D                         xppc    P1              ; T1=B*B
(1)    119F : 45 10                      .dbyte  vB
(1)    11A1 : 4F 10                      .dbyte  vT1
(1)    11A3 : 3D                         xppc    P1              ; T2=A*A
(1)    11A4 : 43 10                      .dbyte  vA
(1)    11A6 : 51 10                      .dbyte  vT2
(1)    11A8 : C4 3F                      ldi     L(vBASE)
(1)    11AA : 31                         xpal    P1
(1)    11AB : C4 10                      ldi     H(vBASE)
(1)    11AD : 35                         xpah    P1              ; P1=vBASE
(1)    11AE : 03                         scl
(1)    11AF : C1 06                      ld      (vB-vBASE)(P1)
(1)    11B1 : F9 0E                      cad     (vT-vBASE)(P1)
(1)    11B3 : C9 08                      st      (vS-vBASE)(P1)  ; S=B-Q*F
(1)    11B5 : C1 07                      ld      (vB-vBASE+1)(P1)
(1)    11B7 : F9 0F                      cad     (vT-vBASE+1)(P1)
(1)    11B9 : C9 09                      st      (vS-vBASE+1)(P1)
(1)    11BB : 03                         scl
(1)    11BC : C1 12                      ld      (vT2-vBASE)(P1)
(1)    11BE : F9 10                      cad     (vT1-vBASE)(P1)
(1)    11C0 : C9 12                      st      (vT2-vBASE)(P1) ; T2=A*A-B*B
(1)    11C2 : C1 13                      ld      (vT2-vBASE+1)(P1)
(1)    11C4 : F9 11                      cad     (vT1-vBASE+1)(P1)
(1)    11C6 : C9 13                      st      (vT2-vBASE+1)(P1)
(1)    11C8 : C1 04                      ld      (vA-vBASE)(P1)
(1)    11CA : C9 0E                      st      (vT-vBASE)(P1)  ; T=A
(1)    11CC : C9 10                      st      (vT1-vBASE)(P1) ; T1=A
(1)    11CE : C1 05                      ld      (vA-vBASE+1)(P1)
(1)    11D0 : C9 0F                      st      (vT-vBASE+1)(P1)
(1)    11D2 : C9 11                      st      (vT1-vBASE+1)(P1)
(1)    11D4 : C4 6D                      ldi     L(ADDR(mulsi2))
(1)    11D6 : 31                         xpal    P1
(1)    11D7 : C4 14                      ldi     H(ADDR(mulsi2))
(1)    11D9 : 35                         xpah    P1              ; P1=ADDR(mulsi2)
(1)    11DA : 3D                         xppc    P1              ; T=A*S
(1)    11DB : 47 10                      .dbyte  vS
(1)    11DD : 4D 10                      .dbyte  vT
(1)    11DF : 3D                         xppc    P1              ; T1=A*Q
(1)    11E0 : 4B 10                      .dbyte  vQ
(1)    11E2 : 4F 10                      .dbyte  vT1
(1)    11E4 : C4 1D                      ldi     L(ADDR(divsi2))
(1)    11E6 : 31                         xpal    P1
(1)    11E7 : C4 15                      ldi     H(ADDR(divsi2))
(1)    11E9 : 35                         xpah    P1              ; P1=ADDR(divsi2)
(1)    11EA : 3D                         xppc    P1              ; T2=(A*A-B*B)/F
(1)    11EB : 2F 10                      .dbyte  cF
(1)    11ED : 51 10                      .dbyte  vT2
(1)    11EF : 3D                         xppc    P1              ; T=A*S/F
(1)    11F0 : 2F 10                      .dbyte  cF
(1)    11F2 : 4D 10                      .dbyte  vT
(1)    11F4 : C4 3F                      ldi     L(vBASE)
(1)    11F6 : 31                         xpal    P1
(1)    11F7 : C4 10                      ldi     H(vBASE)
(1)    11F9 : 35                         xpah    P1              ; P1=vBASE
(1)    11FA : 02                         ccl
(1)    11FB : C1 00                      ld      (vC-vBASE)(P1)
(1)    11FD : F1 12                      add     (vT2-vBASE)(P1)
(1)    11FF : C9 04                      st      (vA-vBASE)(P1) ; A=(A*A-B*B)/F+C
(1)    1201 : C9 0A                      st      (vP-vBASE)(P1) ; P=A
(1)    1203 : C1 01                      ld      (vC-vBASE+1)(P1)
(1)    1205 : F1 13                      add     (vT2-vBASE+1)(P1)
(1)    1207 : C9 05                      st      (vA-vBASE+1)(P1)
(1)    1209 : C9 0B                      st      (vP-vBASE+1)(P1)
(1)    120B : 02                         ccl
(1)    120C : C1 0E                      ld      (vT-vBASE)(P1)
(1)    120E : F1 10                      add     (vT1-vBASE)(P1)
(1)    1210 : C9 10                      st      (vT1-vBASE)(P1) ; T1=A*Q+A*S/F
(1)    1212 : C1 0F                      ld      (vT-vBASE+1)(P1)
(1)    1214 : F1 11                      add     (vT1-vBASE+1)(P1)
(1)    1216 : C9 11                      st      (vT1-vBASE+1)(P1)
(1)    1218 : 02                         ccl
(1)    1219 : C1 10                      ld      (vT1-vBASE)(P1)
(1)    121B : F1 10                      add     (vT1-vBASE)(P1)
(1)    121D : C9 06                      st      (vB-vBASE)(P1)  ; B=2*(A*Q+A*S/F)
(1)    121F : C1 11                      ld      (vT1-vBASE+1)(P1)
(1)    1221 : F1 11                      add     (vT1-vBASE+1)(P1)
(1)    1223 : C9 07                      st      (vB-vBASE+1)(P1)
(1)    1225 : 02                         ccl
(1)    1226 : C1 06                      ld      (vB-vBASE)(P1)
(1)    1228 : F1 02                      add     (vD-vBASE)(P1)
(1)    122A : C9 06                      st      (vB-vBASE)(P1)  ; B=2*(A*Q+A*S/F)+D
(1)    122C : C9 0C                      st      (vQ-vBASE)(P1)  ; Q=B
(1)    122E : C1 07                      ld      (vB-vBASE+1)(P1)
(1)    1230 : F1 03                      add     (vD-vBASE+1)(P1)
(1)    1232 : C9 07                      st      (vB-vBASE+1)(P1)
(1)    1234 : C9 0D                      st      (vQ-vBASE+1)(P1)
(1)    1236 : C4 1D                      ldi     L(ADDR(divsi2))
(1)    1238 : 31                         xpal    P1
(1)    1239 : C4 15                      ldi     H(ADDR(divsi2))
(1)    123B : 35                         xpah    P1              ; P1=ADDR(divsi2)
(1)    123C : 3D                         xppc    P1              ; P=A/F
(1)    123D : 2F 10                      .dbyte  cF
(1)    123F : 49 10                      .dbyte  vP
(1)    1241 : 3D                         xppc    P1              ; Q=B/F
(1)    1242 : 2F 10                      .dbyte  cF
(1)    1244 : 4B 10                      .dbyte  vQ
(1)    1246 : C4 3F                      ldi     L(vBASE)
(1)    1248 : 31                         xpal    P1
(1)    1249 : C4 10                      ldi     H(vBASE)
(1)    124B : 35                         xpah    P1              ; P1=vBASE
(1)    124C : C1 0A                      ld      (vP-vBASE)(P1)
(1)    124E : C9 0E                      st      (vT-vBASE)(P1)  ; T=P
(1)    1250 : C1 0B                      ld      (vP-vBASE+1)(P1)
(1)    1252 : C9 0F                      st      (vT-vBASE+1)(P1)
(1)    1254 : C1 0C                      ld      (vQ-vBASE)(P1)
(1)    1256 : C9 10                      st      (vT1-vBASE)(P1) ; T1=Q
(1)    1258 : C1 0D                      ld      (vQ-vBASE+1)(P1)
(1)    125A : C9 11                      st      (vT1-vBASE+1)(P1)
(1)    125C : C4 6D                      ldi     L(ADDR(mulsi2))
(1)    125E : 31                         xpal    P1
(1)    125F : C4 14                      ldi     H(ADDR(mulsi2))
(1)    1261 : 35                         xpah    P1              ; P1=ADDR(mulsi2)
(1)    1262 : 3D                         xppc    P1              ; T=P*P
(1)    1263 : 49 10                      .dbyte  vP
(1)    1265 : 4D 10                      .dbyte  vT
(1)    1267 : 3D                         xppc    P1              ; T1=Q*Q
(1)    1268 : 4B 10                      .dbyte  vQ
(1)    126A : 4F 10                      .dbyte  vT1
(1)    126C : C4 3F                      ldi     L(vBASE)
(1)    126E : 31                         xpal    P1
(1)    126F : C4 10                      ldi     H(vBASE)
(1)    1271 : 35                         xpah    P1              ; P1=vBASE
(1)    1272 : 02                         ccl
(1)    1273 : C1 10                      ld      (vT1-vBASE)(P1)
(1)    1275 : F1 0E                      add     (vT-vBASE)(P1)
(1)    1277 : C9 0E                      st      (vT-vBASE)(P1)  ; T=P*P+Q*Q
(1)    1279 : C1 11                      ld      (vT1-vBASE+1)(P1)
(1)    127B : F1 0F                      add     (vT-vBASE+1)(P1)
(1)    127D : C9 0F                      st      (vT-vBASE+1)(P1)
(1)    127F :
(1)    127F :                            ;; ldi     L(ADDR(putchar))
(1)    127F :                            ;; xpal    P1
(1)    127F :                            ;; ldi     H(ADDR(putchar))
(1)    127F :                            ;; xpah    P1              ; P1=ADDR(putchar)
(1)    127F :                            ;; ldi     ' '
(1)    127F :                            ;; xppc    P1              ; print space
(1)    127F :                            ;; ldi     L(ADDR(print_int8))
(1)    127F :                            ;; xpal    P1
(1)    127F :                            ;; ldi     H(ADDR(print_int8))
(1)    127F :                            ;; xpah    P1              ; P1=ADDR(print)
(1)    127F :                            ;; xppc    P1              ; print I
(1)    127F :                            ;; .byte   'I'
(1)    127F :                            ;; .dbyte  vI
(1)    127F :                            ;; ldi     L(ADDR(print))
(1)    127F :                            ;; xpal    P1
(1)    127F :                            ;; ldi     H(ADDR(print))
(1)    127F :                            ;; xpah    P1              ; P1=ADDR(print)
(1)    127F :                            ;; xppc    P1              ; print A
(1)    127F :                            ;; .byte   'A'
(1)    127F :                            ;; .dbyte  vA
(1)    127F :                            ;; xppc    P1              ; print B
(1)    127F :                            ;; .byte   'B'
(1)    127F :                            ;; .dbyte  vB
(1)    127F :                            ;; xppc    P1              ; print P
(1)    127F :                            ;; .byte   'P'
(1)    127F :                            ;; .dbyte  vP
(1)    127F :                            ;; xppc    P1              ; print Q
(1)    127F :                            ;; .byte   'Q'
(1)    127F :                            ;; .dbyte  vQ
(1)    127F :                            ;; xppc    P1              ; print T
(1)    127F :                            ;; .byte   'T'
(1)    127F :                            ;; .dbyte  vT
(1)    127F :                            ;; ldi     L(ADDR(newline))
(1)    127F :                            ;; xpal    P1
(1)    127F :                            ;; ldi     H(ADDR(newline))
(1)    127F :                            ;; xpah    P1              ; P1=ADDR(newline)
(1)    127F :                            ;; xppc    P1              ; newline
(1)    127F :
(1)    127F : C4 3F                      ldi     L(vBASE)
(1)    1281 : 31                         xpal    P1
(1)    1282 : C4 10                      ldi     H(vBASE)
(1)    1284 : 35                         xpah    P1              ; P1=vBASE
(1)    1285 : C1 0F                      ld      (vT-vBASE+1)(P1) ; H(T)
(1)    1287 : 9C 19                      jnz     next_i
(1)    1289 : 03                         scl                     ; clear borrow
(1)    128A : C4 04                      ldi     4
(1)    128C : F9 0E                      cad     (vT-vBASE)(P1)  ; 4-L(T)
(1)    128E : 94 12                      jp      next_i          ; branch if 4<T
(1)    1290 :                    print_i:
(1)    1290 : C1 16                      ld      (vI-vBASE)(P1)
(1)    1292 : 03                         scl                     ; clear borrow
(1)    1293 : FC 0A                      cai     10              ; A=I-10
(1)    1295 : 94 06                      jp      print_i_hex
(1)    1297 : C1 16                      ld      (vI-vBASE)(P1)
(1)    1299 : DC 30                      ori     '0'
(1)    129B : 90 15                      jmp     print_char
(1)    129D :                    print_i_hex:
(1)    129D : 02                         ccl
(1)    129E : F4 41                      adi     'A'
(1)    12A0 : 90 10                      jmp     print_char
(1)    12A2 :                    next_i:
(1)    12A2 : A9 16                      ild     (vI-vBASE)(P1)  ; I+=1
(1)    12A4 : 03                         scl                     ; clear borrow
(1)    12A5 : FC 10                      cai     16              ; I-16
(1)    12A7 : 94 07                      jp      print_space     ; branch if I >= 16
(1)    12A9 : C4 5F                      ldi     L(ADDR(loop_i))
(1)    12AB : 31                         xpal    P1
(1)    12AC : C4 11                      ldi     H(ADDR(loop_i))
(1)    12AE : 35                         xpah    P1
(1)    12AF : 3D                         xppc    P1              ; jump to loop_i
(1)    12B0 :                    print_space:
(1)    12B0 : C4 20                      ldi     ' '
(1)    12B2 :                    print_char:
(1)    12B2 : 01                         xae                     ; E=char
(1)    12B3 : C4 4F                      ldi     L(ADDR(putchar))
(1)    12B5 : 31                         xpal    P1
(1)    12B6 : C4 16                      ldi     H(ADDR(putchar))
(1)    12B8 : 35                         xpah    P1
(1)    12B9 : 40                         lde
(1)    12BA : 3D                         xppc    P1              ; print char
(1)    12BB :
(1)    12BB :                            ;; ldi     '@'
(1)    12BB :                            ;; xppc    P1              ; print '@='
(1)    12BB :                            ;; ldi     '='
(1)    12BB :                            ;; xppc    P1
(1)    12BB :                            ;; lde
(1)    12BB :                            ;; xppc    P1
(1)    12BB :                            ;; ldi     L(ADDR(newline))
(1)    12BB :                            ;; xpal    P1
(1)    12BB :                            ;; ldi     H(ADDR(newline))
(1)    12BB :                            ;; xpah    P1              ; P1=ADDR(newline)
(1)    12BB :                            ;; xppc    P1
(1)    12BB :
(1)    12BB : C4 2E                      ldi     L(ADDR(getchar))
(1)    12BD : 31                         xpal    P1
(1)    12BE : C4 16                      ldi     H(ADDR(getchar))
(1)    12C0 : 35                         xpah    P1              ; P1=ADDR(getchar)
(1)    12C1 : 3D                         xppc    P1
(1)    12C2 : 98 04                      jz      next_x
(1)    12C4 : 40                         lde
(1)    12C5 : 9C 01                      jnz     next_x
(1)    12C7 : 00                         halt                    ; halt to system
(1)    12C8 :
(1)    12C8 :                    next_x:
(1)    12C8 : C4 54                      ldi     L(vX)
(1)    12CA : 31                         xpal    P1
(1)    12CB : C4 10                      ldi     H(vX)
(1)    12CD : 35                         xpah    P1              ; P1=&vX
(1)    12CE : A9 00                      ild     0(P1)           ; X++
(1)    12D0 : 03                         scl                     ; clear borrow
(1)    12D1 : FC 1E                      cai     30              ; X-30
(1)    12D3 : 94 07                      jp      next_y          ; branch if X>=30
(1)    12D5 :                    jump_loop_x:
(1)    12D5 : C4 03                      ldi     L(ADDR(loop_x))
(1)    12D7 : 31                         xpal    P1
(1)    12D8 : C4 11                      ldi     H(ADDR(loop_x))
(1)    12DA : 35                         xpah    P1
(1)    12DB : 3D                         xppc    P1              ; jump to loop_x
(1)    12DC :                    next_y:
(1)    12DC : C4 74                      ldi     L(ADDR(newline))
(1)    12DE : 31                         xpal    P1
(1)    12DF : C4 16                      ldi     H(ADDR(newline))
(1)    12E1 : 35                         xpah    P1              ; P1=ADDR(newline)
(1)    12E2 : 3D                         xppc    P1
(1)    12E3 : C4 53                      ldi     L(vY)
(1)    12E5 : 31                         xpal    P1
(1)    12E6 : C4 10                      ldi     H(vY)
(1)    12E8 : 35                         xpah    P1              ; P1=&Y
(1)    12E9 : A9 00                      ild     0(P1)           ; Y++
(1)    12EB : 03                         scl                     ; clear borrow
(1)    12EC : FC 0D                      cai     13              ; Y-13
(1)    12EE : 94 07                      jp      mandelbrot_end  ; branch if Y>=13
(1)    12F0 :                    jump_loop_y:
(1)    12F0 : C4 F9                      ldi     L(ADDR(loop_y))
(1)    12F2 : 31                         xpal    P1
(1)    12F3 : C4 10                      ldi     H(ADDR(loop_y))
(1)    12F5 : 35                         xpah    P1
(1)    12F6 : 3D                         xppc    P1              ; jump to loop_y
(1)    12F7 :
(1)    12F7 :                    mandelbrot_end:
(1)    12F7 : C6 01                      ld      @1(P2)
(1)    12F9 : 31                         xpal    P1
(1)    12FA : C6 01                      ld      @1(P2)
(1)    12FC : 35                         xpah    P1
(1)    12FD : 3D                         xppc    P1              ; return
       12FE :                            include "arith.inc"
(1)    12FE :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    12FE :
(1)    12FE :                    ;;; Print int16_t value
(1)    12FE :                    ;;;   xppc   P1
(1)    12FE :                    ;;;   .dbyte &value
(1)    12FE :                    ;;; @local P2[1:0] &value
(1)    12FE :                    ;;; @local P2[7:0] buffer
(1)    12FE :                    ;;; @local P2[9:8] return address
(1)    12FE :                    print_int16:
(1)    12FE : C5 01                      ld      @1(P1)          ; point &value
(1)    1300 : C5 01                      ld      @1(P1)
(1)    1302 : CE F6                      st      @-10(P2)        ; P2[1:0]=&value
(1)    1304 : C1 00                      ld      0(P1)           ; P1=return address
(1)    1306 : CA 01                      st      1(P2)
(1)    1308 : 35                         xpah    P1
(1)    1309 : CA 09                      st      9(P2)           ; P2[9:8]=return address
(1)    130B : C2 00                      ld      0(P2)
(1)    130D : 31                         xpal    P1              ; P1=&value
(1)    130E : CA 08                      st      8(P2)
(1)    1310 : C1 00                      ld      0(P1)
(1)    1312 : C8 1F                      st      vPRINT
(1)    1314 : C1 01                      ld      1(P1)
(1)    1316 : C8 1C                      st      vPRINT+1        ; vPRINT=value
(1)    1318 : 94 1A                      jp      print_uint16    ; branch if value >= 0
(1)    131A : 03                         scl                     ; clear borrow
(1)    131B : C4 00                      ldi     0
(1)    131D : F8 14                      cad     vPRINT
(1)    131F : C8 12                      st      vPRINT
(1)    1321 : C4 00                      ldi     0
(1)    1323 : F8 0F                      cad     vPRINT+1
(1)    1325 : C8 0D                      st      vPRINT+1        ; negate vPRINT
(1)    1327 : C4 4F                      ldi     L(ADDR(putchar))
(1)    1329 : 31                         xpal    P1
(1)    132A : C4 16                      ldi     H(ADDR(putchar))
(1)    132C : 35                         xpah    P1
(1)    132D : C4 2D                      ldi     '-'
(1)    132F : 3D                         xppc    P1              ; print '-'
(1)    1330 : 90 02                      jmp     print_uint16
(1)    1332 :                    ;;; Print uint16_t value
(1)    1332 :                    ;;; @param vPRINT value
(1)    1332 :                    ;;; @local P2[7:0] buffer
(1)    1332 :                    ;;; @local P2[9:8] return address
(1)    1332 :                    ;;; @clobber E
(1)    1332 : 00 00              vPRINT:         .dbyte  0
(1)    1334 :                    print_uint16:
(1)    1334 : C4 00                      ldi     0
(1)    1336 : CA 00                      st      0(P2)           ; buffer[0]=0
(1)    1338 : C4 01                      ldi     1
(1)    133A : 01                         xae                     ; E=1
(1)    133B : C4 B1                      ldi     L(ADDR(udiv16))
(1)    133D : 31                         xpal    P1
(1)    133E : C4 15                      ldi     H(ADDR(udiv16))
(1)    1340 : 35                         xpah    P1
(1)    1341 :                    print_uint16_loop:
(1)    1341 : C0 F0                      ld      vPRINT
(1)    1343 : C9 ED                      st      (vDIVIDEND-ADDR(udiv16))(P1)
(1)    1345 : C0 ED                      ld      vPRINT+1
(1)    1347 : C9 EE                      st      (vDIVIDEND-ADDR(udiv16)+1)(P1)
(1)    1349 : C4 0A                      ldi     10
(1)    134B : C9 EF                      st      (vDIVISOR-ADDR(udiv16))(P1)
(1)    134D : C4 00                      ldi     0
(1)    134F : C9 F0                      st      (vDIVISOR-ADDR(udiv16)+1)(P1)
(1)    1351 : 3D                         xppc    P1              ; calculate vPRINT/=10
(1)    1352 : C1 ED                      ld      (vREMINDER-ADDR(udiv16))(P1) ; L(vREMINDER)
(1)    1354 : DC 30                      ori     '0'
(1)    1356 : CA 80                      st      E(P2)           ; buffer[E]=digit
(1)    1358 : 02                         ccl
(1)    1359 : C4 01                      ldi     1
(1)    135B : 70                         ade
(1)    135C : 01                         xae                     ; ++E
(1)    135D : C1 EB                      ld      (vQUOTIENT-ADDR(udiv16))(P1)
(1)    135F : C8 D2                      st      vPRINT
(1)    1361 : C1 EC                      ld      (vQUOTIENT-ADDR(udiv16)+1)(P1)
(1)    1363 : C8 CF                      st      vPRINT+1
(1)    1365 : D8 CC                      or      vPRINT
(1)    1367 : 9C D8                      jnz     print_uint16_loop ; while vPRINT!=0
(1)    1369 : C4 4F                      ldi     L(ADDR(putchar))
(1)    136B : 31                         xpal    P1
(1)    136C : C4 16                      ldi     H(ADDR(putchar))
(1)    136E : 35                         xpah    P1              ; P1=ADDR(putchar)
(1)    136F :                    print_uint16_putdigit:
(1)    136F : 40                         lde
(1)    1370 : 03                         scl                     ; clear borrow
(1)    1371 : FC 01                      cai     1
(1)    1373 : 01                         xae                     ; --E
(1)    1374 : C2 80                      ld      E(P2)
(1)    1376 : 98 03                      jz      print_int16_return
(1)    1378 : 3D                         xppc    P1              ; print digit
(1)    1379 : 90 F4                      jmp     print_uint16_putdigit
(1)    137B :                    print_int16_return:
(1)    137B : C6 08                      ld      @8(P2)          ; discard locals
(1)    137D : C6 01                      ld      @1(P2)
(1)    137F : 31                         xpal    P1
(1)    1380 : C6 01                      ld      @1(P2)
(1)    1382 : 35                         xpah    P1
(1)    1383 : 3D                         xppc    P1              ; return
(1)    1384 :
(1)    1384 :                    ;;; Add: summand += addend
(1)    1384 :                    ;;;   xppc   P1
(1)    1384 :                    ;;;   .dbyte &addend
(1)    1384 :                    ;;;   .dbyte &summand
(1)    1384 :                    ;;; @local P2[1:0] &addend, addend
(1)    1384 :                    ;;; @local P2[3:2] &summand
(1)    1384 :                    ;;; @local P2[5:4] return address
(1)    1384 :                    addsi2_exit:
(1)    1384 : C6 04                      ld      @4(P2)          ; discard locals
(1)    1386 : C6 01                      ld      @1(P2)
(1)    1388 : 31                         xpal    P1
(1)    1389 : C6 01                      ld      @1(P2)
(1)    138B : 35                         xpah    P1
(1)    138C : 3D                         xppc    P1              ; return
(1)    138D :                    addsi2:
(1)    138D : C5 01                      ld      @1(P1)          ; point to &addend
(1)    138F : C5 01                      ld      @1(P1)
(1)    1391 : CE FA                      st      @-6(P2)         ; P2[1:0]=&addend
(1)    1393 : C5 01                      ld      @1(P1)
(1)    1395 : CA 01                      st      1(P2)
(1)    1397 : C5 01                      ld      @1(P1)
(1)    1399 : CA 02                      st      2(P2)           ; P2[3:2]=&summand
(1)    139B : C1 00                      ld      0(P1)           ; P1=return address
(1)    139D : CA 03                      st      3(P2)
(1)    139F : C2 00                      ld      0(P2)           ; P2[1:0]=&addend
(1)    13A1 : 31                         xpal    P1
(1)    13A2 : CA 04                      st      4(P2)           ; P2[5:4]=return address
(1)    13A4 : C2 01                      ld      1(P2)
(1)    13A6 : 35                         xpah    P1              ; P1=&addend
(1)    13A7 : CA 05                      st      5(P2)
(1)    13A9 : C1 00                      ld      0(P1)
(1)    13AB : CA 00                      st      0(P2)           ; P2[1:0]=addend
(1)    13AD : C1 01                      ld      1(P1)
(1)    13AF : CA 01                      st      1(P2)
(1)    13B1 : C2 02                      ld      2(P2)           ; P2[3:2]=&summand
(1)    13B3 : 31                         xpal    P1
(1)    13B4 : C2 03                      ld      3(P2)
(1)    13B6 : 35                         xpah    P1              ; P1=&summand
(1)    13B7 : 02                         ccl                     ; clear carry
(1)    13B8 : C1 00                      ld      0(P1)
(1)    13BA : F2 00                      add     0(P2)           ; L(summand+addend)
(1)    13BC : C9 00                      st      0(P1)
(1)    13BE : C1 01                      ld      1(P1)
(1)    13C0 : F2 01                      add     1(P2)           ; L(summand+addend)
(1)    13C2 : C9 01                      st      1(P1)
(1)    13C4 : 90 BE                      jmp     addsi2_exit
(1)    13C6 :
(1)    13C6 :                    ;;; Subtract: minuend -= subtrahend
(1)    13C6 :                    ;;;   xppc   P1
(1)    13C6 :                    ;;;   .dbyte &subtrahend
(1)    13C6 :                    ;;;   .dbyte &minuend
(1)    13C6 :                    ;;; @local P2[1:0] &subtrahend, subtrahend
(1)    13C6 :                    ;;; @local P2[3:2] &minuend
(1)    13C6 :                    ;;; @local P2[5:4] return address
(1)    13C6 :                    subsi2_exit:
(1)    13C6 : C6 04                      ld      @4(P2)          ; discard locals
(1)    13C8 : C6 01                      ld      @1(P2)
(1)    13CA : 31                         xpal    P1
(1)    13CB : C6 01                      ld      @1(P2)
(1)    13CD : 35                         xpah    P1
(1)    13CE : 3D                         xppc    P1              ; return
(1)    13CF :                    subsi2:
(1)    13CF : C5 01                      ld      @1(P1)          ; point to &subtrahend
(1)    13D1 : C5 01                      ld      @1(P1)
(1)    13D3 : CE FA                      st      @-6(P2)         ; P2[1:0]=&subtrahend
(1)    13D5 : C5 01                      ld      @1(P1)
(1)    13D7 : CA 01                      st      1(P2)
(1)    13D9 : C5 01                      ld      @1(P1)
(1)    13DB : CA 02                      st      2(P2)           ; P2[3:2]=&minuend
(1)    13DD : C1 00                      ld      0(P1)           ; P1=return address
(1)    13DF : CA 03                      st      3(P2)
(1)    13E1 : C2 00                      ld      0(P2)           ; P2[1:0]=&subtrahend
(1)    13E3 : 31                         xpal    P1
(1)    13E4 : CA 04                      st      4(P2)           ; P2[5:4]=return address
(1)    13E6 : C2 01                      ld      1(P2)
(1)    13E8 : 35                         xpah    P1              ; P1=&subtrahend
(1)    13E9 : CA 05                      st      5(P2)
(1)    13EB : C1 00                      ld      0(P1)
(1)    13ED : CA 00                      st      0(P2)           ; P2[1:0]=subtrahend
(1)    13EF : C1 01                      ld      1(P1)
(1)    13F1 : CA 01                      st      1(P2)
(1)    13F3 : C2 02                      ld      2(P2)           ; P2[3:2]=&minuend
(1)    13F5 : 31                         xpal    P1
(1)    13F6 : C2 03                      ld      3(P2)
(1)    13F8 : 35                         xpah    P1              ; P1=&minuend
(1)    13F9 : 03                         scl                     ; clear borrow
(1)    13FA : C1 00                      ld      0(P1)
(1)    13FC : FA 00                      cad     0(P2)           ; L(minuend-subtrahend)
(1)    13FE : C9 00                      st      0(P1)
(1)    1400 : C1 01                      ld      1(P1)
(1)    1402 : FA 01                      cad     1(P2)           ; H(minuend-subtrahend)
(1)    1404 : C9 01                      st      1(P1)
(1)    1406 : 90 BE                      jmp     subsi2_exit
(1)    1408 :
(1)    1408 :                    ;;; Signed compare: A = sign(minuend - subtrahend)
(1)    1408 :                    ;;;   xppc   P1
(1)    1408 :                    ;;;   .dbyte &subtrahend
(1)    1408 :                    ;;;   .dbyte &minuend
(1)    1408 :                    ;;; @return A=0  JZ
(1)    1408 :                    ;;;         A=1  JP
(1)    1408 :                    ;;;         A=-1
(1)    1408 :                    ;;; @local P2[1:0] &subtrahend, subtrahend
(1)    1408 :                    ;;; @local P2[3:2] &minuend, minuend - subtrahend
(1)    1408 :                    ;;; @local P2[5:4] return address
(1)    1408 :                    ;;; @local P2[6]   sign(minuend - subtrahend)
(1)    1408 :                    cmpsi2_exit:
(1)    1408 : CA 06                      st      6(P2)           ; save sign(minuend-subtrahend)
(1)    140A : C6 04                      ld      @4(P2)          ; discard locals
(1)    140C : C6 01                      ld      @1(P2)
(1)    140E : 31                         xpal    P1
(1)    140F : C6 01                      ld      @1(P2)
(1)    1411 : 35                         xpah    P1
(1)    1412 : C6 01                      ld      @1(P2)          ; sign(minuend-subtrahend)
(1)    1414 : 3D                         xppc    P1              ; return
(1)    1415 :                    cmpsi2:
(1)    1415 : C5 01                      ld      @1(P1)          ; point to &subtrahend
(1)    1417 : C5 01                      ld      @1(P1)
(1)    1419 : CE F9                      st      @-7(P2)         ; P2[1:0]=&subtrahend
(1)    141B : C5 01                      ld      @1(P1)
(1)    141D : CA 01                      st      1(P2)
(1)    141F : C5 01                      ld      @1(P1)
(1)    1421 : CA 02                      st      2(P2)           ; P2[3:2]=&minuend
(1)    1423 : C1 00                      ld      0(P1)           ; P1=return address
(1)    1425 : CA 03                      st      3(P2)
(1)    1427 : C2 00                      ld      0(P2)           ; P2[1:0]=&subtrahend
(1)    1429 : 31                         xpal    P1
(1)    142A : CA 04                      st      4(P2)           ; P2[5:4]=return address
(1)    142C : C2 01                      ld      1(P2)
(1)    142E : 35                         xpah    P1              ; P1=&subtrahend
(1)    142F : CA 05                      st      5(P2)
(1)    1431 : C1 00                      ld      0(P1)
(1)    1433 : CA 00                      st      0(P2)           ; P2[1:0]=subtrahend
(1)    1435 : C1 01                      ld      1(P1)
(1)    1437 : CA 01                      st      1(P2)
(1)    1439 : C2 02                      ld      2(P2)           ; P2[3:2]=&minuend
(1)    143B : 31                         xpal    P1
(1)    143C : C2 03                      ld      3(P2)
(1)    143E : 35                         xpah    P1              ; P1=&minuend
(1)    143F : 03                         scl                     ; clear borrow
(1)    1440 : C1 00                      ld      0(P1)
(1)    1442 : FA 00                      cad     0(P2)           ; L(minuend-subtrahend)
(1)    1444 : CA 02                      st      2(P2)           ; P2[3:2]=minuend-subtrahend
(1)    1446 : C1 01                      ld      1(P1)
(1)    1448 : FA 01                      cad     1(P2)
(1)    144A : CA 03                      st      3(P2)
(1)    144C : DA 02                      or      2(P2)
(1)    144E : 98 B8                      jz      cmpsi2_exit     ; branch if result==0 with A=0
(1)    1450 : 06                         csa
(1)    1451 : D4 40                      ani     S_OV
(1)    1453 : 9C 08                      jnz     cmpsi2_ov       ; branch if V=1
(1)    1455 : C2 03                      ld      3(P2)           ; H(minuend-subtrahend)
(1)    1457 : 94 08                      jp      cmpsi2_gt       ; V=0, N=0
(1)    1459 :                    cmpsi2_lt:
(1)    1459 : C4 FF                      ldi     -1              ; V=0, N=1
(1)    145B : 90 AB                      jmp     cmpsi2_exit
(1)    145D :                    cmpsi2_ov:
(1)    145D : C2 01                      ld      1(P2)           ; H(result)
(1)    145F : 94 F8                      jp      cmpsi2_lt       ; V=1, N=0
(1)    1461 :                    cmpsi2_gt:                      ; V=1, N=1
(1)    1461 : C4 01                      ldi     1
(1)    1463 : 90 A3                      jmp     cmpsi2_exit
(1)    1465 :
(1)    1465 :                    ;;; Signed multiply; multiplicand *= multiplier
(1)    1465 :                    ;;;   xppc   P1
(1)    1465 :                    ;;;   .dbyte &multiplier
(1)    1465 :                    ;;;   .dbyte &multiplicand
(1)    1465 :                    ;;; @local P2[1:0] multiplier, &multiplier
(1)    1465 :                    ;;; @local P2[3:2] multiplicand, &multiplicand
(1)    1465 :                    ;;; @local P2[4]   H(multiplicand ^ multiplier)
(1)    1465 :                    ;;; @local P2[6:5] return address
(1)    1465 :                    mulsi2_exit:
(1)    1465 : C6 05                      ld      @5(P2)          ; discard locals
(1)    1467 : C6 01                      ld      @1(P2)
(1)    1469 : 31                         xpal    P1
(1)    146A : C6 01                      ld      @1(P2)
(1)    146C : 35                         xpah    P1
(1)    146D : 3D                         xppc    P1              ; return
(1)    146E :                    mulsi2:
(1)    146E : C5 01                      ld      @1(P1)          ; point to &multiplier
(1)    1470 : C5 01                      ld      @1(P1)
(1)    1472 : CE F9                      st      @-7(P2)         ; P2[1:0]=&multiplier
(1)    1474 : C5 01                      ld      @1(P1)
(1)    1476 : CA 01                      st      1(P2)
(1)    1478 : C5 01                      ld      @1(P1)
(1)    147A : CA 02                      st      2(P2)           ; P2[3:2]=&multiplicand
(1)    147C : C1 00                      ld      0(P1)
(1)    147E : CA 03                      st      3(P2)
(1)    1480 : C2 00                      ld      0(P2)           ; P2[1:0]=&multiplier
(1)    1482 : 31                         xpal    P1
(1)    1483 : CA 05                      st      5(P2)           ; P2[6:5]=return address
(1)    1485 : C2 01                      ld      1(P2)
(1)    1487 : 35                         xpah    P1              ; P1=&multiplier
(1)    1488 : CA 06                      st      6(P2)
(1)    148A : C1 00                      ld      0(P1)
(1)    148C : CA 00                      st      0(P2)           ; P2[1:0]=multiplier
(1)    148E : C1 01                      ld      1(P1)
(1)    1490 : CA 01                      st      1(P2)
(1)    1492 : C2 02                      ld      2(P2)           ; P2[3:2]=&multiplicand
(1)    1494 : 31                         xpal    P1
(1)    1495 : C2 03                      ld      3(P2)
(1)    1497 : 35                         xpah    P1              ; P1=&multiplicand
(1)    1498 : C1 00                      ld      0(P1)
(1)    149A : CA 02                      st      2(P2)           ; P2[3:2]=multiplicand
(1)    149C : C1 01                      ld      1(P1)
(1)    149E : CA 03                      st      3(P2)
(1)    14A0 : E2 01                      xor     1(P2)           ; P2[1]=H(multiplier)
(1)    14A2 : CA 04                      st      4(P2)           ; P2[4]=H(multiplicand^multiplier)
(1)    14A4 : C2 01                      ld      1(P2)           ; H(multiplier)
(1)    14A6 : 94 0D                      jp      mulsi2_multiplicand
(1)    14A8 : 03                         scl                     ; clear borrow
(1)    14A9 : C4 00                      ldi     0
(1)    14AB : FA 00                      cad     0(P2)
(1)    14AD : CA 00                      st      0(P2)
(1)    14AF : C4 00                      ldi     0
(1)    14B1 : FA 01                      cad     1(P2)
(1)    14B3 : CA 01                      st      1(P2)           ; negate multiplier
(1)    14B5 :                    mulsi2_multiplicand:
(1)    14B5 : C2 03                      ld      3(P2)           ; H(multiplicand)
(1)    14B7 : 94 11                      jp      umul16
(1)    14B9 : 03                         scl                     ; clear borrow
(1)    14BA : C4 00                      ldi     0
(1)    14BC : FA 02                      cad     2(P2)
(1)    14BE : CA 02                      st      2(P2)
(1)    14C0 : C4 00                      ldi     0
(1)    14C2 : FA 03                      cad     3(P2)
(1)    14C4 : CA 03                      st      3(P2)           ; negate multiplicand
(1)    14C6 : 90 02                      jmp     umul16
(1)    14C8 :                    mulsi2_exit_1:
(1)    14C8 : 90 9B                      jmp     mulsi2_exit
(1)    14CA :                    ;;; Unsigned multiply; product = multiplicand * multiplier
(1)    14CA :                    ;;; @param P2[1:0] multiplier
(1)    14CA :                    ;;; @param P2[3:2] multiplicand
(1)    14CA :                    ;;; @return P1[1:0] product
(1)    14CA :                    ;;; @clobber multiplier multiplicand
(1)    14CA :                    ;;; @unchanged P1
(1)    14CA :                    umul16:
(1)    14CA : C4 00                      ldi     0
(1)    14CC : C9 00                      st      0(P1)
(1)    14CE : C9 01                      st      1(P1)           ; P1[1:0]=product
(1)    14D0 : 90 2A                      jmp     umul16_check
(1)    14D2 :                    umul16_loop:
(1)    14D2 : C2 01                      ld      1(P2)           ; P2[1:0]=multiplier
(1)    14D4 : 02                         ccl
(1)    14D5 : 1F                         rrl
(1)    14D6 : CA 01                      st      1(P2)
(1)    14D8 : C2 00                      ld      0(P2)
(1)    14DA : 1F                         rrl
(1)    14DB : CA 00                      st      0(P2)           ; multiplier >>= 1
(1)    14DD : 06                         csa
(1)    14DE : D4 80                      ani     S_CY
(1)    14E0 : 98 0D                      jz      umul16_next     ; if lsb(multiplier) == 0
(1)    14E2 : 02                         ccl
(1)    14E3 : C2 02                      ld      2(P2)           ; P2[3:2]=multiplicand
(1)    14E5 : F1 00                      add     0(P1)           ; P1[1:0]=product
(1)    14E7 : C9 00                      st      0(P1)
(1)    14E9 : C2 03                      ld      3(P2)
(1)    14EB : F1 01                      add     1(P1)
(1)    14ED : C9 01                      st      1(P1)           ; product += multiplicand
(1)    14EF :                    umul16_next:
(1)    14EF : 02                         ccl
(1)    14F0 : C2 02                      ld      2(P2)           ; P2[3:2]=multiplicand
(1)    14F2 : F2 02                      add     2(P2)
(1)    14F4 : CA 02                      st      2(P2)
(1)    14F6 : C2 03                      ld      3(P2)
(1)    14F8 : F2 03                      add     3(P2)
(1)    14FA : CA 03                      st      3(P2)           ; multiplicand <<= 1
(1)    14FC :                    umul16_check:
(1)    14FC : C2 00                      ld      0(P2)           ; P2[1:0]=multiplier
(1)    14FE : DA 01                      or      1(P2)
(1)    1500 : 9C D0                      jnz     umul16_loop     ; while multiplier != 0
(1)    1502 :                    umul16_end:
(1)    1502 : C2 04                      ld      4(P2)           ; H(multiplier^multiplicand)
(1)    1504 : 94 C2                      jp      mulsi2_exit_1
(1)    1506 : 03                         scl                     ; clear borrow
(1)    1507 : C4 00                      ldi     0
(1)    1509 : F9 00                      cad     0(P1)           ; P1[1:0]=product
(1)    150B : C9 00                      st      0(P1)
(1)    150D : C4 00                      ldi     0
(1)    150F : F9 01                      cad     1(P1)
(1)    1511 : C9 01                      st      1(P1)           ; negate product
(1)    1513 : 90 B3                      jmp     mulsi2_exit_1
(1)    1515 :
(1)    1515 :                    ;;; Signed divide; dividend /= divisor ... remainder
(1)    1515 :                    ;;;   xppc   P1
(1)    1515 :                    ;;;   .dbyte &divisor
(1)    1515 :                    ;;;   .dbyte &dividend
(1)    1515 :                    ;;; @return vREMINDER |dividend| % |divisor|
(1)    1515 :                    ;;; @local P2[1:0] &divisor
(1)    1515 :                    ;;; @local P2[3:2] &dividend
(1)    1515 :                    ;;; @local P2[5:4] return address
(1)    1515 :                    divsi2_exit:
(1)    1515 : C6 04                      ld      @4(P2)          ; discard locals
(1)    1517 : C6 01                      ld      @1(P2)
(1)    1519 : 31                         xpal    P1
(1)    151A : C6 01                      ld      @1(P2)
(1)    151C : 35                         xpah    P1
(1)    151D : 3D                         xppc    P1              ; return
(1)    151E :                    divsi2:
(1)    151E : C5 01                      ld      @1(P1)          ; point to &divisor
(1)    1520 : C5 01                      ld      @1(P1)
(1)    1522 : CE FA                      st      @-6(P2)         ; P2[1:0]=&divisor
(1)    1524 : C5 01                      ld      @1(P1)
(1)    1526 : CA 01                      st      1(P2)
(1)    1528 : C5 01                      ld      @1(P1)
(1)    152A : CA 02                      st      2(P2)           ; P2[3:2]=&dividend
(1)    152C : C1 00                      ld      0(P1)           ; P1=return address
(1)    152E : CA 03                      st      3(P2)
(1)    1530 : C2 00                      ld      0(P2)           ; P2[1:0]=&divisor
(1)    1532 : 31                         xpal    P1
(1)    1533 : CA 04                      st      4(P2)           ; P2[5:4]=return address
(1)    1535 : C2 01                      ld      1(P2)
(1)    1537 : 35                         xpah    P1              ; P1=&divisor
(1)    1538 : CA 05                      st      5(P2)
(1)    153A : C1 00                      ld      0(P1)
(1)    153C : C8 63                      st      vDIVISOR
(1)    153E : 01                         xae                     ; E=high(divisor)
(1)    153F : C1 01                      ld      1(P1)
(1)    1541 : C8 5F                      st      vDIVISOR+1
(1)    1543 : 94 0F                      jp      divsi2_dividend ; if divisor>=0
(1)    1545 : 03                         scl                     ; clear borrow
(1)    1546 : C4 00                      ldi     0
(1)    1548 : F8 57                      cad     vDIVISOR
(1)    154A : C8 55                      st      vDIVISOR
(1)    154C : C4 00                      ldi     0
(1)    154E : F8 52                      cad     vDIVISOR+1
(1)    1550 : C8 50                      st      vDIVISOR+1      ; negate divisor
(1)    1552 :                    divsi2_exit_trampoline
(1)    1552 : 90 C1                      jmp     divsi2_exit
(1)    1554 :                    divsi2_dividend:
(1)    1554 : C2 02                      ld      2(P2)           ; P2[3:2]=&dividend
(1)    1556 : 31                         xpal    P1
(1)    1557 : C2 03                      ld      3(P2)
(1)    1559 : 35                         xpah    P1              ; P1=&dividend
(1)    155A : C1 00                      ld      0(P1)
(1)    155C : C8 41                      st      vDIVIDEND
(1)    155E : C1 01                      ld      1(P1)
(1)    1560 : C8 3E                      st      vDIVIDEND+1
(1)    1562 : 60                         xre
(1)    1563 : 01                         xae                     ; E=high(dividend^divisor)
(1)    1564 : C1 01                      ld      1(P1)
(1)    1566 : 94 0D                      jp      divsi2_divide   ; if dividend>=0
(1)    1568 : 03                         scl                     ; clear borrow
(1)    1569 : C4 00                      ldi     0
(1)    156B : F8 32                      cad     vDIVIDEND
(1)    156D : C8 30                      st      vDIVIDEND
(1)    156F : C4 00                      ldi     0
(1)    1571 : F8 2D                      cad     vDIVIDEND+1
(1)    1573 : C8 2B                      st      vDIVIDEND+1     ; negate dividend
(1)    1575 :                    divsi2_divide:
(1)    1575 : C4 B1                      ldi     L(ADDR(udiv16))
(1)    1577 : 31                         xpal    P1
(1)    1578 : C4 15                      ldi     H(ADDR(udiv16))
(1)    157A : 35                         xpah    P1
(1)    157B : 3D                         xppc    P1              ; call udiv16
(1)    157C : 40                         lde
(1)    157D : 94 0D                      jp      divsi2_store
(1)    157F : 03                         scl                     ; clear borrow
(1)    1580 : C4 00                      ldi     0
(1)    1582 : F8 19                      cad     vQUOTIENT
(1)    1584 : C8 17                      st      vQUOTIENT
(1)    1586 : C4 00                      ldi     0
(1)    1588 : F8 14                      cad     vQUOTIENT+1
(1)    158A : C8 12                      st      vQUOTIENT+1     ; negate quotient
(1)    158C :                    divsi2_store:
(1)    158C : C2 02                      ld      2(P2)
(1)    158E : 31                         xpal    P1
(1)    158F : C2 03                      ld      3(P2)
(1)    1591 : 35                         xpah    P1              ; Pq=&dividend
(1)    1592 : C0 09                      ld      vQUOTIENT
(1)    1594 : C9 00                      st      0(P1)
(1)    1596 : C0 06                      ld      vQUOTIENT+1
(1)    1598 : C9 01                      st      1(P1)
(1)    159A : 90 B6                      jmp     divsi2_exit_trampoline
(1)    159C :
(1)    159C :                    ;;; Unsigned divide; quotient = dividend / divisor ... remainder
(1)    159C :                    ;;; @param vDIVISOR divisor
(1)    159C :                    ;;; @param vDIVIDEND dividend
(1)    159C :                    ;;; @return vQUOTIENT quotient
(1)    159C :                    ;;; @return vDIVIDEND reminder
(1)    159C :                    ;;; @clobber E vDIVISOR
(1)    159C :                    ;;; @unchanged P1
(1)    159C : 00 00              vQUOTIENT:      .dbyte  0
(1)    159E : 00 00              vDIVIDEND:      .dbyte  0
(1)    15A0 : 00 00              vDIVISOR:       .dbyte  0
(1)    15A2 : =159E              vREMINDER       = vDIVIDEND
(1)    15A2 : 00                 udiv16_bits:    .byte   0
(1)    15A3 : 00                 udiv16_borrow:  .byte   0
(1)    15A4 :                    udiv16_adjust:
(1)    15A4 : 02                         ccl
(1)    15A5 : C0 F8                      ld      vDIVIDEND
(1)    15A7 : F0 F8                      add     vDIVISOR
(1)    15A9 : C8 F4                      st      vDIVIDEND
(1)    15AB : C0 F3                      ld      vDIVIDEND+1
(1)    15AD : F0 F3                      add     vDIVISOR+1
(1)    15AF : C8 EF                      st      vDIVIDEND+1     ; dividend+=divisor
(1)    15B1 :                    udiv16_exit:
(1)    15B1 : 3D                         xppc    P1
(1)    15B2 :                    udiv16:
(1)    15B2 : C0 ED                      ld      vDIVISOR
(1)    15B4 : D8 EC                      or      vDIVISOR+1
(1)    15B6 : 98 F9                      jz      udiv16_exit     ; divide by zero
(1)    15B8 : C4 01                      ldi     1
(1)    15BA : C8 E7                      st      udiv16_bits
(1)    15BC : C8 E6                      st      udiv16_borrow   ; borrow=false
(1)    15BE : 90 0F                      jmp     udiv16_prep
(1)    15C0 :                    udiv16_prep_loop:
(1)    15C0 : 02                         ccl
(1)    15C1 : C0 DE                      ld      vDIVISOR
(1)    15C3 : F0 DC                      add     vDIVISOR
(1)    15C5 : C8 DA                      st      vDIVISOR
(1)    15C7 : C0 D9                      ld      vDIVISOR+1
(1)    15C9 : F0 D7                      add     vDIVISOR+1
(1)    15CB : C8 D5                      st      vDIVISOR+1      ; divisor<<=1
(1)    15CD : A8 D4                      ild     udiv16_bits     ; ++bits
(1)    15CF :                    udiv16_prep:
(1)    15CF : C0 D1                      ld      vDIVISOR+1
(1)    15D1 : 94 ED                      jp      udiv16_prep_loop ; while msb(divisor)==0
(1)    15D3 : C4 00                      ldi     0
(1)    15D5 : C8 C6                      st      vQUOTIENT
(1)    15D7 : C8 C5                      st      vQUOTIENT+1     ; quotient=0
(1)    15D9 : 90 18                      jmp     udiv16_enter_loop
(1)    15DB :                    udiv16_loop:
(1)    15DB : 02                         ccl
(1)    15DC : C0 C4                      ld      vDIVISOR+1
(1)    15DE : 1F                         rrl
(1)    15DF : C8 C1                      st      vDIVISOR+1
(1)    15E1 : C0 BE                      ld      vDIVISOR
(1)    15E3 : 1F                         rrl
(1)    15E4 : C8 BB                      st      vDIVISOR        ; divisor>>=1
(1)    15E6 : 02                         ccl
(1)    15E7 : C0 B4                      ld      vQUOTIENT
(1)    15E9 : F0 B2                      add     vQUOTIENT
(1)    15EB : C8 B0                      st      vQUOTIENT
(1)    15ED : C0 AF                      ld      vQUOTIENT+1
(1)    15EF : F0 AD                      add     vQUOTIENT+1
(1)    15F1 : C8 AB                      st      vQUOTIENT+1     ; quotient<<=1
(1)    15F3 :                    udiv16_enter_loop:
(1)    15F3 : C0 AF                      ld      udiv16_borrow
(1)    15F5 : 98 0F                      jz      udiv16_add
(1)    15F7 :                    udiv16_sub:
(1)    15F7 : 03                         scl                     ; clear borrow
(1)    15F8 : C0 A5                      ld      vDIVIDEND
(1)    15FA : F8 A5                      cad     vDIVISOR
(1)    15FC : C8 A1                      st      vDIVIDEND
(1)    15FE : C0 A0                      ld      vDIVIDEND+1
(1)    1600 : F8 A0                      cad     vDIVISOR+1
(1)    1602 : C8 9C                      st      vDIVIDEND+1     ; dividend-=divisor
(1)    1604 : 90 0D                      jmp     udiv16_quotient
(1)    1606 :                    udiv16_add:
(1)    1606 : 02                         ccl
(1)    1607 : C0 96                      ld      vDIVIDEND
(1)    1609 : F0 96                      add     vDIVISOR
(1)    160B : C8 92                      st      vDIVIDEND
(1)    160D : C0 91                      ld      vDIVIDEND+1
(1)    160F : F0 91                      add     vDIVISOR+1
(1)    1611 : C8 8D                      st      vDIVIDEND+1     ; dividend+=divisor
(1)    1613 :                    udiv16_quotient:
(1)    1613 : 06                         csa
(1)    1614 : D4 80                      ani     S_CY
(1)    1616 : C8 8C                      st      udiv16_borrow
(1)    1618 : 98 02                      jz      udiv16_next    ; if dividend<divisor
(1)    161A : A8 81                      ild     vQUOTIENT      ; quotient++
(1)    161C :                    udiv16_next:
(1)    161C : B8 85                      dld     udiv16_bits     ; --bits
(1)    161E : 9C BB                      jnz     udiv16_loop     ; while bits!=0
(1)    1620 : C0 82                      ld      udiv16_borrow
(1)    1622 : 98 80                      jz      udiv16_adjust
(1)    1624 : 90 8B                      jmp     udiv16_exit
       1626 :
       1626 :                    ;;; Get character
       1626 :                    ;;; @return E char
       1626 :                    ;;; @return A 0 if no char received
       1626 :                    getchar_exit:
       1626 : C6 01                      ld      @1(P2)          ; pop P1
       1628 : 31                         xpal    P1
       1629 : C6 01                      ld      @1(P2)
       162B : 35                         xpah    P1
       162C : C6 01                      ld      @1(P2)          ; pop return value
       162E : 3D                         xppc    P1
       162F :                    getchar:
       162F : CE FF                      st      @-1(P2)         ; for return value
       1631 : C4 20                      ldi     L(ADDR(queue_remove))
       1633 : 31                         xpal    P1
       1634 : CE FE                      st      @-2(P2)
       1636 : C4 17                      ldi     H(ADDR(queue_remove))
       1638 : 35                         xpah    P1
       1639 : CA 01                      st      1(P2)           ; push P1
       163B : 04                         dint                    ; disable IRQ
       163C : 3D                         xppc    P1              ; call queue_remove
       163D : 00 20                      .dbyte  rx_queue
       163F : 05                         ien                     ; enable IRQ
       1640 : CA 02                      st      2(P2)           ; save return value
       1642 : 90 E2                      jmp     getchar_exit
       1644 :
       1644 :                    ;;; Put character
       1644 :                    ;;; @param A char
       1644 :                    putchar_exit:
       1644 : C6 01                      ld      @1(P2)          ; pop P1
       1646 : 31                         xpal    P1
       1647 : C6 01                      ld      @1(P2)
       1649 : 35                         xpah    P1
       164A : C6 01                      ld      @1(P2)          ; pop E
       164C : 01                         xae
       164D : C6 01                      ld      @1(P2)          ; pop A
       164F : 3D                         xppc    P1
       1650 :                    putchar:
       1650 : CE FF                      st      @-1(P2)         ; push A
       1652 : 40                         lde
       1653 : CE FF                      st      @-1(P2)         ; push E
       1655 : C4 D3                      ldi     L(ADDR(queue_add))
       1657 : 31                         xpal    P1
       1658 : CE FE                      st      @-2(P2)
       165A : C4 16                      ldi     H(ADDR(queue_add))
       165C : 35                         xpah    P1
       165D : CA 01                      st      1(P2)           ; push P1
       165F : C2 03                      ld      3(P2)           ; restore char
       1661 : 01                         xae                     ; E=char
       1662 :                    putchar_retry:
       1662 : 04                         dint                    ; disable interrupt
       1663 : 3D                         xppc    P1              ; call queue_add
       1664 : 10 20                      .dbyte  tx_queue
       1666 : 05                         ien                     ; enable interrupt
       1667 : 98 F9                      jz      putchar_retry   ; queue is full
       1669 : C4 00                      ldi     L(ACIA)
       166B : 31                         xpal    P1
       166C : C4 DF                      ldi     H(ACIA)
       166E : 35                         xpah    P1
       166F : C4 B4                      ldi     RX_INT_TX_INT   ; enable Tx interrupt
       1671 : C9 00                      st      ACIA_C(P1)
       1673 :                    putchar_return:
       1673 : 90 CF                      jmp     putchar_exit
       1675 :
       1675 :                    newline:
       1675 : C4 4F                      ldi     L(ADDR(putchar))
       1677 : 31                         xpal    P1
       1678 : CE FE                      st      @-2(P2)
       167A : C4 16                      ldi     H(ADDR(putchar))
       167C : 35                         xpah    P1
       167D : CA 01                      st      1(P2)
       167F : C4 0D                      ldi     X'0D
       1681 : 3D                         xppc    P1              ; print CR
       1682 : C4 0A                      ldi     X'0A
       1684 : 3D                         xppc    P1              ; print LF
       1685 : C6 01                      ld      @1(P2)
       1687 : 31                         xpal    P1
       1688 : C6 01                      ld      @1(P2)
       168A : 35                         xpah    P1
       168B : 3D                         xppc    P1              ; return
       168C :
       168C :                            include "queue.inc"
(1)    168C :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    168C :                    ;;; [queue] queue structure
(1)    168C : =0                 queue_len       =       0       ; queue length
(1)    168C : =1                 queue_size      =       1       ; buffer size
(1)    168C : =2                 queue_put       =       2       ; queue put index
(1)    168C : =3                 queue_get       =       3       ; queue get index
(1)    168C : =4                 queue_buf       =       4       ; buffer start offset
(1)    168C :
(1)    168C :                    ;;; [queue] Initialize queue
(1)    168C :                    ;;; @param A queue space size
(1)    168C :                    ;;; @param P1 return address pointer
(1)    168C :                    ;;; @param P1[1:2] queue space pointer
(1)    168C :                    ;;; @clobber A
(1)    168C :                    queue_init_exit:
(1)    168C : C6 01                      ld      @1(P2)          ; pop P1
(1)    168E : 31                         xpal    P1
(1)    168F : C6 01                      ld      @1(P2)
(1)    1691 : 35                         xpah    P1
(1)    1692 : C6 01                      ld      @1(P2)          ; discard work area
(1)    1694 : 3D                         xppc    P1
(1)    1695 :                    queue_init:
(1)    1695 : CE FF                      st      @-1(P2)         ; save queue space size
(1)    1697 : C5 01                      ld      @1(P1)          ; advance to queue space pointer
(1)    1699 : C5 01                      ld      @1(P1)          ; load queue work space pointer (le16)
(1)    169B : CE FE                      st      @-2(P2)         ; save lo(queue space)
(1)    169D : C1 00                      ld      0(P1)
(1)    169F : 35                         xpah    P1
(1)    16A0 : CA 01                      st      1(P2)           ; P[1:0] push P1
(1)    16A2 : C2 00                      ld      0(P2)
(1)    16A4 : 31                         xpal    P1              ; P1=queue space pointer
(1)    16A5 : CA 00                      st      0(P2)
(1)    16A7 : C4 00                      ldi     0
(1)    16A9 : C9 00                      st      queue_len(P1)   ; clear queue_len
(1)    16AB : C9 02                      st      queue_put(P1)
(1)    16AD : C9 03                      st      queue_get(P1)
(1)    16AF : C2 02                      ld      2(P2)           ; queue space size
(1)    16B1 : 03                         scl
(1)    16B2 : FC 04                      cai     queue_buf
(1)    16B4 : C9 01                      st      queue_size(P1)
(1)    16B6 : CA 02                      st      2(P2)           ; counter
(1)    16B8 : C5 04                      ld      @queue_buf(P1)  ; advanced pointer
(1)    16BA :                    queue_init_loop:
(1)    16BA : C4 00                      ldi     0
(1)    16BC : CD 01                      st      @1(P1)
(1)    16BE : BA 02                      dld     2(P2)
(1)    16C0 : 9C F8                      jnz     queue_init_loop
(1)    16C2 : 90 C8                      jmp     queue_init_exit
(1)    16C4 :
(1)    16C4 :                    ;;; [queue] Add an element to queue
(1)    16C4 :                    ;;; @param E an element
(1)    16C4 :                    ;;; @param P1 return address pointer
(1)    16C4 :                    ;;; @param P1[1:2] queue space pointer
(1)    16C4 :                    ;;; @return E an element
(1)    16C4 :                    ;;; @return A 0 if queue is full
(1)    16C4 :                    ;;; @clobber P1
(1)    16C4 :                    queue_add_exit:
(1)    16C4 : CA 05                      st      5(P2)           ; P2[5] return flag
(1)    16C6 : C6 02                      ld      @2(P2)          ; discard queue space pointer
(1)    16C8 : C6 01                      ld      @1(P2)          ; pop P1
(1)    16CA : 31                         xpal    P1
(1)    16CB : C6 01                      ld      @1(P2)
(1)    16CD : 35                         xpah    P1
(1)    16CE : C6 01                      ld      @1(P2)          ; restore E
(1)    16D0 : 01                         xae
(1)    16D1 : C6 01                      ld      @1(P2)          ; return flag
(1)    16D3 : 3D                         xppc    P1
(1)    16D4 :                    queue_add:
(1)    16D4 : C5 01                      ld      @1(P1)          ; advanced to queue space pointer
(1)    16D6 : C5 01                      ld      @1(P1)          ; load queue space pointer (le16)
(1)    16D8 : CE FA                      st      @-6(P2)         ; param, P1, elem, return flag
(1)    16DA : C1 00                      ld      0(P1)
(1)    16DC : CA 01                      st      1(P2)           ; P2[1:0] queue space pointer
(1)    16DE : 35                         xpah    P1
(1)    16DF : CA 03                      st      3(P2)           ; P2[3:2] saved P1
(1)    16E1 : C2 00                      ld      0(P2)
(1)    16E3 : 31                         xpal    P1
(1)    16E4 : CA 02                      st      2(P2)
(1)    16E6 : 40                         lde
(1)    16E7 : CA 04                      st      4(P2)           ; P2[4] save an element
(1)    16E9 : C1 00                      ld      queue_len(P1)
(1)    16EB : E1 01                      xor     queue_size(P1)
(1)    16ED : 98 D5                      jz      queue_add_exit  ; queue is full, A=0
(1)    16EF :                    queue_not_full:
(1)    16EF : A9 00                      ild     queue_len(P1)    ; update queue_len
(1)    16F1 : C2 00                      ld      0(P2)
(1)    16F3 : 02                         ccl
(1)    16F4 : F1 02                      add     queue_put(P1)
(1)    16F6 : 01                         xae
(1)    16F7 : C2 01                      ld      1(P2)
(1)    16F9 : F4 00                      adi     0
(1)    16FB : 35                         xpah    P1
(1)    16FC : 01                         xae
(1)    16FD : 31                         xpal    P1
(1)    16FE : C2 04                      ld      4(P2)           ; an element
(1)    1700 : C9 04                      st      queue_buf(P1)   ; store element
(1)    1702 : C2 00                      ld      0(P2)
(1)    1704 : 31                         xpal    P1
(1)    1705 : C2 01                      ld      1(P2)
(1)    1707 : 35                         xpah    P1
(1)    1708 : A9 02                      ild     queue_put(P1)   ; advanced queue_put
(1)    170A : E1 01                      xor     queue_size(P1)
(1)    170C : 9C 02                      jnz     queue_add_end   ; branch if queue_put != queue_size
(1)    170E : C9 02                      st      queue_put(P1)   ; reset queue_put
(1)    1710 :                    queue_add_end:
(1)    1710 : C4 01                      ldi     1
(1)    1712 : 90 B0                      jmp     queue_add_exit  ; an element added, A=1
(1)    1714 :
(1)    1714 :                    ;;; [queue] Remove an element from queue
(1)    1714 :                    ;;; @param P1 return address pointer
(1)    1714 :                    ;;; @param P1[1:2] queue space pointer
(1)    1714 :                    ;;; @return E an element
(1)    1714 :                    ;;; @return A 0 if queue is empty
(1)    1714 :                    ;;; @clobber P1
(1)    1714 :                    queue_remove_exit:
(1)    1714 : CA 04                      st      4(P2)           ; return flag
(1)    1716 : C6 02                      ld      @2(P2)          ; discard work area
(1)    1718 : C6 01                      ld      @1(P2)          ; pop P1
(1)    171A : 31                         xpal    P1
(1)    171B : C6 01                      ld      @1(P2)
(1)    171D : 35                         xpah    P1
(1)    171E : C6 01                      ld      @1(P2)          ; return flag
(1)    1720 : 3D                         xppc    P1              ; return
(1)    1721 :                    queue_remove:
(1)    1721 : C5 01                      ld      @1(P1)          ; advanced to queue space pointer
(1)    1723 : C5 01                      ld      @1(P1)          ; load queue space pointer (le16)
(1)    1725 : CE FB                      st      @-5(P2)         ; param, P1, return flag
(1)    1727 : C1 00                      ld      0(P1)
(1)    1729 : CA 01                      st      1(P2)           ; P2[1:0] queue space pointer
(1)    172B : 35                         xpah    P1
(1)    172C : CA 03                      st      3(P2)           ; P2[3:2] saved P1
(1)    172E : C2 00                      ld      0(P2)
(1)    1730 : 31                         xpal    P1
(1)    1731 : CA 02                      st      2(P2)
(1)    1733 : C1 00                      ld      queue_len(P1)
(1)    1735 : 98 DD                      jz      queue_remove_exit ; queue is empty, A=0
(1)    1737 :                    queue_not_empty:
(1)    1737 : B9 00                      dld     queue_len(P1)    ; update queue_len
(1)    1739 : C2 00                      ld      0(P2)
(1)    173B : 02                         ccl
(1)    173C : F1 03                      add     queue_get(P1)
(1)    173E : 01                         xae
(1)    173F : C2 01                      ld      1(P2)
(1)    1741 : F4 00                      adi     0
(1)    1743 : 35                         xpah    P1
(1)    1744 : 40                         lde
(1)    1745 : 31                         xpal    P1
(1)    1746 : C1 04                      ld      queue_buf(P1)   ; load element
(1)    1748 : 01                         xae                     ; E=element
(1)    1749 : C2 00                      ld      0(P2)
(1)    174B : 31                         xpal    P1
(1)    174C : C2 01                      ld      1(P2)
(1)    174E : 35                         xpah    P1
(1)    174F : A9 03                      ild     queue_get(P1)   ; advanced queue_get
(1)    1751 : E1 01                      xor     queue_size(P1)
(1)    1753 : 9C 02                      jnz     queue_remove_end ; branch if queue_put != queue_size
(1)    1755 : C9 03                      st      queue_get(P1)   ; reset queue_get
(1)    1757 :                    queue_remove_end:
(1)    1757 : C4 01                      ldi     1
(1)    1759 : 90 B9                      jmp     queue_remove_exit
       175B :
       175B :                    isr_sensea_exit:
       175B : C6 01                      ld      @1(P2)          ; pop P1
       175D : 31                         xpal    P1
       175E : C6 01                      ld      @1(P2)
       1760 : 35                         xpah    P1
       1761 : C6 01                      ld      @1(P2)          ; pop Status
       1763 : 07                         cas
       1764 : C6 01                      ld      @1(P2)          ; pop E
       1766 : 01                         xae
       1767 : C6 01                      ld      @1(P2)          ; pop A
       1769 : 05                         ien                     ; enable interrupt
       176A : 3F                         xppc    P3              ; return from interrupt
       176B :                    isr_sensea:
       176B : CE FF                      st      @-1(P2)         ; save A
       176D : 40                         lde
       176E : CE FF                      st      @-1(P2)         ; save E
       1770 : 06                         csa
       1771 : CE FF                      st      @-1(P2)         ; save Status
       1773 : C4 00                      ldi     L(ACIA)         ; save P1 and load P1
       1775 : 31                         xpal    P1
       1776 : CE FE                      st      @-2(P2)
       1778 : C4 DF                      ldi     H(ACIA)
       177A : 35                         xpah    P1
       177B : CA 01                      st      1(P2)
       177D : C1 00                      ld      ACIA_S(P1)
       177F : CE FF                      st      @-1(P2)         ; save ACIA_status
       1781 : D4 01                      ani     RDRF_bm
       1783 : 98 0C                      jz      isr_send
       1785 : C1 01                      ld      ACIA_D(P1)      ; receive character
       1787 : 01                         xae                     ; E=char
       1788 : C4 D3                      ldi     L(ADDR(queue_add))
       178A : 31                         xpal    P1
       178B : C4 16                      ldi     H(ADDR(queue_add))
       178D : 35                         xpah    P1
       178E : 3D                         xppc    P1              ; call queue_add
       178F : 00 20                      .dbyte  rx_queue
       1791 :                    isr_send:
       1791 : C6 01                      ld      @1(P2)          ; pop ACIA status
       1793 : D4 02                      ani     TDRE_bm
       1795 : 98 C4                      jz      isr_sensea_exit
       1797 : C4 20                      ldi     L(ADDR(queue_remove))
       1799 : 31                         xpal    P1
       179A : C4 17                      ldi     H(ADDR(queue_remove))
       179C : 35                         xpah    P1
       179D : 3D                         xppc    P1              ; call queue_remove
       179E : 10 20                      .dbyte  tx_queue
       17A0 : 98 0B                      jz      isr_send_empty
       17A2 : C4 00                      ldi     L(ACIA)
       17A4 : 31                         xpal    P1
       17A5 : C4 DF                      ldi     H(ACIA)
       17A7 : 35                         xpah    P1
       17A8 : 40                         lde
       17A9 : C9 01                      st      ACIA_D(P1)      ; send character
       17AB : 90 AE                      jmp     isr_sensea_exit
       17AD :                    isr_send_empty:
       17AD : C4 00                      ldi     L(ACIA)
       17AF : 31                         xpal    P1
       17B0 : C4 DF                      ldi     H(ACIA)
       17B2 : 35                         xpah    P1
       17B3 : C4 94                      ldi     RX_INT_TX_NO
       17B5 : C9 00                      st      ACIA_C(P1)      ; disable Tx interrupt
       17B7 : 90 A2                      jmp     isr_sensea_exit
       17B9 :
       17B9 :                            end
