          0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
          0 :                            include "i8085.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                            include "i8080.inc"
(2)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(2)       0 :                    ;;; i8080
(2)       0 :                            cpu     8080
(2)       0 :                    ;;; FLAGS Register
(2)       0 : =80                F_SIGN:         equ     10000000B ; set to 1 if negative
(2)       0 : =40                F_ZERO:         equ     01000000B ; set to 1 if zero
(2)       0 : =10                F_HALF_CARRY:   equ     00010000B ; set to 1 if carry from bit-3
(2)       0 : =4                 F_PARITY:       equ     00000100B ; set to 1 if even parity
(2)       0 : =1                 F_CARRY:        equ     00000001B ; set to 1 if carry
(2)       0 :                    ;;; Interrupt origin
(2)       0 : =0                 ORG_RESET:      equ     0000H   ; RESET
(2)       0 : =0                 ORG_RST0:       equ     0000H   ; RST 0
(2)       0 : =8                 ORG_RST1:       equ     0008H   ; RST 1
(2)       0 : =10                ORG_RST2:       equ     0010H   ; RST 2
(2)       0 : =18                ORG_RST3:       equ     0018H   ; RST 3
(2)       0 : =20                ORG_RST4:       equ     0020H   ; RST 4
(2)       0 : =28                ORG_RST5:       equ     0028H   ; RST 5
(2)       0 : =30                ORG_RST6:       equ     0030H   ; RST 6
(2)       0 : =38                ORG_RST7:       equ     0038H   ; RST 3
(1)       0 :                            cpu     8085
(1)       0 :                    ;;; i8085
(1)       0 :                    ;;; Set Innterrupt Maske
(1)       0 : =80                SIM_SOD:        equ     10000000B ; Serial Output Data
(1)       0 : =40                SIM_SDE:        equ     01000000B ; Serial Data Enable
(1)       0 : =10                SIM_R75:        equ     00010000B ; Reset RST 7.5 latch
(1)       0 : =8                 SIM_MSE:        equ     00001000B ; Mask Set Enable
(1)       0 : =4                 SIM_M75:        equ     00000100B ; RST 7.5 Mask
(1)       0 : =2                 SIM_M65:        equ     00000010B ; RST 6.5 Mask
(1)       0 : =1                 SIM_M55:        equ     00000001B ; RST 5.5 Mask
(1)       0 :                    ;;; Read Interrupt Mask
(1)       0 : =80                RIM_SID:        equ     10000000B ; Serial Input Data
(1)       0 : =40                RIM_I75:        equ     01000000B ; RST 7.5 Pending
(1)       0 : =20                RIM_I65:        equ     00100000B ; RST 6.5 Pending
(1)       0 : =10                RIM_I55:        equ     00010000B ; RST 5.5 Pending
(1)       0 : =8                 RIM_IE:         equ     00001000B ; Interrupt Enable
(1)       0 : =4                 RIM_M75:        equ     SIM_M75
(1)       0 : =2                 RIM_M65:        equ     SIM_M65
(1)       0 : =1                 RIM_M55:        equ     SIM_M55
(1)       0 :                    ;;; Interrupt origin
(1)       0 : =24                ORG_TRAP:       equ     0024H   ; TRAP
(1)       0 : =2C                ORG_RST55:      equ     002CH   ; RST 5.5
(1)       0 : =34                ORG_RST65:      equ     0034H   ; RST 6.5
(1)       0 : =3C                ORG_RST75:      equ     003CH   ; RST 7.5
          0 :
          0 :                    ;;; i8251 Universal Synchronous/Asynchronous Receiver/Transmitter
          0 : =0                 USART:          equ     00H
          0 : =0                 USARTD:         equ     USART+0 ; Receive/Transmit data
          0 : =1                 USARTS:         equ     USART+1 ; Srtatus register
          0 : =1                 USARTC:         equ     USART+1 ; Control register
          0 : =2                 USARTRV:        equ     USART+2 ; Receive interrupt vector (ORG_*)
          0 : =3                 USARTTV:        equ     USART+3 ; Transmit interrupt vector (ORG_*)
          0 :                            include "i8251.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; i8251 USART device emulator.
(1)       0 : =6                 MODE_STOP_gp:   equ     6
(1)       0 : =C0                MODE_STOP_gm:   equ     11000000B
(1)       0 : =40                MODE_STOP1_gc:  equ     (1 << MODE_STOP_gp)
(1)       0 : =80                MODE_STOP15_gc: equ     (2 << MODE_STOP_gp)
(1)       0 : =C0                MODE_STOP2_gc:  equ     (3 << MODE_STOP_gp)
(1)       0 : =20                MODE_EVEN_bm:   equ     00100000B
(1)       0 : =10                MODE_PARITY_bm: equ     00010000B
(1)       0 : =2                 MODE_LEN_gp:    equ     2
(1)       0 : =C                 MODE_LEN_gm:    equ     00001100B
(1)       0 : =0                 MODE_LEN5_gc:   equ     (0 << MODE_LEN_gp)
(1)       0 : =4                 MODE_LEN6_gc:   equ     (1 << MODE_LEN_gp)
(1)       0 : =8                 MODE_LEN7_gc:   equ     (2 << MODE_LEN_gp)
(1)       0 : =C                 MODE_LEN8_gc:   equ     (3 << MODE_LEN_gp)
(1)       0 : =0                 MODE_BAUD_gp:   equ     0
(1)       0 : =3                 MODE_BAUD_gm:   equ     00000011B
(1)       0 : =1                 MODE_BAUD_X1:   equ     (1 << MODE_BAUD_gp)
(1)       0 : =2                 MODE_BAUD_X16:  equ (2 << MODE_BAUD_gp)
(1)       0 : =3                 MODE_BAUD_X64:  equ (3 << MODE_BAUD_gp)
(1)       0 :                    ;;; Bit Definition of command register
(1)       0 : =80                CMD_EH_bm:      equ     10000000B   ; Enter hunt mode
(1)       0 : =40                CMD_IR_bm:      equ     01000000B   ; Internal Reset
(1)       0 : =20                CMD_RTS_bm:     equ     00100000B   ; Request To Send
(1)       0 : =10                CMD_ER_bm:      equ     00010000B   ; Error Reset
(1)       0 : =8                 CMD_SBRK_bm:    equ     00001000B   ; Send Break
(1)       0 : =4                 CMD_RxEN_bm:    equ     00000100B   ; Receive Enable
(1)       0 : =2                 CMD_DTR_bm:     equ     00000010B   ; Data Terminal Ready
(1)       0 : =1                 CMD_TxEN_bm:    equ     00000001B   ; Transmit enable
(1)       0 :
(1)       0 :                    ;;; Bit definition of status register
(1)       0 : =80                ST_DSR_bm:      equ     10000000B   ; Data Set Ready
(1)       0 : =40                ST_BRK_bm:      equ     01000000B   ; BREAK detected
(1)       0 : =20                ST_FE_bm:       equ     00100000B   ; Framing Error
(1)       0 : =10                ST_OE_bm:       equ     00010000B   ; Iverrun Error
(1)       0 : =8                 ST_PE_bm:       equ     00001000B   ; Parity Error
(1)       0 : =4                 ST_TxEMPTY_bm:  equ     00000100B   ; Transmitter empty
(1)       0 : =2                 ST_RxRDY_bm:    equ     00000010B   ; Receiver ready
(1)       0 : =1                 ST_TxRDY_bm:    equ     00000001B   ; Transmitter ready
          0 :                    ;;; Async 1stop 8data x16
          0 : =4E                ASYNC_MODE:     equ     MODE_STOP1_gc|MODE_LEN8_gc|MODE_BAUD_X16
          0 :                    ;;; RTS/DTR, error reset, Rx enable, Tx enable
          0 : =37                RX_EN_TX_EN:    equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm|CMD_TxEN_bm
          0 : =36                RX_EN_TX_DIS:   equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm
          0 :
       2000 :                            org     2000H
       2000 : =80                rx_queue_size:  equ     128
       2000 :                    rx_queue:       ds      rx_queue_size
       2080 : =80                tx_queue_size:  equ     128
       2080 :                    tx_queue:       ds      tx_queue_size
       2100 :
       1000 :                            org     1000H
       1000 : =1000              stack:  equ     $
       1000 :
          0 :                            org     ORG_RESET
          0 : C3 00 01                   jmp     init
          3 :
         2C :                            org     ORG_RST55
         2C : C3 58 04                   jmp     isr_intr_rx
         2F :
         34 :                            org     ORG_RST65
         34 : C3 6D 04                   jmp     isr_intr_tx
         37 :
        100 :                            org     0100H
        100 :                    init:
        100 : 31 00 10                   lxi     sp, stack
        103 : 21 00 20                   lxi     h, rx_queue
        106 : 06 80                      mvi     b, rx_queue_size
        108 : CD F6 03                   call    queue_init
        10B : 21 80 20                   lxi     h, tx_queue
        10E : 06 80                      mvi     b, tx_queue_size
        110 : CD F6 03                   call    queue_init
        113 :                    init_usart:
        113 : AF                         xra     a               ; clear A
        114 : D3 01                      out     USARTC
        116 : D3 01                      out     USARTC
        118 : D3 01                      out     USARTC          ; safest way to sync mode
        11A : 3E 40                      mvi     a, CMD_IR_bm
        11C : D3 01                      out     USARTC          ; reset
        11E : 00                         nop
        11F : 00                         nop
        120 : 3E 4E                      mvi     a, ASYNC_MODE
        122 : D3 01                      out     USARTC
        124 : 00                         nop
        125 : 00                         nop
        126 : 3E 36                      mvi     a, RX_EN_TX_DIS
        128 : D3 01                      out     USARTC
        12A : 3E 2C                      mvi     a, ORG_RST55
        12C : D3 02                      out     USARTRV         ; set RxRDY interrupt vector RST 5.5
        12E : 3E 34                      mvi     a, ORG_RST65
        130 : D3 03                      out     USARTTV         ; set TxRDY interrupt vector RST 6.5
        132 :
        132 : 20                         rim
        133 : E6 FC                      ani     ~(SIM_M55|SIM_M65) ; enable RST 5.5/RST 5.6
        135 : F6 18                      ori     SIM_MSE|SIM_R75
        137 : 30                         sim
        138 : FB                         ei
        139 :
        139 :                    loop:
        139 : CD 80 01                   call    mandelbrot
        13C : CD 61 01                   call    newline
        13F : F2 39 01                   jp      loop
        142 :
        142 :                    ;;; Get character
        142 :                    ;;; @return A
        142 :                    ;;; @return CC.C 0 if no character
        142 :                    getchar:
        142 : E5                         push    h
        143 : 21 00 20                   lxi     h, rx_queue
        146 : F3                         di
        147 : CD 34 04                   call    queue_remove
        14A : FB                         ei
        14B : E1                         pop     h
        14C : C9                         ret
        14D :
        14D :                    ;;; Put character
        14D :                    ;;; @param A
        14D :                    putchar:
        14D : F5                         push    psw
        14E : E5                         push    h
        14F : 21 80 20                   lxi     h, tx_queue
        152 :                    putchar_retry:
        152 : F3                         di
        153 : CD 0C 04                   call    queue_add
        156 : FB                         ei
        157 : D2 52 01                   jnc     putchar_retry   ; branch if queue is full
        15A : E1                         pop     h
        15B : 3E 37                      mvi     a, RX_EN_TX_EN  ; enable Tx
        15D : D3 01                      out     USARTC
        15F :                    putchar_exit:
        15F : F1                         pop     psw
        160 : C9                         ret
        161 :
        161 :                    ;;; Put newline
        161 :                    ;;; @clobber A
        161 :                    newline:
        161 : 3E 0D                      mvi     A, 0DH
        163 : CD 4D 01                   call    putchar
        166 : 3E 0A                      mvi     A, 0AH
        168 : C3 4D 01                   jmp     putchar
        16B :
        16B :                    ;;; Put newline
        16B :                    ;;; @clobber A
        16B :                    putspace:
        16B : 3E 20                      mvi     A, ' '
        16D : C3 4D 01                   jmp     putchar
        170 :
        170 :                            include "mandelbrot.inc"
(1)     170 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     170 :
(1)     170 :                    ;;; Sign extend A into BC
(1)     170 :                    ;;; @param A 8-bit value
(1)     170 :                    ;;; @return BC 16-bit value
(1)     170 :                    sex_BC:
(1)     170 : 06 00                      mvi     B, 0
(1)     172 : 4F                         mov     C, A
(1)     173 : B7                         ora     A
(1)     174 : F0                         rp
(1)     175 : 06 FF                      mvi     B, -1
(1)     177 : C9                         ret
(1)     178 :
(1)     178 :                    ;;; Sign extend A into HL
(1)     178 :                    ;;; @param A 8-bit value
(1)     178 :                    ;;; @return HL 16-bit value
(1)     178 :                    sex_HL:
(1)     178 : 26 00                      mvi     H, 0
(1)     17A : 6F                         mov     L, A
(1)     17B : B7                         ora     A
(1)     17C : F0                         rp
(1)     17D : 26 FF                      mvi     H, -1
(1)     17F : C9                         ret
(1)     180 :
(1)     180 : =32                Fv:     equ     50
(1)     180 :                    mandelbrot:
(1)     180 : 3E F4                      mvi     A, -12
(1)     182 : 32 DE 02                   sta     vY              ; Y=-12
(1)     185 :                    loop_y:
(1)     185 : 3E CF                      mvi     A, -49
(1)     187 : 32 E0 02                   sta     vX              ; X=-49
(1)     18A :                    loop_x:
(1)     18A : 3A E0 02                   lda     vX
(1)     18D : CD 70 01                   call    sex_BC          ; BC=X
(1)     190 : 11 E5 00                   lxi     D, 229
(1)     193 : CD 5E 03                   call    mul16           ; X*229
(1)     196 : 44                         mov     B, H
(1)     197 : 4D                         mov     C, L
(1)     198 : 11 64 00                   lxi     D, 100
(1)     19B : CD CD 03                   call    div16           ; X*229/100
(1)     19E : 22 CE 02                   shld    vC              ; C=X*229/200
(1)     1A1 : 22 D2 02                   shld    vA              ; A=C
(1)     1A4 : 3A DE 02                   lda     vY
(1)     1A7 : CD 70 01                   call    sex_BC          ; BC=Y
(1)     1AA : 11 A0 01                   lxi     D, 416
(1)     1AD : CD 5E 03                   call    mul16           ; Y*416
(1)     1B0 : 44                         mov     B, H
(1)     1B1 : 4D                         mov     C, L
(1)     1B2 : 11 64 00                   lxi     D, 100
(1)     1B5 : CD CD 03                   call    div16           ; Y*416/100
(1)     1B8 : 22 D0 02                   shld    vD              ; D=y*416/100
(1)     1BB : 22 D4 02                   shld    vB              ; B=D
(1)     1BE : AF                         xra     A
(1)     1BF : 32 E2 02                   sta     vI              ; I=0
(1)     1C2 :
(1)     1C2 :                            ;; lda     vY
(1)     1C2 :                            ;; call    sex_HL
(1)     1C2 :                            ;; mvi     A, 'Y'
(1)     1C2 :                            ;; call    print
(1)     1C2 :                            ;; lda     vX
(1)     1C2 :                            ;; call    sex_HL
(1)     1C2 :                            ;; mvi     A, 'X'
(1)     1C2 :                            ;; call    print
(1)     1C2 :                            ;; lhld    vC
(1)     1C2 :                            ;; mvi     A, 'C'
(1)     1C2 :                            ;; call    print
(1)     1C2 :                            ;; lhld    vD
(1)     1C2 :                            ;; mvi     A, 'D'
(1)     1C2 :                            ;; call    print
(1)     1C2 :                            ;; call    newline
(1)     1C2 :
(1)     1C2 :                    loop_i:
(1)     1C2 : 2A D4 02                   lhld    vB
(1)     1C5 : 44                         mov     B, H
(1)     1C6 : 4D                         mov     C, L
(1)     1C7 : 11 32 00                   lxi     D, Fv
(1)     1CA : CD CD 03                   call    div16           ; B/F
(1)     1CD : 22 D8 02                   shld    (vQ)            ; Q=B/F
(1)     1D0 : 44                         mov     B, H
(1)     1D1 : 4D                         mov     C, L
(1)     1D2 : 11 CE FF                   lxi     D, -Fv
(1)     1D5 : CD 5E 03                   call    mul16           ; -Q*F
(1)     1D8 : 54                         mov     D, H
(1)     1D9 : 5D                         mov     E, L
(1)     1DA : 2A D4 02                   lhld    vB
(1)     1DD : 19                         dad     D               ; S=B-Q*F
(1)     1DE : 22 DA 02                   shld    vS
(1)     1E1 : 2A D4 02                   lhld    vB
(1)     1E4 : 44                         mov     B, H
(1)     1E5 : 4D                         mov     C, L
(1)     1E6 : 54                         mov     D, H
(1)     1E7 : 5D                         mov     E, L
(1)     1E8 : CD 5E 03                   call    mul16           ; B*B
(1)     1EB : E5                         push    H               ; push B*B
(1)     1EC : 2A D2 02                   lhld    vA
(1)     1EF : 44                         mov     B, H
(1)     1F0 : 4D                         mov     C, L
(1)     1F1 : 54                         mov     D, H
(1)     1F2 : 5D                         mov     E, L
(1)     1F3 : CD 5E 03                   call    mul16           ; A*A
(1)     1F6 : D1                         pop     D               ; pop B*B
(1)     1F7 : CD 38 03                   call    neg_DE          ; -B*B
(1)     1FA : 19                         dad     D               ; A*A-B*B
(1)     1FB : 44                         mov     B, H
(1)     1FC : 4D                         mov     C, L
(1)     1FD : 11 32 00                   lxi     D, Fv
(1)     200 : CD CD 03                   call    div16           ; (A*A-B*B)/F
(1)     203 : 54                         mov     D, H
(1)     204 : 5D                         mov     E, L
(1)     205 : 2A CE 02                   lhld    vC
(1)     208 : 19                         dad     D               ; (A*A-B*B)/F+C
(1)     209 : E5                         push    H               ; push (A*A-B*B)/F+C
(1)     20A : 2A D2 02                   lhld    vA
(1)     20D : 44                         mov     B, H
(1)     20E : 4D                         mov     C, L
(1)     20F : 2A DA 02                   lhld    vS
(1)     212 : 54                         mov     D, H
(1)     213 : 5D                         mov     E, L
(1)     214 : CD 5E 03                   call    mul16           ; A*S
(1)     217 : 44                         mov     B, H
(1)     218 : 4D                         mov     C, L
(1)     219 : 11 32 00                   lxi     D, Fv
(1)     21C : CD CD 03                   call    div16           ; A*S/F
(1)     21F : E5                         push    H               ; push A*S/F
(1)     220 : 2A D2 02                   lhld    vA
(1)     223 : 44                         mov     B, H
(1)     224 : 4D                         mov     C, L
(1)     225 : 2A D8 02                   lhld    vQ
(1)     228 : 54                         mov     D, H
(1)     229 : 5D                         mov     E, L
(1)     22A : CD 5E 03                   call    mul16           ; A*Q
(1)     22D : D1                         pop     D               ; pop A*S/F
(1)     22E : 19                         dad     D               ; A*Q+A*S/F
(1)     22F : 29                         dad     H               ; 2*(A*Q+A*S/F)
(1)     230 : 54                         mov     D, H
(1)     231 : 5D                         mov     E, L
(1)     232 : 2A D0 02                   lhld    vD
(1)     235 : 19                         dad     D               ; 2*(A*Q+A*S/F)+D
(1)     236 : 22 D4 02                   shld    vB              ; B=2*(A*Q+A*S/F)+D
(1)     239 : E1                         pop     H               ; pop (A*A-B*B)/F+C
(1)     23A : 22 D2 02                   shld    vA              ; A=(A*A-B*B)/F+C
(1)     23D : 44                         mov     B, H
(1)     23E : 4D                         mov     C, L
(1)     23F : 11 32 00                   lxi     D, Fv
(1)     242 : CD CD 03                   call    div16           ; A/F
(1)     245 : 22 D6 02                   shld    vP              ; P=A/F
(1)     248 : 44                         mov     B, H
(1)     249 : 4D                         mov     C, L
(1)     24A : 54                         mov     D, H
(1)     24B : 5D                         mov     E, L
(1)     24C : CD 5E 03                   call    mul16           ; P*P
(1)     24F : E5                         push    H               ; push P*P
(1)     250 : 2A D4 02                   lhld    vB
(1)     253 : 44                         mov     B, H
(1)     254 : 4D                         mov     C, L
(1)     255 : 11 32 00                   lxi     D, Fv
(1)     258 : CD CD 03                   call    div16           ; B/F
(1)     25B : 22 D8 02                   shld    vQ              ; Q=B/F
(1)     25E : 44                         mov     B, H
(1)     25F : 4D                         mov     C, L
(1)     260 : 54                         mov     D, H
(1)     261 : 5D                         mov     E, L
(1)     262 : CD 5E 03                   call    mul16           ; Q*Q
(1)     265 : D1                         pop     D               ; pop P*P
(1)     266 : 19                         dad     D               ; P*P+Q*Q
(1)     267 : 22 DC 02                   shld    vT              ; T=P*P+Q*Q
(1)     26A :
(1)     26A :                            ;; call    putspace
(1)     26A :                            ;; lda     vI
(1)     26A :                            ;; call    sex_HL
(1)     26A :                            ;; mvi     A, 'I'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; lhld    vA
(1)     26A :                            ;; mvi     A, 'A'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; lhld    vB
(1)     26A :                            ;; mvi     A, 'B'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; lhld    vP
(1)     26A :                            ;; mvi     A, 'P'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; lhld    vQ
(1)     26A :                            ;; mvi     A, 'Q'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; lhld    vT
(1)     26A :                            ;; mvi     A, 'T'
(1)     26A :                            ;; call    print
(1)     26A :                            ;; call    newline
(1)     26A :
(1)     26A : 3A DD 02                   lda     vT+1
(1)     26D : C2 89 02                   jnz     print_i         ; if T>=256
(1)     270 : 3A DC 02                   lda     vT
(1)     273 : FE 05                      cpi     4+1
(1)     275 : D2 89 02                   jnc     print_i         ; if 4<T
(1)     278 : 3A E2 02                   lda     vI
(1)     27B : 3C                         inr     A
(1)     27C : 32 E2 02                   sta     vI              ; I+=1
(1)     27F : FE 10                      cpi     16
(1)     281 : DA C2 01                   jc      loop_i          ; if I<16
(1)     284 : 3E 20                      mvi     A, ' '
(1)     286 : C3 92 02                   jmp     print_char
(1)     289 :                    print_i:
(1)     289 : 3A E2 02                   lda     vI
(1)     28C : C6 90                      adi     90H
(1)     28E : 27                         daa
(1)     28F : CE 40                      aci     40H
(1)     291 : 27                         daa
(1)     292 :                    print_char:
(1)     292 : CD 4D 01                   call    putchar
(1)     295 :
(1)     295 :                            ;; push    PSW
(1)     295 :                            ;; mvi     A, '@'
(1)     295 :                            ;; call    putchar
(1)     295 :                            ;; mvi     A, '='
(1)     295 :                            ;; call    putchar
(1)     295 :                            ;; pop     PSW
(1)     295 :                            ;; call    putchar
(1)     295 :                            ;; call    newline
(1)     295 :
(1)     295 : CD 42 01                   call    getchar
(1)     298 : D2 A0 02                   jnc     next_x
(1)     29B : B7                         ora     a
(1)     29C : C2 A0 02                   jnz     next_x
(1)     29F : 76                         hlt                     ; halt to system
(1)     2A0 :                    next_x:
(1)     2A0 : 21 E0 02                   lxi     H, vX           ; X+=1
(1)     2A3 : 34                         inr     M
(1)     2A4 : 7E                         mov     A, M
(1)     2A5 : B7                         ora     A
(1)     2A6 : FA 8A 01                   jm      loop_x          ; if X<0
(1)     2A9 : FE 1E                      cpi     30
(1)     2AB : DA 8A 01                   jc      loop_x          ; if X<30
(1)     2AE : CD 61 01                   call    newline
(1)     2B1 : 21 DE 02                   lxi     H, vY
(1)     2B4 : 34                         inr     M               ; Y+=1
(1)     2B5 : 7E                         mov     A, M
(1)     2B6 : B7                         ora     A
(1)     2B7 : FA 85 01                   jm      loop_y          ; if Y<0
(1)     2BA : FE 0D                      cpi     13
(1)     2BC : DA 85 01                   jc      loop_y          ; if X<13
(1)     2BF : C9                         ret
(1)     2C0 :
(1)     2C0 :                    ;;; Print variable
(1)     2C0 :                    ;;; @param A variable name
(1)     2C0 :                    ;;; @param HL variable value
(1)     2C0 :                    print:
(1)     2C0 : CD 4D 01                   call    putchar
(1)     2C3 : 3E 3D                      mvi     A, '='
(1)     2C5 : CD 4D 01                   call    putchar
(1)     2C8 : CD E4 02                   call    print_int16
(1)     2CB : C3 6B 01                   jmp     putspace
(1)     2CE :
(1)     2CE :                    ;;; workspace
(1)     2CE :                    vC:     ds      2
(1)     2D0 :                    vD:     ds      2
(1)     2D2 :                    vA:     ds      2
(1)     2D4 :                    vB:     ds      2
(1)     2D6 :                    vP:     ds      2
(1)     2D8 :                    vQ:     ds      2
(1)     2DA :                    vS:     ds      2
(1)     2DC :                    vT:     ds      2
(1)     2DE :                    vY:     ds      2
(1)     2E0 :                    vX:     ds      2
(1)     2E2 :                    vI:     ds      2
        2E4 :                            include "arith.inc"
(1)     2E4 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     2E4 :                            cpu     8085
(1)     2E4 :
(1)     2E4 :                    ;;; Print signed 16-bit integer as decimal
(1)     2E4 :                    ;;; @param HL value
(1)     2E4 :                    ;;; @clobber A HL
(1)     2E4 :                    print_int16:
(1)     2E4 : 7C                         mov     A, H
(1)     2E5 : B5                         ora     L
(1)     2E6 : CA 18 03                   jz      print_uint16_zero
(1)     2E9 : 7C                         mov     A, H
(1)     2EA : B7                         ora     A
(1)     2EB : F2 FA 02                   jp      print_uint16
(1)     2EE : 3E 2D                      mvi     A, '-'
(1)     2F0 : CD 4D 01                   call    putchar
(1)     2F3 : 7D                         mov     A, L
(1)     2F4 : 2F                         cma
(1)     2F5 : 6F                         mov     L, A
(1)     2F6 : 7C                         mov     A, H
(1)     2F7 : 2F                         cma
(1)     2F8 : 67                         mov     H, A
(1)     2F9 : 23                         inx     H               ; HL=-value
(1)     2FA :                    print_uint16:
(1)     2FA : C5                         push    B
(1)     2FB : D5                         push    D
(1)     2FC : CD 02 03                   call    print_uint16_loop
(1)     2FF : D1                         pop     D
(1)     300 : C1                         pop     B
(1)     301 : C9                         ret
(1)     302 :                    print_uint16_loop:
(1)     302 : 7C                         mov     A, H
(1)     303 : B5                         ora     L
(1)     304 : C8                         rz
(1)     305 : 44                         mov     B, H
(1)     306 : 4D                         mov     C, L
(1)     307 : 11 0A 00                   lxi     D, 10
(1)     30A : CD 87 03                   call    udiv16          ; BC/DE = HL...BC
(1)     30D : C5                         push    B               ; push remainder
(1)     30E : CD 02 03                   call    print_uint16_loop
(1)     311 : E1                         pop     H               ; pop remainder
(1)     312 : 7D                         mov     A, L
(1)     313 : C6 30                      adi     '0'
(1)     315 : C3 4D 01                   jmp     putchar
(1)     318 :                    print_uint16_zero:
(1)     318 : 3E 30                      mvi     A, '0'
(1)     31A : C3 4D 01                   jmp     putchar
(1)     31D :
(1)     31D :                    ;;; Signed comparison; minuend - subtrahend
(1)     31D :                    ;;; @param BC minuend
(1)     31D :                    ;;; @param DE subtrahend
(1)     31D :                    ;;; @return PSW.Z, PSW.S
(1)     31D :                    ;;; @clobber A
(1)     31D :                    cmp16:
(1)     31D : C5                         push    B
(1)     31E : D5                         push    D
(1)     31F : E5                         push    H
(1)     320 : 1A                         ldax    D
(1)     321 : 79                         mov     A, C
(1)     322 : 93                         sub     E
(1)     323 : 6F                         mov     L, A
(1)     324 : 78                         mov     A, B
(1)     325 : 9A                         sbb     D
(1)     326 : 67                         mov     H, A            ; HL=minuend-subtrahend
(1)     327 : B5                         ora     L
(1)     328 : CA 34 03                   jz      cmp16_return    ; PSW.Z=1
(1)     32B : 7C                         mov     A, H            ; high(minuend-subtrahend)
(1)     32C : A8                         xra     B               ; high(minuend-subtrahend)^minuend
(1)     32D : 6F                         mov     L, A
(1)     32E : 78                         mov     A, B
(1)     32F : AA                         xra     D               ; high(minuend^subtrahend)
(1)     330 : A5                         ana     L               ; overflow
(1)     331 : AC                         xra     H               ; PSW.S=overflow^sign
(1)     332 : F6 01                      ori     1               ; clear PSW.Z
(1)     334 :                    cmp16_return:
(1)     334 : E1                         pop     H
(1)     335 : D1                         pop     D
(1)     336 : C1                         pop     B
(1)     337 : C9                         ret
(1)     338 :
(1)     338 :                    ;;; Negate; v
(1)     338 :                    ;;; @param DE v
(1)     338 :                    ;;; @return DE -v
(1)     338 :                    ;;; @clobber A
(1)     338 :                    neg_DE:
(1)     338 : 7A                         mov     A, D
(1)     339 : 2F                         cma
(1)     33A : 57                         mov     D, A
(1)     33B : 7B                         mov     A, E
(1)     33C : 2F                         cma
(1)     33D : 5F                         mov     E, A
(1)     33E : 13                         inx     D
(1)     33F : C9                         ret
(1)     340 :
(1)     340 :                    ;;; Unsigned multiplication; result = multiplicand * multiplier
(1)     340 :                    ;;; @param BC multiplicand
(1)     340 :                    ;;; @param DE multiplier
(1)     340 :                    ;;; @return HL result
(1)     340 :                    ;;; @clobber BC DE HL A
(1)     340 :                    umul16:
(1)     340 : 21 00 00                   lxi     H, 0            ; result=0
(1)     343 : C3 58 03                   jmp     umul16_check
(1)     346 :                    umul16_loop:
(1)     346 : B7                         ora     A               ; clear PSW.C
(1)     347 : 7A                         mov     A, D            ; multiplier >>= 1
(1)     348 : 1F                         rar
(1)     349 : 57                         mov     D, A
(1)     34A : 7B                         mov     A, E
(1)     34B : 1F                         rar
(1)     34C : 5F                         mov     E, A
(1)     34D : D2 51 03                   jnc     umul16_next     ; if lsb(multiplier) == 0
(1)     350 : 09                         dad     B               ; result += multiplicand
(1)     351 :                    umul16_next:
(1)     351 : B7                         ora     A               ; clear PSW.C
(1)     352 : 79                         mov     A, C            ; multiplicand <<= 1
(1)     353 : 17                         ral
(1)     354 : 4F                         mov     C, A
(1)     355 : 78                         mov     A, B
(1)     356 : 17                         ral
(1)     357 : 47                         mov     B, A
(1)     358 :                    umul16_check:
(1)     358 : 7A                         mov     A, D
(1)     359 : B3                         ora     E
(1)     35A : C2 46 03                   jnz     umul16_loop     ; while multiplier != 0
(1)     35D :                    umul16_end:
(1)     35D : C9                         ret
(1)     35E :
(1)     35E :                    ;;; Signed multiplication; result =multiplicand * multiplier
(1)     35E :                    ;;; @param BC multiplicand
(1)     35E :                    ;;; @param DE multiplier
(1)     35E :                    ;;; @return HL result
(1)     35E :                    ;;; @clobber A BC DE
(1)     35E :                    mul16:
(1)     35E : 78                         mov     A, B
(1)     35F : AA                         xra     D
(1)     360 : F5                         push    PSW             ; save high(multiplicand^multiplier)
(1)     361 : 78                         mov     A, B
(1)     362 : B7                         ora     A
(1)     363 : F2 6C 03                   jp      mul16_abs_muliplicand
(1)     366 : 2F                         cma
(1)     367 : 47                         mov     B, A
(1)     368 : 79                         mov     A, C
(1)     369 : 2F                         cma
(1)     36A : 4F                         mov     C, A
(1)     36B : 03                         inx     B               ; multiplicand = -multiplicand
(1)     36C :                    mul16_abs_muliplicand:
(1)     36C : 7A                         mov     A, D
(1)     36D : B7                         ora     A
(1)     36E : F2 77 03                   jp      mul16_multiply
(1)     371 : 2F                         cma
(1)     372 : 57                         mov     D, A
(1)     373 : 7B                         mov     A, E
(1)     374 : 2F                         cma
(1)     375 : 5F                         mov     E, A
(1)     376 : 13                         inx     D               ; multiplier = -multiplier
(1)     377 :                    mul16_multiply:
(1)     377 : CD 40 03                   call    umul16          ; HL = multiplicand * multiplier
(1)     37A : F1                         pop     PSW             ; save high(multiplicand^multiplier)
(1)     37B : B7                         ora     A
(1)     37C : F2 86 03                   jp      mul16_return
(1)     37F : 7C                         mov     A, H
(1)     380 : 2F                         cma
(1)     381 : 67                         mov     H, A
(1)     382 : 7D                         mov     A, L
(1)     383 : 2F                         cma
(1)     384 : 6F                         mov     L, A
(1)     385 : 23                         inx     H               ; result = -result
(1)     386 :                    mul16_return:
(1)     386 : C9                         ret
(1)     387 :
(1)     387 :                    ;;; Unsigned division; dividend / divisor = quotient ... remainder
(1)     387 :                    ;;; @praram BC dividend
(1)     387 :                    ;;; @praram DE divisor
(1)     387 :                    ;;; @return BC remainder
(1)     387 :                    ;;; @return HL quotient
(1)     387 :                    ;;; @clobber A DE
(1)     387 :                    udiv16:
(1)     387 : 7A                         mov     A, D
(1)     388 : B3                         ora     E
(1)     389 : C8                         rz                      ; divide by zero
(1)     38A : 2E 01                      mvi     L, 1            ; L=bits
(1)     38C : C3 97 03                   jmp     udiv16_prep
(1)     38F :                    udiv16_prep_loop:
(1)     38F : B7                         ora     A               ; clear PSW.C
(1)     390 : 7B                         mov     A, E            ; divisor <<= 1
(1)     391 : 17                         ral
(1)     392 : 5F                         mov     E, A
(1)     393 : 7A                         mov     A, D
(1)     394 : 17                         ral
(1)     395 : 57                         mov     D, A
(1)     396 : 2C                         inr     L               ; ++bits
(1)     397 :                    udiv16_prep:                    ; while msb(divisor) == 0
(1)     397 : 7A                         mov     A, D
(1)     398 : B7                         ora     A
(1)     399 : F2 8F 03                   jp      udiv16_prep_loop
(1)     39C : 7D                         mov     A, L
(1)     39D : F5                         push    PSW             ; push bits
(1)     39E : 60                         mov     H, B
(1)     39F : 69                         mov     L, C            ; HL=dividend
(1)     3A0 : AF                         xra     A
(1)     3A1 : 47                         mov     B, A
(1)     3A2 : 4F                         mov     C, A            ; BC=quotient
(1)     3A3 : C3 B5 03                   jmp     udiv16_enter_loop
(1)     3A6 :                    udiv16_loop:
(1)     3A6 : F5                         push    PSW             ; push bits
(1)     3A7 : B7                         ora     A               ; clear PSW.C
(1)     3A8 : 7A                         mov     A, D            ; divisor >>= 1
(1)     3A9 : 1F                         rar
(1)     3AA : 57                         mov     D, A
(1)     3AB : 7B                         mov     A, E
(1)     3AC : 1F                         rar
(1)     3AD : 5F                         mov     E, A
(1)     3AE : B7                         ora     A               ; clear PSW.C
(1)     3AF : 79                         mov     A, C            ; quotient <<= 1
(1)     3B0 : 17                         ral
(1)     3B1 : 4F                         mov     C, A
(1)     3B2 : 78                         mov     A, B
(1)     3B3 : 17                         ral
(1)     3B4 : 47                         mov     B, A
(1)     3B5 :                    udiv16_enter_loop:
(1)     3B5 : 7D                         mov     A, L
(1)     3B6 : 93                         sub     E
(1)     3B7 : 6F                         mov     L, A
(1)     3B8 : 7C                         mov     A, H
(1)     3B9 : 9A                         sbb     D
(1)     3BA : 67                         mov     H, A            ; dividend -= divisor
(1)     3BB : DA C2 03                   jc      udiv16_readd    ; if dividend < 0
(1)     3BE : 03                         inx     B               ; quotient |= 1
(1)     3BF : C3 C3 03                   jmp     udiv16_next    ;
(1)     3C2 :                    udiv16_readd:
(1)     3C2 : 19                         dad     D               ; dividend += divisor
(1)     3C3 :                    udiv16_next:
(1)     3C3 : F1                         pop     PSW
(1)     3C4 : 3D                         dcr     A               ; --bits
(1)     3C5 : C2 A6 03                   jnz     udiv16_loop     ; while bits != 0
(1)     3C8 : E5                         push    H               ; remainder
(1)     3C9 : C5                         push    B               ; quotient
(1)     3CA : E1                         pop     H
(1)     3CB : C1                         pop     B
(1)     3CC : C9                         ret
(1)     3CD :
(1)     3CD :                    ;;; Signed division; dividend / divisor = quotient ... remainder
(1)     3CD :                    ;;; @param BC dividend
(1)     3CD :                    ;;; @param DE divisor
(1)     3CD :                    ;;; @return BC remainder
(1)     3CD :                    ;;; @return HL quotient
(1)     3CD :                    ;;; @clobber A DE
(1)     3CD :                    div16:
(1)     3CD : 78                         mov     A, B
(1)     3CE : AA                         xra     D
(1)     3CF : F5                         push    PSW             ; save high(dividend^divisor)
(1)     3D0 : 78                         mov     A, B            ; H=high(dividend)
(1)     3D1 : B7                         ora     A
(1)     3D2 : F2 DB 03                   jp      div16_abs_dividend
(1)     3D5 : 2F                         cma
(1)     3D6 : 47                         mov     B, A
(1)     3D7 : 79                         mov     A, C
(1)     3D8 : 2F                         cma
(1)     3D9 : 4F                         mov     C, A
(1)     3DA : 03                         inx     B               ; dividend = -dividend
(1)     3DB :                    div16_abs_dividend:
(1)     3DB : 7A                         mov     A, D
(1)     3DC : B7                         ora     A
(1)     3DD : F2 E6 03                   jp      div16_divide
(1)     3E0 : 2F                         cma
(1)     3E1 : 57                         mov     D, A
(1)     3E2 : 7B                         mov     A, E
(1)     3E3 : 2F                         cma
(1)     3E4 : 5F                         mov     E, A
(1)     3E5 : 13                         inx     D               ; divisor = -divisor
(1)     3E6 :                    div16_divide:
(1)     3E6 : CD 87 03                   call    udiv16          ; HL=quotient, BC=remainder
(1)     3E9 : F1                         pop     PSW             ; A=high(dividend^divisor)
(1)     3EA : B7                         ora     A
(1)     3EB : F2 F5 03                   jp      div16_return
(1)     3EE : 7C                         mov     A, H
(1)     3EF : 2F                         cma
(1)     3F0 : 67                         mov     H, A
(1)     3F1 : 7D                         mov     A, L
(1)     3F2 : 2F                         cma
(1)     3F3 : 6F                         mov     L, A
(1)     3F4 : 23                         inx     H               ; quotient=-quotient
(1)     3F5 :                    div16_return:
(1)     3F5 : C9                         ret
        3F6 :                            include "queue.inc"
(1)     3F6 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     3F6 :                    ;;; [queue] queue structure
(1)     3F6 : =0                 queue_len:      equ     0       ; queue length
(1)     3F6 : =1                 queue_size:     equ     1       ; buffer size
(1)     3F6 : =2                 queue_put:      equ     2       ; queue put index
(1)     3F6 : =3                 queue_get:      equ     3       ; queue get index
(1)     3F6 : =4                 queue_buf:      equ     4       ; buffer start offset
(1)     3F6 :
(1)     3F6 :                    ;;; [queue] Initialize queue
(1)     3F6 :                    ;;; @param HL queue work space pointer
(1)     3F6 :                    ;;; @param B queue work space size
(1)     3F6 :                    ;;; @clobber B
(1)     3F6 :                    queue_init:
(1)     3F6 : F5                         push    psw
(1)     3F7 : E5                         push    h
(1)     3F8 : AF                         xra     a
(1)     3F9 : 36 00                      mvi     m, 0            ; queue_len
(1)     3FB : 78                         mov     a, b
(1)     3FC : DE 04                      sbi     queue_buf
(1)     3FE : 23                         inx     h
(1)     3FF : 77                         mov     m, a            ; queue_size
(1)     400 : C6 02                      adi     2               ; for queue_put and queue_get
(1)     402 :                    queue_init_loop:
(1)     402 : 23                         inx     h
(1)     403 : 36 00                      mvi     m, 0
(1)     405 : 05                         dcr     b
(1)     406 : C2 02 04                   jnz     queue_init_loop
(1)     409 : E1                         pop     h
(1)     40A : F1                         pop     psw
(1)     40B : C9                         ret
(1)     40C :
(1)     40C :                    ;;; [queue] Add an element to queue
(1)     40C :                    ;;; @param HL queue work space pointer
(1)     40C :                    ;;; @param A an element
(1)     40C :                    ;;; @return F.C 0 if queue is full
(1)     40C :                    queue_add:
(1)     40C : D5                         push    d
(1)     40D : 57                         mov     d, a            ; save an element
(1)     40E : 7E                         mov     a, m            ; queue_len
(1)     40F : 23                         inx     h
(1)     410 : BE                         cmp     m               ; queue_size
(1)     411 : 2B                         dcx     h
(1)     412 : 7A                         mov     a, d            ; restore an element
(1)     413 : DA 18 04                   jc      queue_add_store ; queue_len < queue_size
(1)     416 : D1                         pop     d               ; cleared carry is ensured by |jc|
(1)     417 : C9                         ret
(1)     418 :                    queue_add_store:
(1)     418 : E5                         push    h
(1)     419 : 34                         inr     m               ; queue_len++
(1)     41A : 23                         inx     h
(1)     41B : 23                         inx     h
(1)     41C : 5E                         mov     e, m            ; queue_put
(1)     41D : 16 00                      mvi     d, 0
(1)     41F : EB                         xchg                    ; DE points queue_put
(1)     420 : 19                         dad     d
(1)     421 : 23                         inx     h
(1)     422 : 23                         inx     h               ; offset of queue_buf
(1)     423 : 77                         mov     m, a            ; store an element
(1)     424 : EB                         xchg                    ; DE points a stored element
(1)     425 : 7E                         mov     a, m            ; queue_put
(1)     426 : 3C                         inr     a               ; queue_put++
(1)     427 : 2B                         dcx     h
(1)     428 : BE                         cmp     m               ; queue_size
(1)     429 : 23                         inx     h
(1)     42A : DA 2E 04                   jc      queue_add_update ; queue_put < queue_size
(1)     42D : AF                         xra     a                ; wrap around
(1)     42E :                    queue_add_update:
(1)     42E : 77                         mov     m, a            ; queue_put
(1)     42F : 1A                         ldax    d               ; restore an element
(1)     430 : E1                         pop     h
(1)     431 : D1                         pop     d
(1)     432 : 37                         stc                     ; set carry
(1)     433 : C9                         ret
(1)     434 :
(1)     434 :                    ;;; [queue] Remove an element from queue
(1)     434 :                    ;;; @param HL queue work space pointer
(1)     434 :                    ;;; @return A an element
(1)     434 :                    ;;; @return F.C 0 if queue is empty
(1)     434 :                    queue_remove:
(1)     434 : 7E                         mov     a, m            ; queue_len
(1)     435 : B7                         ora     a               ; clear carry
(1)     436 : C2 3A 04                   jnz     queue_remove_elem ; queue_len > 0
(1)     439 : C9                         ret                     ; carry is cleared by |ora|
(1)     43A :                    queue_remove_elem:
(1)     43A : D5                         push    d
(1)     43B : E5                         push    h
(1)     43C : 35                         dcr     m               ; queue_len--
(1)     43D : 23                         inx     h
(1)     43E : 23                         inx     h
(1)     43F : 23                         inx     h
(1)     440 : 7E                         mov     a, m            ; queue_get
(1)     441 : 5F                         mov     e, a
(1)     442 : 16 00                      mvi     d, 0
(1)     444 : EB                         xchg                    ; DE points queue_get
(1)     445 : 19                         dad     d
(1)     446 : 23                         inx     h               ; offset of queue_buf
(1)     447 : EB                         xchg                    ; DE points an element to read
(1)     448 : 3C                         inr     a               ; queue_get++
(1)     449 : 2B                         dcx     h
(1)     44A : 2B                         dcx     h
(1)     44B : BE                         cmp     m               ; queue_size
(1)     44C : 23                         inx     h
(1)     44D : 23                         inx     h
(1)     44E : DA 52 04                   jc      queue_remove_update ; queue_get < queue_size
(1)     451 : AF                         xra     a                   ; wrap around
(1)     452 :                    queue_remove_update:
(1)     452 : 77                         mov     m, a            ; queue_get
(1)     453 : 1A                         ldax    d               ; read an element
(1)     454 : E1                         pop     h
(1)     455 : D1                         pop     d
(1)     456 : 37                         stc                     ; set carry
(1)     457 : C9                         ret
        458 :
        458 :                    isr_intr_rx:
        458 : F5                         push    psw
        459 : DB 01                      in      USARTS
        45B : E6 02                      ani     ST_RxRDY_bm
        45D : CA 6A 04                   jz      isr_intr_rx_exit
        460 : DB 00                      in      USARTD          ; receive character
        462 : E5                         push    h
        463 : 21 00 20                   lxi     h, rx_queue
        466 : CD 0C 04                   call    queue_add
        469 : E1                         pop     h
        46A :                    isr_intr_rx_exit:
        46A : F1                         pop     psw
        46B : FB                         ei
        46C : C9                         ret
        46D :
        46D :                    isr_intr_tx:
        46D : F5                         push    psw
        46E : DB 01                      in      USARTS
        470 : E6 01                      ani     ST_TxRDY_bm
        472 : CA 82 04                   jz      isr_intr_tx_exit
        475 : E5                         push    h
        476 : 21 80 20                   lxi     h, tx_queue
        479 : CD 34 04                   call    queue_remove
        47C : E1                         pop     h
        47D : D2 85 04                   jnc     isr_intr_send_empty
        480 : D3 00                      out     USARTD          ; send character
        482 :                    isr_intr_tx_exit:
        482 : F1                         pop     psw
        483 : FB                         ei
        484 : C9                         ret
        485 :                    isr_intr_send_empty:
        485 : 3E 36                      mvi     a, RX_EN_TX_DIS
        487 : D3 01                      out     USARTC          ; disable Tx
        489 : F1                         pop     psw
        48A : FB                         ei
        48B : C9                         ret
        48C :
        48C :                            end
