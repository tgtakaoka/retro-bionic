          0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
          0 :                            cpu     8051
          0 :                            include "i8051.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                    ;;; i8051
(1)       0 :                    ;;; Interrupt origin
(1)       0 : =0                 ORG_RESET:      equ     000H    ; RESET
(1)       0 : =3                 ORG_IE0:        equ     003H    ; #INT0
(1)       0 : =B                 ORG_TF0:        equ     00BH    ; Timer 0 overflow
(1)       0 : =13                ORG_IE1:        equ     013H    ; #INT1
(1)       0 : =1B                ORG_TF1:        equ     01BH    ; Timer 1 overflow
(1)       0 : =23                ORG_RITI:       equ     023H    ; Receive & Transmit
(1)       0 :                    ;;; Register bank and internal memory
(1)       0 : =0                 BASE_BANK0:     equ     00H     ; Bank 0 R0-R7
(1)       0 : =8                 BASE_BANK1:     equ     08H     ; Bank 1 R0-R7
(1)       0 : =10                BASE_BANK2:     equ     10H     ; Bank 2 R0-R7
(1)       0 : =18                BASE_BANK3:     equ     18H     ; Bank 3 R0-R7
(1)       0 : =20                BASE_BIT:       equ     20H     ; Bit addressable memory
(1)       0 : =30                BASE_MEMORY:    equ     30H     ; general purpose memory
(1)       0 :                    ;;; Special function registers
(1)       0 : =E0                ACC:    equ     0E0H            ; Accumulator
(1)       0 : =F0                B:      equ     0F0H            ; B register
(1)       0 : =D0                PSW:    equ     0D0H            ; Program status word
(1)       0 : =81                SP:     equ     81H             ; Stack pointer
(1)       0 : =82                DPL:    equ     82H             ; DPTR low byte
(1)       0 : =83                DPH:    equ     83H             ; DPTR high byte
(1)       0 : =80                P0:     equ     80H             ; Port 0
(1)       0 : =90                P1:     equ     90H             ; Port 1
(1)       0 : =A0                P2:     equ     0A0H            ; Port 2
(1)       0 : =B0                P3:     equ     0B0H            ; Port 3
(1)       0 : =B8                IP:     equ     0B8H            ; Interrupt priority control
(1)       0 : =A8                IE:     equ     0A8H            ; Interrupt enable control
(1)       0 : =89                TMOD:   equ     89H             ; Timer/Counter mode control
(1)       0 : =88                TCON:   equ     88H             ; Timer/Counter control
(1)       0 : =8C                TH0:    equ     8CH             ; Timer/Counter 0 high byte
(1)       0 : =8A                TL0:    equ     8AH             ; Timer/Counter 0 low byte
(1)       0 : =8D                TH1:    equ     8DH             ; Timer/Counter 1 high byte
(1)       0 : =8B                TL1:    equ     8BH             ; Timer/Counter 1 low byte
(1)       0 : =98                SCON:   equ     98H             ; Serial control
(1)       0 : =99                SBUF:   equ     99H             ; Serial data buffer
(1)       0 : =87                PCON:   equ     87H             ; Power control
(1)       0 :                    ;;; PSW (0D0H) Program status word (bit addressable)
(1)       0 : =7                 CY:     equ     7              ; set to 1 if carry
(1)       0 : =6                 AC:     equ     6              ; set to 1 if auxillary carry
(1)       0 : =5                 F0:     equ     5              ; user flag 0
(1)       0 : =4                 RS1:    equ     4              ; register bank select
(1)       0 : =3                 RS0:    equ     3              ; register bank select
(1)       0 : =2                 OV:     equ     2              ; set to 1 if overflow
(1)       0 : =1                 F1:     equ     1              ; user flag 1
(1)       0 : =0                 P:      equ     0              ; parity bit
(1)       0 :                    ;;; IE (0A8H) Interrupt enable register
(1)       0 : =7                 EA:     equ     7               ; enable interrupt
(1)       0 : =4                 ES:     equ     4               ; Serial
(1)       0 : =3                 ET1:    equ     3               ; Timer 1 overflow
(1)       0 : =2                 EX1:    equ     2               ; #INT1
(1)       0 : =1                 ET0:    equ     1               ; Timer 0 overflow
(1)       0 : =0                 EX0:    equ     0               ; #INT0
(1)       0 :                    ;;; SCON (89H) Serial control (bit addressable)
(1)       0 : =7                 SM0:    equ     7               ; Serial mode SM[0:1:2]=010 8-bit UART
(1)       0 : =6                 SM1:    equ     6
(1)       0 : =5                 SM2:    equ     5
(1)       0 : =4                 REN:    equ     4               ; Enable reception
(1)       0 : =1                 TI:     equ     1               ; Transmit interrupt flag
(1)       0 : =0                 RI:     equ     0               ; Receive interrupt flag
(1)       0 :                    ;;; TCON (88H) Timer/Counter control register
(1)       0 : =7                 TF1:    equ     7               ; Timer 1 overflow flag
(1)       0 : =6                 TR1:    equ     6               ; Timer 1 run control
(1)       0 : =5                 TF0:    equ     5               ; Timer 0 overflow flag
(1)       0 : =4                 TR0:    equ     4               ; Timer 0 run control
(1)       0 :                    ;;; TMOD (89H) Timer/Counter mode control register
(1)       0 : =4                 T1MODE_gp:      equ     4       ; Timer 1 mode
(1)       0 : =0                 T0MODE_gp:      equ     0       ; Timer 0 mode
(1)       0 : =8                 TGATE:          equ     1000B
(1)       0 : =4                 TXPIN:          equ     0100B   ; Input from Tx pin
(1)       0 : =2                 T8MODE:         equ     0010B   ; 8-bit auto-reload timer/counter
(1)       0 :                    ;;; PCON (87H) Power control register
(1)       0 : =40                SMOD:   equ     1000000B        ; Double baudrate
          0 :
          0 :                    ;;; i8251 Universal Synchronous/Asynchronous Receiver/Transmitter
          0 : =FFF0              USART:          equ     0FFF0H
          0 : =FFF0              USARTD:         equ     USART+0 ; Receive/Transmit data
          0 : =FFF1              USARTS:         equ     USART+1 ; Srtatus register
          0 : =FFF1              USARTC:         equ     USART+1 ; Control register
          0 : =FFF2              USARTRV:        equ     USART+2 ; Receive interrupt vector (ORG_*)
          0 : =FFF3              USARTTV:        equ     USART+3 ; Transmit interrupt vector (ORG_*)
          0 :                            include "i8251.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; i8251 USART device emulator.
(1)       0 : =6                 MODE_STOP_gp:   equ     6
(1)       0 : =C0                MODE_STOP_gm:   equ     11000000B
(1)       0 : =40                MODE_STOP1_gc:  equ     (1 << MODE_STOP_gp)
(1)       0 : =80                MODE_STOP15_gc: equ     (2 << MODE_STOP_gp)
(1)       0 : =C0                MODE_STOP2_gc:  equ     (3 << MODE_STOP_gp)
(1)       0 : =20                MODE_EVEN_bm:   equ     00100000B
(1)       0 : =10                MODE_PARITY_bm: equ     00010000B
(1)       0 : =2                 MODE_LEN_gp:    equ     2
(1)       0 : =C                 MODE_LEN_gm:    equ     00001100B
(1)       0 : =0                 MODE_LEN5_gc:   equ     (0 << MODE_LEN_gp)
(1)       0 : =4                 MODE_LEN6_gc:   equ     (1 << MODE_LEN_gp)
(1)       0 : =8                 MODE_LEN7_gc:   equ     (2 << MODE_LEN_gp)
(1)       0 : =C                 MODE_LEN8_gc:   equ     (3 << MODE_LEN_gp)
(1)       0 : =0                 MODE_BAUD_gp:   equ     0
(1)       0 : =3                 MODE_BAUD_gm:   equ     00000011B
(1)       0 : =1                 MODE_BAUD_X1:   equ     (1 << MODE_BAUD_gp)
(1)       0 : =2                 MODE_BAUD_X16:  equ (2 << MODE_BAUD_gp)
(1)       0 : =3                 MODE_BAUD_X64:  equ (3 << MODE_BAUD_gp)
(1)       0 :                    ;;; Bit Definition of command register
(1)       0 : =80                CMD_EH_bm:      equ     10000000B   ; Enter hunt mode
(1)       0 : =40                CMD_IR_bm:      equ     01000000B   ; Internal Reset
(1)       0 : =20                CMD_RTS_bm:     equ     00100000B   ; Request To Send
(1)       0 : =10                CMD_ER_bm:      equ     00010000B   ; Error Reset
(1)       0 : =8                 CMD_SBRK_bm:    equ     00001000B   ; Send Break
(1)       0 : =4                 CMD_RxEN_bm:    equ     00000100B   ; Receive Enable
(1)       0 : =2                 CMD_DTR_bm:     equ     00000010B   ; Data Terminal Ready
(1)       0 : =1                 CMD_TxEN_bm:    equ     00000001B   ; Transmit enable
(1)       0 :
(1)       0 :                    ;;; Bit definition of status register
(1)       0 : =80                ST_DSR_bm:      equ     10000000B   ; Data Set Ready
(1)       0 : =40                ST_BRK_bm:      equ     01000000B   ; BREAK detected
(1)       0 : =20                ST_FE_bm:       equ     00100000B   ; Framing Error
(1)       0 : =10                ST_OE_bm:       equ     00010000B   ; Iverrun Error
(1)       0 : =8                 ST_PE_bm:       equ     00001000B   ; Parity Error
(1)       0 : =4                 ST_TxEMPTY_bm:  equ     00000100B   ; Transmitter empty
(1)       0 : =2                 ST_RxRDY_bm:    equ     00000010B   ; Receiver ready
(1)       0 : =1                 ST_TxRDY_bm:    equ     00000001B   ; Transmitter ready
(1)       0 : =1                 ST_RxRDY_bp:    equ     1           ; Receiver ready
(1)       0 : =0                 ST_TxRDY_bp:    equ     0           ; Transmitter ready
          0 :                    ;;; Async 1stop 8data x16
          0 : =4E                ASYNC_MODE:     equ     MODE_STOP1_gc|MODE_LEN8_gc|MODE_BAUD_X16
          0 :                    ;;; RTS/DTR, error reset, Rx enable, Tx enable
          0 : =37                RX_EN_TX_EN:    equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm|CMD_TxEN_bm
          0 : =36                RX_EN_TX_DIS:   equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm
          0 :
          0 :                    ;;; External data memory
       2000 :                            org     2000H
       2000 : =80                rx_buffer_size: equ     128
       2000 :                    rx_buffer:
       2000 :                            ds      rx_buffer_size
       2080 : =80                tx_buffer_size: equ     128
       2080 :                    tx_buffer:
       2080 :                            ds      tx_buffer_size
       2100 :                    print_uint16_buf:
       2100 :                            ds      8
       2108 :
       2108 :                    ;;; Internal data memory
         30 :                            org     BASE_MEMORY
         30 :                    rx_queue:       ds      queue_work_size
         36 :                    tx_queue:       ds      queue_work_size
         3C :                    ;;; Work area for mandelbrot.inc
         3C :                    tmp:    ds      2
         3E :                    c229:   ds      2
         40 :                    c416:   ds      2
         42 :                    c100:   ds      2
         44 :                    vF:     ds      2
         46 :                    vC:     ds      2
         48 :                    vD:     ds      2
         4A :                    vA:     ds      2
         4C :                    vB:     ds      2
         4E :                    vP:     ds      2
         50 :                    vQ:     ds      2
         52 :                    vS:     ds      2
         54 :                    vT:     ds      2
         56 :                    vY:     ds      1
         57 :                    vX:     ds      1
         58 :                    vI:     ds      1
         59 : =59                stack:          equ     $
         59 :
          0 :                            org     ORG_RESET
          0 : 02 00 26                   ljmp    init
          3 :                            org     ORG_IE0
          3 : 02 04 14                   ljmp    isr_intr_rx
          B :                            org     ORG_TF0
          B : 02 00 26                   ljmp    init
         13 :                            org     ORG_IE1
         13 : 02 04 35                   ljmp    isr_intr_tx
         1B :                            org     ORG_TF1
         1B : 02 00 26                   ljmp    init
         23 :                            org     ORG_RITI
         23 : 02 00 26                   ljmp    init
         26 :
         26 :                    init:
         26 : 75 81 58                   mov     SP, #stack-1
         29 : 78 30                      mov     R0, #rx_queue
         2B : 79 80                      mov     R1, #rx_buffer_size
         2D : 90 20 00                   mov     DPTR, #rx_buffer
         30 : 71 AD                      acall   queue_init
         32 : 78 36                      mov     R0, #tx_queue
         34 : 79 80                      mov     R1, #tx_buffer_size
         36 : 90 20 80                   mov     DPTR, #tx_buffer
         39 : 71 AD                      acall   queue_init
         3B :                    init_usart:
         3B : 90 FF F1                   mov     DPTR, #USARTC
         3E : E4                         clr     A
         3F : F0                         movx    @DPTR, A
         40 : F0                         movx    @DPTR, A
         41 : F0                         movx    @DPTR, A        ; safest way to sync mode
         42 : 74 40                      mov     a, #CMD_IR_bm
         44 : F0                         movx    @DPTR, A        ; reset
         45 : 00                         nop
         46 : 00                         nop
         47 : 74 4E                      mov     a, #ASYNC_MODE
         49 : F0                         movx    @DPTR, A
         4A : 00                         nop
         4B : 00                         nop
         4C : 74 37                      mov     a, #RX_EN_TX_EN
         4E : F0                         movx    @DPTR, A
         4F : A3                         inc     DPTR
         50 : 74 03                      mov     A, #ORG_IE0
         52 : F0                         movx    @DPTR, A        ; enable Rx interrupt using INT0
         53 : D2 A8                      setb    IE.EX0          ; enable INT0
         55 : 74 13                      mov     A, #ORG_IE1
         57 : A3                         inc     DPTR
         58 : F0                         movx    @DPTR, A        ; enable Tx interrupt using INT1
         59 : D2 AA                      setb    IE.EX1          ; enable INT1
         5B : D2 AF                      setb    IE.EA           ; enable interrupt
         5D :
         5D :                    loop:
         5D : 11 B0                      acall   mandelbrot
         5F : 11 7F                      acall   newline
         61 : 80 FA                      sjmp    loop
         63 :
         63 :                    ;;; Get character
         63 :                    ;;; @return A
         63 :                    ;;; @return PSW.C 0 if no character
         63 :                    getchar:
         63 : C0 83                      push    DPH
         65 : C0 82                      push    DPL
         67 : E8                         mov     A, R0
         68 : C0 E0                      push    ACC             ; save R0
         6A : 78 30                      mov     R0, #rx_queue
         6C : C2 AF                      clr     IE.EA
         6E : 71 ED                      acall   queue_remove
         70 : D2 AF                      setb    IE.EA
         72 : C8                         xch     A, R0           ; R0=character
         73 : D0 E0                      pop     ACC
         75 : C8                         xch     A, R0           ; restore R0
         76 : D0 82                      pop     DPL
         78 : D0 83                      pop     DPH
         7A : 22                         ret
         7B :
         7B :                    ;;; Put space
         7B :                    ;;; @clobber A
         7B :                    putspace:
         7B : 74 20                      mov     A, #' '
         7D : 80 06                      sjmp    putchar
         7F :
         7F :                    ;;; Put newline
         7F :                    ;;; @clobber A
         7F :                    newline:
         7F : 74 0D                      mov     A, #0DH
         81 : 11 85                      acall   putchar
         83 : 74 0A                      mov     A, #0AH
         85 :
         85 :                    ;;; Put character
         85 :                    ;;; @param A
         85 :                    ;;; @clobber DPTR A
         85 :                    putchar:
         85 : C0 83                      push    DPH
         87 : C0 82                      push    DPL             ; save DPTR
         89 : C8                         xch     A, R0           ; save character
         8A : C0 E0                      push    ACC             ; save R0
         8C : E8                         mov     A, R0           ; restore character
         8D :                    putchar_loop:
         8D : 78 36                      mov     R0, #tx_queue
         8F : C2 AF                      clr     IE.EA
         91 : 71 C2                      acall   queue_add
         93 : D2 AF                      setb    IE.EA
         95 : 50 F6                      jnc     putchar_loop    ; branch if queue is full
         97 : 90 FF F1                   mov     DPTR, #USARTC
         9A : 74 37                      mov     A, #RX_EN_TX_EN ; enable Tx
         9C : F0                         movx    @DPTR, A
         9D : D0 E0                      pop     ACC
         9F : F8                         mov     R0, A           ; restore R0
         A0 : D0 82                      pop     DPL
         A2 : D0 83                      pop     DPH             ; restore DPTR
         A4 : 22                         ret
         A5 :
         A5 :                            include "mandelbrot.inc"
(1)      A5 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)      A5 :
(1)      A5 :                    ;;; Sign extend 8-bit to 16-bit
(1)      A5 :                    ;;; @param A 8-bit value
(1)      A5 :                    ;;; @return R5:R4 sign extended 16-bit value
(1)      A5 :                    ;;; @clobber A
(1)      A5 :                    sex_A:
(1)      A5 : FC                         mov     R4, A
(1)      A6 : 20 E7 03                   jb      ACC.7, sex_Aminus
(1)      A9 : E4                         clr     A
(1)      AA : 80 02                      sjmp    sex_Aend
(1)      AC :                    sex_Aminus:
(1)      AC : 74 FF                      mov     A, #-1
(1)      AE :                    sex_Aend:
(1)      AE : FD                         mov     R5, A
(1)      AF : 22                         ret
(1)      B0 :
(1)      B0 :                    mandelbrot:
(1)      B0 : 7C E5                      mov     R4, #LOW(229)
(1)      B2 : 7D 00                      mov     R5, #HIGH(229)
(1)      B4 : 7B 3E                      mov     R3, #c229
(1)      B6 : 31 F0                      acall   set             ; c229=229
(1)      B8 : 7C A0                      mov     R4, #LOW(416)
(1)      BA : 7D 01                      mov     R5, #HIGH(416)
(1)      BC : 7B 40                      mov     R3, #c416
(1)      BE : 31 F0                      acall   set             ; c416=416
(1)      C0 : 7C 64                      mov     R4, #LOW(100)
(1)      C2 : 7D 00                      mov     R5, #HIGH(100)
(1)      C4 : 7B 42                      mov     R3, #c100
(1)      C6 : 31 F0                      acall   set             ; c100=100
(1)      C8 : 7C 32                      mov     R4, #LOW(50)
(1)      CA : 7D 00                      mov     R5, #HIGH(50)
(1)      CC : 7B 44                      mov     R3, #vF         ; F=50
(1)      CE : 31 F0                      acall   set
(1)      D0 : 75 56 F4                   mov     vY, #-12        ; Y=-12
(1)      D3 :                    loop_y:
(1)      D3 : 75 57 CF                   mov     vX, #-49        ; X=-49
(1)      D6 :                    loop_x:
(1)      D6 : E5 57                      mov     A, vX
(1)      D8 : 11 A5                      acall   sex_A
(1)      DA : 7B 46                      mov     R3, #vC
(1)      DC : 31 F0                      acall   set             ; C=X
(1)      DE : 7A 46                      mov     R2, #vC
(1)      E0 : 7B 3E                      mov     R3, #c229
(1)      E2 : 51 F0                      acall   mulsi2          ; C=X*229
(1)      E4 : 7A 46                      mov     R2, #vC
(1)      E6 : 7B 42                      mov     R3, #c100
(1)      E8 : 71 77                      acall   divsi2          ; C=X*229/100
(1)      EA : E5 56                      mov     A, vY
(1)      EC : 11 A5                      acall   sex_A
(1)      EE : 7B 48                      mov     R3, #vD
(1)      F0 : 31 F0                      acall   set             ; D=Y
(1)      F2 : 7A 48                      mov     R2, #vD
(1)      F4 : 7B 40                      mov     R3, #c416
(1)      F6 : 51 F0                      acall   mulsi2          ; D=Y*416
(1)      F8 : 7A 48                      mov     R2, #vD
(1)      FA : 7B 42                      mov     R3, #c100
(1)      FC : 71 77                      acall   divsi2          ; D=Y*416/100
(1)      FE : 7A 4A                      mov     R2, #vA
(1)     100 : 7B 46                      mov     R3, #vC
(1)     102 : 31 F8                      acall   assign          ; A=C
(1)     104 : 7A 4C                      mov     R2, #vB
(1)     106 : 7B 48                      mov     R3, #vD
(1)     108 : 31 F8                      acall   assign          ; B=D
(1)     10A : 75 58 00                   mov     vI, #0          ; I=0
(1)     10D :
(1)     10D :                            ;; mov     R2, #vY
(1)     10D :                            ;; mov     A, #'Y'
(1)     10D :                            ;; acall   print8          print Y
(1)     10D :                            ;; mov     R2, #vX
(1)     10D :                            ;; mov     A, #'X'
(1)     10D :                            ;; acall   print8          print X
(1)     10D :                            ;; mov     R2, #vC
(1)     10D :                            ;; mov     A, #'C'
(1)     10D :                            ;; acall   print           print C
(1)     10D :                            ;; mov     R2, #vD
(1)     10D :                            ;; mov     A, #'D'
(1)     10D :                            ;; acall   print           print D
(1)     10D :                            ;; acall   newline
(1)     10D :
(1)     10D :                    loop_i:
(1)     10D : 7A 50                      mov     R2, #vQ
(1)     10F : 7B 4C                      mov     R3, #vB
(1)     111 : 31 F8                      acall   assign          ; Q=B
(1)     113 : 7B 44                      mov     R3, #vF
(1)     115 : 71 77                      acall   divsi2          ; Q=B/F
(1)     117 : 7A 3C                      mov     R2, #tmp
(1)     119 : 7B 50                      mov     R3, #vQ
(1)     11B : 31 F8                      acall   assign          ; tmp=Q
(1)     11D : 7B 44                      mov     R3, #vF
(1)     11F : 51 F0                      acall   mulsi2          ; tmp=Q*F
(1)     121 : 7A 52                      mov     R2, #vS
(1)     123 : 7B 4C                      mov     R3, #vB
(1)     125 : 31 F8                      acall   assign          ; S=B
(1)     127 : 7B 3C                      mov     R3, #tmp
(1)     129 : 51 9C                      acall   subsi2          ; S=B-Q*F
(1)     12B : 7A 3C                      mov     R2, #tmp
(1)     12D : 7B 4C                      mov     R3, #vB
(1)     12F : 31 F8                      acall   assign          ; tmp=B
(1)     131 : 51 F0                      acall   mulsi2          ; tmp=B*B
(1)     133 : 7A 54                      mov     R2, #vT
(1)     135 : 7B 4A                      mov     R3, #vA
(1)     137 : 31 F8                      acall   assign          ; T=A
(1)     139 : 51 F0                      acall   mulsi2          ; T=A*A
(1)     13B : 7A 54                      mov     R2, #vT
(1)     13D : 7B 3C                      mov     R3, #tmp
(1)     13F : 51 9C                      acall   subsi2          ; T=A*A-B*B
(1)     141 : 7A 54                      mov     R2, #vT
(1)     143 : 7B 44                      mov     R3, #vF
(1)     145 : 71 77                      acall   divsi2          ; T=(A*A-B*B)/F
(1)     147 : 7A 54                      mov     R2, #vT
(1)     149 : 7B 46                      mov     R3, #vC
(1)     14B : 51 8C                      acall   addsi2          ; T=(A*A-B*B)/F+C
(1)     14D : 7A 3C                      mov     R2, #tmp
(1)     14F : 7B 4A                      mov     R3, #vA         ; tmp=A
(1)     151 : 31 F8                      acall   assign
(1)     153 : 7B 52                      mov     R3, #vS
(1)     155 : 51 F0                      acall   mulsi2          ; tmp=A*S
(1)     157 : 7A 3C                      mov     R2, #tmp
(1)     159 : 7B 44                      mov     R3, #vF
(1)     15B : 71 77                      acall   divsi2          ; tmp=A*S/F
(1)     15D : 7A 4C                      mov     R2, #vB
(1)     15F : 7B 4A                      mov     R3, #vA
(1)     161 : 31 F8                      acall   assign          ; B=A
(1)     163 : 7B 50                      mov     R3, #vQ
(1)     165 : 51 F0                      acall   mulsi2          ; B=A*Q
(1)     167 : 7A 4C                      mov     R2, #vB
(1)     169 : 7B 3C                      mov     R3, #tmp
(1)     16B : 51 8C                      acall   addsi2          ; B=A*Q+A*S/F
(1)     16D : 7A 4C                      mov     R2, #vB
(1)     16F : 7B 4C                      mov     R3, #vB
(1)     171 : 51 8C                      acall   addsi2          ; B=2*(A*Q+A*S/F)
(1)     173 : 7A 4C                      mov     R2, #vB
(1)     175 : 7B 48                      mov     R3, #vD
(1)     177 : 51 8C                      acall   addsi2          ; B=2*(A*Q+A*S/F)+D
(1)     179 : 7A 4A                      mov     R2, #vA
(1)     17B : 7B 54                      mov     R3, #vT
(1)     17D : 31 F8                      acall   assign          ; A=T
(1)     17F : 7A 4E                      mov     R2, #vP
(1)     181 : 31 F8                      acall   assign          ; P=A
(1)     183 : 7B 44                      mov     R3, #vF
(1)     185 : 71 77                      acall   divsi2          ; P=A/F
(1)     187 : 7A 50                      mov     R2, #vQ
(1)     189 : 7B 4C                      mov     R3, #vB
(1)     18B : 31 F8                      acall   assign          ; Q=B
(1)     18D : 7B 44                      mov     R3, #vF
(1)     18F : 71 77                      acall   divsi2          ; Q=B/F
(1)     191 : 7A 3C                      mov     R2, #tmp
(1)     193 : 7B 50                      mov     R3, #vQ
(1)     195 : 31 F8                      acall   assign          ; tmp=Q
(1)     197 : 51 F0                      acall   mulsi2          ; tmp=Q*Q
(1)     199 : 7A 54                      mov     R2, #vT
(1)     19B : 7B 4E                      mov     R3, #vP
(1)     19D : 31 F8                      acall   assign          ; T=P
(1)     19F : 51 F0                      acall   mulsi2          ; T=P*P
(1)     1A1 : 7A 54                      mov     R2, #vT
(1)     1A3 : 7B 3C                      mov     R3, #tmp
(1)     1A5 : 51 8C                      acall   addsi2          ; T=P*P+Q*Q (T>=0)
(1)     1A7 :
(1)     1A7 :                            ;; acall   putspace
(1)     1A7 :                            ;; mov     R2, #vI
(1)     1A7 :                            ;; mov     A, #'I'
(1)     1A7 :                            ;; acall   print8          ; print I
(1)     1A7 :                            ;; mov     R2, #vA
(1)     1A7 :                            ;; mov     A, #'A'
(1)     1A7 :                            ;; acall   print           ; print A
(1)     1A7 :                            ;; mov     R2, #vB
(1)     1A7 :                            ;; mov     A, #'B'
(1)     1A7 :                            ;; acall   print           ; print B
(1)     1A7 :                            ;; mov     R2, #vP
(1)     1A7 :                            ;; mov     A, #'P'
(1)     1A7 :                            ;; acall   print           ; print P
(1)     1A7 :                            ;; mov     R2, #vQ
(1)     1A7 :                            ;; mov     A, #'Q'
(1)     1A7 :                            ;; acall   print           ; print Q
(1)     1A7 :                            ;; mov     R2, #vT
(1)     1A7 :                            ;; mov     A, #'T'
(1)     1A7 :                            ;; acall   print           ; print T
(1)     1A7 :                            ;; acall   newline
(1)     1A7 :
(1)     1A7 : E5 55                      mov     A, vT+1         ; A=hi(T)
(1)     1A9 : 70 15                      jnz     print_i         ; if T>=256
(1)     1AB : E5 54                      mov     A, vT           ; A=lo(T)
(1)     1AD : 24 FB                      add     A, #-(4+1)
(1)     1AF : 40 0F                      jc      print_i         ; if T>=5
(1)     1B1 : 05 58                      inc     vI              ; I+=1
(1)     1B3 : E5 58                      mov     A, vI           ; A=I (I>=0)
(1)     1B5 : B4 10 02                   cjne    A, #16, jmp_loop_i
(1)     1B8 : 80 02                      sjmp    print_space
(1)     1BA :                    jmp_loop_i:
(1)     1BA : 21 0D                      ajmp    loop_i          ; if I<16
(1)     1BC :                    print_space:
(1)     1BC : 74 20                      mov     A, #' '
(1)     1BE : 80 0A                      sjmp    print_char
(1)     1C0 :                    print_i:
(1)     1C0 : E5 58                      mov     A, vI
(1)     1C2 : 24 F6                      add     A, #-10
(1)     1C4 : 50 02                      jnc     print_dec       ; if I<10
(1)     1C6 : 24 07                      add     A, #'A'-('0'+10)
(1)     1C8 :                    print_dec:
(1)     1C8 : 24 3A                      add     A, #10+'0'
(1)     1CA :                    print_char:
(1)     1CA :                            ;; push    ACC             ; push A
(1)     1CA :                            ;; mov     A, #'@'
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; mov     A, #'='
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; pop     ACC
(1)     1CA :                            ;; push    ACC             ; restore A
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; acall   newline
(1)     1CA :                            ;; pop     ACC             ; pop A
(1)     1CA :
(1)     1CA : 11 85                      acall   putchar
(1)     1CC : 11 63                      acall   getchar
(1)     1CE : 50 03                      jnc     next_x
(1)     1D0 : 70 01                      jnz     next_x
(1)     1D2 : A5                         db      0A5H            ; halt to system
(1)     1D3 :                    next_x:
(1)     1D3 : 05 57                      inc     vX               ; X+=1
(1)     1D5 : E5 57                      mov     A, vX
(1)     1D7 : 20 E7 04                   jb      ACC.7, jmp_loop_x ; if hi(X)<0
(1)     1DA : 24 E2                      add     A, #-30
(1)     1DC : 40 02                      jc      next_y
(1)     1DE :                    jmp_loop_x:
(1)     1DE : 01 D6                      ajmp    loop_x          ; if X<30
(1)     1E0 :                    next_y:
(1)     1E0 : 11 7F                      acall   newline
(1)     1E2 : 05 56                      inc     vY              ; Y+=1
(1)     1E4 : E5 56                      mov     A, vY
(1)     1E6 : 20 E7 04                   jb      ACC.7, jmp_loop_y ; if hi(Y)<0
(1)     1E9 : 24 F3                      add     A, #-13
(1)     1EB : 40 02                      jc      mandelbrot_end
(1)     1ED :                    jmp_loop_y:
(1)     1ED : 01 D3                      ajmp    loop_y          ; if Y<13
(1)     1EF :                    mandelbrot_end:
(1)     1EF : 22                         ret
(1)     1F0 :
(1)     1F0 :                    ;;; Set value to variable
(1)     1F0 :                    ;;; @param R5:R4 value
(1)     1F0 :                    ;;; @param R3 &variable
(1)     1F0 :                    ;;; @clobber A R0
(1)     1F0 :                    set:
(1)     1F0 : EB                         mov     A, R3
(1)     1F1 : F8                         mov     R0, A
(1)     1F2 : EC                         mov     A, R4
(1)     1F3 : F6                         mov     @R0, A
(1)     1F4 : ED                         mov     A, R5
(1)     1F5 : 08                         inc     R0
(1)     1F6 : F6                         mov     @R0, A
(1)     1F7 : 22                         ret
(1)     1F8 :
(1)     1F8 :                    ;;; Assign variable; v1 = v2
(1)     1F8 :                    ;;; @param R2 &v1
(1)     1F8 :                    ;;; @param R3 &v2
(1)     1F8 :                    ;;; @clobber A R0
(1)     1F8 :                    assign:
(1)     1F8 : EB                         mov     A, R3
(1)     1F9 : F8                         mov     R0, A           ; R0=&v2
(1)     1FA : E6                         mov     A, @R0
(1)     1FB : FB                         mov     R3, A           ; R3=lo(v2)
(1)     1FC : 08                         inc     R0              ; R0=&v2+1
(1)     1FD : E6                         mov     A, @R0          ; A=hi(v2)
(1)     1FE : CA                         xch     A, R2           ; R2=hi(v2), A=&v1
(1)     1FF : C8                         xch     A, R0           ; R0=&v1, A=&v2+1
(1)     200 : CB                         xch     A, R3           ; R3=&v2+1, A=lo(v2)
(1)     201 : 1B                         dec     R3              ; R3=&v2
(1)     202 : F6                         mov     @R0, A          ; lo(v1)=lo(v2)
(1)     203 : EA                         mov     A, R2           ; A=hi(v2)
(1)     204 : 08                         inc     R0              ; R0=&v1+1
(1)     205 : F6                         mov     @R0, A          ; hi(v1)=hi(v2)
(1)     206 : 18                         dec     R0              ; R0=&v1
(1)     207 : E8                         mov     A, R0
(1)     208 : FA                         mov     R2, A           ; R2=&v1
(1)     209 : 22                         ret
(1)     20A :
(1)     20A :                    ;;; Print 8-bit variable
(1)     20A :                    ;;; @param A: variable name
(1)     20A :                    ;;; @param R2: &variable
(1)     20A :                    ;;; @clobber A R0
(1)     20A :                    print8:
(1)     20A : C0 E0                      push    ACC
(1)     20C : EA                         mov     A, R2
(1)     20D : F8                         mov     R0, A
(1)     20E : E6                         mov     A, @R0
(1)     20F : 11 A5                      acall   sex_A
(1)     211 : 7B 3C                      mov     R3, #tmp
(1)     213 : 31 F0                      acall   set
(1)     215 : 7A 3C                      mov     R2, #tmp
(1)     217 : D0 E0                      pop     ACC
(1)     219 :
(1)     219 :                    ;;; Print variable
(1)     219 :                    ;;; @param A: variable name
(1)     219 :                    ;;; @param R2: &variable
(1)     219 :                    ;;; @clobber A R0
(1)     219 :                    print:
(1)     219 : 11 85                      acall   putchar
(1)     21B : 74 3D                      mov     A, #'='
(1)     21D : 11 85                      acall   putchar
(1)     21F : EA                         mov     A, R2
(1)     220 : F8                         mov     R0, A
(1)     221 : 51 25                      acall   print_int16
(1)     223 : 01 7B                      ajmp    putspace
        225 :                            include "arith.inc"
(1)     225 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     225 :                            cpu     8051
(1)     225 :
(1)     225 :                    ;;; Print signed 16-bit integer as decimal
(1)     225 :                    ;;; @param R0 &value
(1)     225 :                    ;;; @clobber A
(1)     225 :                    print_int16:
(1)     225 : E8                         mov     A, R0
(1)     226 : C0 E0                      push    ACC             ; save R0
(1)     228 : E6                         mov     A, @R0
(1)     229 : CA                         xch     A, R2
(1)     22A : C0 E0                      push    ACC             ; save R2
(1)     22C : 08                         inc     R0
(1)     22D : E6                         mov     A, @R0
(1)     22E : CB                         xch     A, R3
(1)     22F : C0 E0                      push    ACC             ; save R3
(1)     231 : EB                         mov     A, R3
(1)     232 : 30 E7 06                   jnb     ACC.7, print_uint16
(1)     235 : 74 2D                      mov     A, #'-'
(1)     237 : 11 85                      acall   putchar         ; print '-'
(1)     239 : 51 62                      acall   neg_R3R2        ; negate value
(1)     23B :                    ;;; Print unsigned 16-bit integer as decimal
(1)     23B :                    ;;; @param R2:R3: value
(1)     23B :                    ;;; @param print_uint16_buf external data memory
(1)     23B :                    ;;; @clobber A
(1)     23B :                    print_uint16:
(1)     23B : 90 21 00                   mov     DPTR, #print_uint16_buf
(1)     23E : E4                         clr     A
(1)     23F : F0                         movx    @DPTR, A        ; mark EOS
(1)     240 :                    print_uint16_loop:
(1)     240 : 7C 0A                      mov     R4, #LOW(10)
(1)     242 : 7D 00                      mov     R5, #HIGH(10)
(1)     244 : 71 26                      acall   udiv16
(1)     246 : EC                         mov     A, R4           ; lo(reminder)
(1)     247 : 24 30                      add     A, #'0'
(1)     249 : A3                         inc     DPTR
(1)     24A : F0                         movx    @DPTR, A        ; write to buffer
(1)     24B : EA                         mov     A, R2
(1)     24C : 4B                         orl     A, R3
(1)     24D : 70 F1                      jnz     print_uint16_loop ; until value == 0
(1)     24F :                    print_uint16_out:
(1)     24F : E0                         movx    A, @DPTR
(1)     250 : 60 06                      jz      print_uint16_end
(1)     252 : 11 85                      acall   putchar
(1)     254 : 15 82                      dec     DPL
(1)     256 : 80 F7                      sjmp    print_uint16_out
(1)     258 :                    print_uint16_end:
(1)     258 : D0 E0                      pop     ACC
(1)     25A : FB                         mov     R3, A           ; restore R3
(1)     25B : D0 06                      pop     AC
(1)     25D : FA                         mov     R2, A           ; restore R2
(1)     25E : D0 E0                      pop     ACC
(1)     260 : F8                         mov     R0, A           ; restore R0
(1)     261 : 22                         ret
(1)     262 :
(1)     262 :                    ;;; Negation; result = -result
(1)     262 :                    ;;; @param R3:R2 result
(1)     262 :                    ;;; @clobber A
(1)     262 :                    neg_R3R2:
(1)     262 : EA                         mov     A, R2
(1)     263 : F4                         cpl     A
(1)     264 : 24 01                      add     A, #1
(1)     266 : FA                         mov     R2, A
(1)     267 : EB                         mov     A, R3
(1)     268 : F4                         cpl     A
(1)     269 : 34 00                      addc    A, #0
(1)     26B : FB                         mov     R3, A
(1)     26C : 22                         ret
(1)     26D :
(1)     26D :                    ;;; Negation; result = -result
(1)     26D :                    ;;; @param R5:R4 result
(1)     26D :                    ;;; @clobber A
(1)     26D :                    neg_R5R4:
(1)     26D : EC                         mov     A, R4
(1)     26E : F4                         cpl     A
(1)     26F : 24 01                      add     A, #1
(1)     271 : FC                         mov     R4, A
(1)     272 : ED                         mov     A, R5
(1)     273 : F4                         cpl     A
(1)     274 : 34 00                      addc    A, #0
(1)     276 : FD                         mov     R5, A
(1)     277 : 22                         ret
(1)     278 :
(1)     278 :                    ;;; Negation; result = -value
(1)     278 :                    ;;; @param R2: &result
(1)     278 :                    ;;; @param R3: &value
(1)     278 :                    ;;; @clobber A R0 R2 R3
(1)     278 :                    negsi2:
(1)     278 : EB                         mov     A, R3
(1)     279 : F8                         mov     R0, A           ; R0=&value
(1)     27A : E6                         mov     A, @R0          ; A=lo(value)
(1)     27B : F4                         cpl     A
(1)     27C : 24 01                      add     A, #1
(1)     27E : FB                         mov     R3, A           ; R3=lo(-value)
(1)     27F : 08                         inc     R0
(1)     280 : E6                         mov     A, @R0          ; A=hi(value)
(1)     281 : F4                         cpl     A
(1)     282 : 34 00                      addc    A, #0           ; A=hi(-value)
(1)     284 : CA                         xch     A, R2           ; R2=hi(-value)
(1)     285 : F8                         mov     R0, A           ; R0=&result
(1)     286 : EB                         mov     A, R3
(1)     287 : F6                         mov     @R0, A          ; store lo(-value)
(1)     288 : 08                         inc     R0
(1)     289 : EA                         mov     A, R2
(1)     28A : F6                         mov     @R0, A          ; store hi(-value)
(1)     28B : 22                         ret
(1)     28C :
(1)     28C :                    ;;; Signed addition: summand += addend
(1)     28C :                    ;;; @param R2: &summand
(1)     28C :                    ;;; @param R3: &addend
(1)     28C :                    ;;; @clobber A R2 R3
(1)     28C :                    addsi2:
(1)     28C : EB                         mov     A, R3
(1)     28D : F8                         mov     R0, A           ; R0=&addend
(1)     28E : E6                         mov     A, @R0          ; A=lo(addend)
(1)     28F : FB                         mov     R3, A           ; R3=lo(addend)
(1)     290 : 08                         inc     R0
(1)     291 : E6                         mov     A, @R0          ; A=hi(addend)
(1)     292 : CA                         xch     A, R2           ; R2=hi(addend)
(1)     293 : F8                         mov     R0, A           ; R0=&summand
(1)     294 : E6                         mov     A, @R0          ; A=lo(summand)
(1)     295 : 2B                         add     A, R3           ; A=lo(summand+addend)
(1)     296 : F6                         mov     @R0, A
(1)     297 : 08                         inc     R0
(1)     298 : E6                         mov     A, @R0          ; A=hi(summand)
(1)     299 : 3A                         addc    A, R2           ; A=hi(summand+addend)
(1)     29A : F6                         mov     @R0, A
(1)     29B : 22                         ret
(1)     29C :
(1)     29C :                    ;;; Singed subtraction: minuend -= subtrahend
(1)     29C :                    ;;; @param R2: &minuend
(1)     29C :                    ;;; @param R3: &subtrahend
(1)     29C :                    ;;; @clobber A R0 R2 R3
(1)     29C :                    subsi2:
(1)     29C : EB                         mov     A, R3
(1)     29D : F8                         mov     R0, A           ; R0=&subtrahend
(1)     29E : E6                         mov     A, @R0          ; A=lo(subtrahend)
(1)     29F : FB                         mov     R3, A           ; R3=lo(subtrahend)
(1)     2A0 : 08                         inc     R0
(1)     2A1 : E6                         mov     A, @R0          ; A=hi(subtrahend)
(1)     2A2 : CA                         xch     A, R2           ; R2=hi(subtrahend)
(1)     2A3 : F8                         mov     R0, A           ; R0=&minuend
(1)     2A4 : E6                         mov     A, @R0          ; A=lo(minuend)
(1)     2A5 : C3                         clr     C
(1)     2A6 : 9B                         subb    A, R3           ; A=lo(minuend-subtrahend)
(1)     2A7 : F6                         mov     @R0, A
(1)     2A8 : 08                         inc     R0
(1)     2A9 : E6                         mov     A, @R0          ; A=hi(minuend)
(1)     2AA : 9A                         subb    A, R2           ; A=hi(minuend-subtrahend)
(1)     2AB : F6                         mov     @R0, A
(1)     2AC : 22                         ret
(1)     2AD :
(1)     2AD :                    ;;; Signed comparison: minuend - subtrahend
(1)     2AD :                    ;;; @param R2: &minuend
(1)     2AD :                    ;;; @param R3: &subtrahend
(1)     2AD :                    ;;; @return A  0: minuend == subtrahend
(1)     2AD :                    ;;;         A  1: minuend >  subtrahend
(1)     2AD :                    ;;;         A -1: minuend <  subtrahend
(1)     2AD :                    ;;; @clobber A R0 R2 R3
(1)     2AD :                    cmpsi2:
(1)     2AD : EB                         mov     A, R3
(1)     2AE : F8                         mov     R0, A           ; R0=&subtrahend
(1)     2AF : E6                         mov     A, @R0          ; A=lo(subtrahend)
(1)     2B0 : FB                         mov     R3, A           ; R3=lo(subtrahend)
(1)     2B1 : 08                         inc     R0
(1)     2B2 : E6                         mov     A, @R0          ; A=hi(subtrahend)
(1)     2B3 : C0 E0                      push    ACC             ; save hi(subtrahend)
(1)     2B5 : CA                         xch     A, R2           ; R2=hi(subtrahend)
(1)     2B6 : F8                         mov     R0, A           ; R0=&minuend
(1)     2B7 : E6                         mov     A, @R0          ; A=lo(minuend)
(1)     2B8 : C3                         clr     C
(1)     2B9 : 9B                         subb    A, R3
(1)     2BA : FB                         mov     R3, A           ; A=lo(minuend-subtrahend)
(1)     2BB : 08                         inc     R0
(1)     2BC : E6                         mov     A, @R0          ; A=hi(minuend)
(1)     2BD : 9A                         subb    A, R2
(1)     2BE : FA                         mov     R2, A           ; R2=hi(minuend-subtrahend)
(1)     2BF : 4B                         orl     A, R3
(1)     2C0 : 60 15                      jz      cmpsi2_eq       ; branch if minuend-subtrahend==0
(1)     2C2 : D0 E0                      pop     ACC             ; restore hi(subtrahend)
(1)     2C4 : 66                         xrl     A, @R0          ; A=hi(minuend^subtrahend)
(1)     2C5 : C0 E0                      push    ACC             ; save hi(minuend^subtrahend)
(1)     2C7 : EA                         mov     A, R2
(1)     2C8 : 66                         xrl     A, @R0
(1)     2C9 : FB                         mov     R3, A           ; R3=hi(minuend-subtrahend)^minuend
(1)     2CA : D0 E0                      pop     ACC             ; restore hi(minuend^subtrahend)
(1)     2CC : 5B                         anl     A, R3           ; overflow flag
(1)     2CD : 6A                         xrl     A, R2
(1)     2CE : 20 E7 03                   jb      ACC.7, cmpsi2_lt
(1)     2D1 :                    cmpsi2_gt:
(1)     2D1 : 74 01                      mov     A, #1
(1)     2D3 : 22                         ret
(1)     2D4 :                    cmpsi2_lt:
(1)     2D4 : 74 FF                      mov     A, #-1
(1)     2D6 : 22                         ret
(1)     2D7 :                    cmpsi2_eq:
(1)     2D7 : 15 81                      dec     SP              ; discard hi(subtrahend)
(1)     2D9 : 22                         ret
(1)     2DA :
(1)     2DA :                    ;;; Unsigned multiplication: result = multiplicand * multiplier
(1)     2DA :                    ;;; @param R3:R2 multiplicand
(1)     2DA :                    ;;; @param R5:R4 multiplier
(1)     2DA :                    ;;; @return R3:R2 result
(1)     2DA :                    ;;; @clobber A R2 R3 R6 R7
(1)     2DA :                    umul16:
(1)     2DA : EA                         mov     A, R2           ; A=lo(multiplicand)
(1)     2DB : 8C F0                      mov     B, R4           ; B=lo(multiplier)
(1)     2DD : A4                         mul     AB              ; B:A
(1)     2DE : FE                         mov     R6, A
(1)     2DF : AF F0                      mov     R7, B           ; R7:R6=result
(1)     2E1 : EA                         mov     A, R2           ; A=lo(multiplicand)
(1)     2E2 : 8D F0                      mov     B, R5           ; B=hi(multiplier)
(1)     2E4 : A4                         mul     AB
(1)     2E5 : 2F                         add     A, R7
(1)     2E6 : FF                         mov     R7, A           ; result+=lo(BA)
(1)     2E7 : EB                         mov     A, R3           ; A=hi(multiplicand)
(1)     2E8 : 8C F0                      mov     B, R4           ; B=lo(multiplier)
(1)     2EA : A4                         mul     AB
(1)     2EB : 2F                         add     A, R7
(1)     2EC : FB                         mov     R3, A
(1)     2ED : EE                         mov     A, R6
(1)     2EE : FA                         mov     R2, A
(1)     2EF : 22                         ret
(1)     2F0 :
(1)     2F0 :                    ;;; Signed multiplication: multiplicand *= multiplier
(1)     2F0 :                    ;;; @param R2: &multiplicand
(1)     2F0 :                    ;;; @param R3: &multiplier
(1)     2F0 :                    ;;; @clobber A R0 R2 R3 R4 R5 R6 R7
(1)     2F0 :                    mulsi2:
(1)     2F0 : EA                         mov     A, R2
(1)     2F1 : C0 E0                      push    ACC             ; save &multiplicand
(1)     2F3 : EB                         mov     A, R3
(1)     2F4 : C0 E0                      push    ACC             ; save &multiplier
(1)     2F6 : F8                         mov     R0, A           ; R0=&multiplier
(1)     2F7 : E6                         mov     A, @R0
(1)     2F8 : FC                         mov     R4, A
(1)     2F9 : 08                         inc     R0
(1)     2FA : E6                         mov     A, @R0
(1)     2FB : FD                         mov     R5, A           ; R5:R4=multiplier
(1)     2FC : 30 E7 02                   jnb     ACC.7, mulsi2_multiplicand
(1)     2FF : 51 6D                      acall   neg_R5R4
(1)     301 :                    mulsi2_multiplicand:
(1)     301 : EA                         mov     A, R2
(1)     302 : F8                         mov     R0, A           ; R0=&multiplicand
(1)     303 : E6                         mov     A, @R0
(1)     304 : FA                         mov     R2, A
(1)     305 : 08                         inc     R0
(1)     306 : E6                         mov     A, @R0
(1)     307 : FB                         mov     R3, A
(1)     308 : 30 E7 02                   jnb     ACC.7, mulsi2_multiply
(1)     30B : 51 62                      acall   neg_R3R2
(1)     30D :                    mulsi2_multiply:
(1)     30D : 51 DA                      acall   umul16
(1)     30F : D0 E0                      pop     ACC
(1)     311 : F8                         mov     R0, A           ; R0=&multiplier
(1)     312 : 08                         inc     R0
(1)     313 : E6                         mov     A, @R0          ; A=hi(multiplier)
(1)     314 : FD                         mov     R5, A           ; R5=hi(multiplier)
(1)     315 : D0 E0                      pop     ACC
(1)     317 : F8                         mov     R0, A           ; R0=&multiplicand
(1)     318 : 08                         inc     R0
(1)     319 : E6                         mov     A, @R0          ; A=hi(multiplicand)
(1)     31A : 6D                         xrl     A, R5           ; A=hi(multiplicand^multiplier)
(1)     31B : 30 E7 02                   jnb     ACC.7, mulsi2_store
(1)     31E : 51 62                      acall   neg_R3R2
(1)     320 :                    mulsi2_store:
(1)     320 : EB                         mov     A, R3
(1)     321 : F6                         mov     @R0, A
(1)     322 : 18                         dec     R0
(1)     323 : EA                         mov     A, R2
(1)     324 : F6                         mov     @R0, A
(1)     325 : 22                         ret
(1)     326 :
(1)     326 :                    ;;; Unsigned division: dividend / divisor = quotient ... reminder
(1)     326 :                    ;;; @praram R3:R2 dividend
(1)     326 :                    ;;; @praram R5:R4 divisor
(1)     326 :                    ;;; @return R3:R2 quotient
(1)     326 :                    ;;; @return R5:R4 reminder
(1)     326 :                    ;;; @clobber A R0 R1 R2 R3 R4 R5 R6 R7
(1)     326 :                    udiv16:
(1)     326 : ED                         mov     A, R5
(1)     327 : 70 0E                      jnz     udiv16_calc     ; branch if divisor >= 256
(1)     329 : 4C                         orl     A, R4
(1)     32A : 60 0A                      jz      udiv16_div0     ; B=divisor (<256)
(1)     32C : F5 F0                      mov     B, A
(1)     32E : EB                         mov     A, R3
(1)     32F : 70 06                      jnz     udiv16_calc     ; branch if dividend >= 256
(1)     331 : EA                         mov     A, R2           ; A=dividend (<256)
(1)     332 : 84                         div     AB              ; A=quotient B=reminder
(1)     333 : FA                         mov     R2, A
(1)     334 : AC F0                      mov     R4, B
(1)     336 :                    udiv16_div0:
(1)     336 : 22                         ret
(1)     337 :                    udiv16_calc:
(1)     337 : 79 01                      mov     R1, #1          ; R1=bits
(1)     339 : 80 08                      sjmp    udiv16_prep
(1)     33B :                    udiv16_prep_loop:
(1)     33B : C3                         clr     C
(1)     33C : EC                         mov     A, R4
(1)     33D : 33                         rlc     A
(1)     33E : FC                         mov     R4, A
(1)     33F : ED                         mov     A, R5
(1)     340 : 33                         rlc     A
(1)     341 : FD                         mov     R5, A           ; divisor <<= 1
(1)     342 : 09                         inc     R1              ; bits++
(1)     343 :                    udiv16_prep:
(1)     343 : ED                         mov     A, R5
(1)     344 : 30 E7 F4                   jnb     ACC.7, udiv16_prep_loop ; while msb(divisor) == 0
(1)     347 : E4                         clr     A
(1)     348 : FE                         mov     R6, A
(1)     349 : FF                         mov     R7, A           ; R7:R6=quotient
(1)     34A : 80 0E                      sjmp    udiv16_enter_loop
(1)     34C :                    udiv16_loop:
(1)     34C : C3                         clr     C
(1)     34D : ED                         mov     A, R5
(1)     34E : 13                         rrc     A
(1)     34F : FD                         mov     R5, A
(1)     350 : EC                         mov     A, R4
(1)     351 : 13                         rrc     A
(1)     352 : FC                         mov     R4, A           ; divisor >>= 1
(1)     353 : C3                         clr     C
(1)     354 : EE                         mov     A, R6
(1)     355 : 33                         rlc     A
(1)     356 : FE                         mov     R6, A
(1)     357 : EF                         mov     A, R7
(1)     358 : 33                         rlc     A
(1)     359 : FF                         mov     R7, A           ; quotient <<= 1
(1)     35A :                    udiv16_enter_loop:
(1)     35A : EA                         mov     A, R2
(1)     35B : C3                         clr     C
(1)     35C : 9C                         subb    A, R4
(1)     35D : FA                         mov     R2, A
(1)     35E : EB                         mov     A, R3
(1)     35F : 9D                         subb    A, R5
(1)     360 : FB                         mov     R3, A           ; divident -= divisor
(1)     361 : 40 03                      jc      udiv16_readd    ; branch if dividend < 0
(1)     363 : 0E                         inc     R6              ; quotient |= 1
(1)     364 : 80 06                      sjmp    udiv16_next
(1)     366 :                    udiv16_readd:
(1)     366 : EA                         mov     A, R2
(1)     367 : 2C                         add     A, R4
(1)     368 : FA                         mov     R2, A
(1)     369 : EB                         mov     A, R3
(1)     36A : 3D                         addc    A, R5
(1)     36B : FB                         mov     R3, A           ; dividend += divisor
(1)     36C :                    udiv16_next:
(1)     36C : D9 DE                      djnz    R1, udiv16_loop
(1)     36E : EA                         mov     A, R2
(1)     36F : FC                         mov     R4, A
(1)     370 : EB                         mov     A, R3
(1)     371 : FD                         mov     R5, A           ; store reminder
(1)     372 : EE                         mov     A, R6
(1)     373 : FA                         mov     R2, A
(1)     374 : EF                         mov     A, R7
(1)     375 : FB                         mov     R3, A           ; store quotient
(1)     376 : 22                         ret
(1)     377 :
(1)     377 :
(1)     377 :                    ;;; Signed division: dividend /= divisor
(1)     377 :                    ;;; @param R2: &dividend
(1)     377 :                    ;;; @param R3: &divisor
(1)     377 :                    ;;; @clobber A R0 R2 R3 R4 R5 R6 R7
(1)     377 :                    divsi2:
(1)     377 : EA                         mov     A, R2
(1)     378 : C0 E0                      push    ACC             ; save &dividend
(1)     37A : EB                         mov     A, R3
(1)     37B : C0 E0                      push    ACC             ; save &divisor
(1)     37D : F8                         mov     R0, A           ; R0=&divisor
(1)     37E : E6                         mov     A, @R0
(1)     37F : FC                         mov     R4, A
(1)     380 : 08                         inc     R0
(1)     381 : E6                         mov     A, @R0
(1)     382 : FD                         mov     R5, A           ; R5:R4=divisor
(1)     383 : 30 E7 02                   jnb     ACC.7, divsi2_dividend
(1)     386 : 51 6D                      acall   neg_R5R4
(1)     388 :                    divsi2_dividend:
(1)     388 : EA                         mov     A, R2
(1)     389 : F8                         mov     R0, A           ; R0=&dividend
(1)     38A : E6                         mov     A, @R0
(1)     38B : FA                         mov     R2, A
(1)     38C : 08                         inc     R0
(1)     38D : E6                         mov     A, @R0
(1)     38E : FB                         mov     R3, A
(1)     38F : 30 E7 02                   jnb     ACC.7, divsi2_divide
(1)     392 : 51 62                      acall   neg_R3R2
(1)     394 :                    divsi2_divide:
(1)     394 : 71 26                      acall   udiv16
(1)     396 : D0 E0                      pop     ACC
(1)     398 : F8                         mov     R0, A           ; R0=&divisor
(1)     399 : 08                         inc     R0
(1)     39A : E6                         mov     A, @R0          ; A=hi(divisor)
(1)     39B : FD                         mov     R5, A           ; R5=hi(divisor)
(1)     39C : D0 E0                      pop     ACC
(1)     39E : F8                         mov     R0, A           ; R0=&dividend
(1)     39F : 08                         inc     R0
(1)     3A0 : E6                         mov     A, @R0          ; A=hi(dividend)
(1)     3A1 : 6D                         xrl     A, R5           ; A=hi(dividend^divisor)
(1)     3A2 : 30 E7 02                   jnb     ACC.7, divsi2_store
(1)     3A5 : 51 62                      acall   neg_R3R2
(1)     3A7 :                    divsi2_store:
(1)     3A7 : EB                         mov     A, R3
(1)     3A8 : F6                         mov     @R0, A
(1)     3A9 : 18                         dec     R0
(1)     3AA : EA                         mov     A, R2
(1)     3AB : F6                         mov     @R0, A
(1)     3AC : 22                         ret
        3AD :                            include "queue.inc"
(1)     3AD :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     3AD :                    ;;; [queue] queue structure on internal data memory
(1)     3AD : =0                 queue_len:      equ     0       ; queue length
(1)     3AD : =1                 queue_size:     equ     1       ; buffer size
(1)     3AD : =2                 queue_put:      equ     2       ; queue put index
(1)     3AD : =3                 queue_get:      equ     3       ; queue get index
(1)     3AD : =4                 queue_buf_lo:   equ     4       ; lo(queue buffer) pointer to  external data memory
(1)     3AD : =5                 queue_buf_hi:   equ     5       ; hi(queue_buffer)
(1)     3AD : =6                 queue_work_size: equ    6       ; queue work size
(1)     3AD :
(1)     3AD :                    ;;; [queue] Initialize queue
(1)     3AD :                    ;;; @param R0 queue work space pointer
(1)     3AD :                    ;;; @param R1 queue buffer size
(1)     3AD :                    ;;; @param DPTR queue buffer pointer
(1)     3AD :                    ;;; @clobber DPTR R0 R1 A
(1)     3AD :                    queue_init:
(1)     3AD : E4                         clr     A
(1)     3AE : F6                         mov     @R0, A          ; clear queue_len
(1)     3AF : E9                         mov     A, R1
(1)     3B0 : 08                         inc     R0
(1)     3B1 : F6                         mov     @R0, A          ; save queue_size
(1)     3B2 : E4                         clr     A
(1)     3B3 : 08                         inc     R0
(1)     3B4 : F6                         mov     @R0, A          ; clear queue_put
(1)     3B5 : 08                         inc     R0
(1)     3B6 : F6                         mov     @R0, A          ; clear queue_get
(1)     3B7 : 08                         inc     R0
(1)     3B8 : A6 82                      mov     @R0, DPL        ; lo(queue_buf)
(1)     3BA : 08                         inc     R0
(1)     3BB : A6 83                      mov     @R0, DPH        ; hi(queue_buf)
(1)     3BD :                    queue_init_loop:
(1)     3BD : F0                         movx    @DPTR, A
(1)     3BE : A3                         inc     DPTR
(1)     3BF : D9 FC                      djnz    R1, queue_init_loop
(1)     3C1 : 22                         ret
(1)     3C2 :
(1)     3C2 :                    ;;; [queue] Add an element to queue
(1)     3C2 :                    ;;; @param R0 queue work space pointer
(1)     3C2 :                    ;;; @param A an element
(1)     3C2 :                    ;;; @return PSW.C 0 if queue is full
(1)     3C2 :                    ;;; @clobber DPTR R0 A
(1)     3C2 :                    queue_add:
(1)     3C2 : C0 E0                      push    ACC             ; save an element
(1)     3C4 : E6                         mov     A, @R0          ; A=queue_len
(1)     3C5 : 08                         inc     R0              ; R0=&queue_size
(1)     3C6 : 66                         xrl     A, @R0          ; queue_size
(1)     3C7 : 70 04                      jnz     queue_add_store ; branch if queue is not full
(1)     3C9 : D0 E0                      pop     ACC
(1)     3CB : C3                         clr     C               ; PSW.C=0
(1)     3CC : 22                         ret
(1)     3CD :                    queue_add_store:
(1)     3CD : 18                         dec     R0              ; R0=&queue_len
(1)     3CE : 06                         inc     @R0             ; queue_len+=1
(1)     3CF : 08                         inc     R0
(1)     3D0 : 08                         inc     R0
(1)     3D1 : E6                         mov     A, @R0          ; A=queue_put
(1)     3D2 : 08                         inc     R0
(1)     3D3 : 08                         inc     R0
(1)     3D4 : 26                         add     A, @R0          ; A=lo(queue_buf)+queue_put
(1)     3D5 : F5 82                      mov     DPL, A
(1)     3D7 : 08                         inc     R0
(1)     3D8 : E6                         mov     A, @R0          ; A=hi(queue_buf)
(1)     3D9 : 34 00                      addc    A, #0
(1)     3DB : F5 83                      mov     DPH, A
(1)     3DD : D0 E0                      pop     ACC             ; restore an element
(1)     3DF : F0                         movx    @DPTR, A        ; add an element
(1)     3E0 : 18                         dec     R0
(1)     3E1 : 18                         dec     R0
(1)     3E2 : 18                         dec     R0
(1)     3E3 : 06                         inc     @R0             ; queue_put+=1
(1)     3E4 : E6                         mov     A, @R0          ; A=queue_put
(1)     3E5 : 18                         dec     R0
(1)     3E6 : 66                         xrl     A, @R0          ; queue_size
(1)     3E7 : 70 02                      jnz     queue_add_end   ; branch if queue_put != queue_size
(1)     3E9 : 08                         inc     R0
(1)     3EA : F6                         mov     @R0, A          ; queue_put=0
(1)     3EB :                    queue_add_end:
(1)     3EB : D3                         setb    C
(1)     3EC : 22                         ret
(1)     3ED :
(1)     3ED :                    ;;; [queue] Remove an element from queue
(1)     3ED :                    ;;; @param R0 queue work space pointer
(1)     3ED :                    ;;; @return A an element
(1)     3ED :                    ;;; @return PSW.C 0 if queue is empty
(1)     3ED :                    ;;; @clobber DPTR R0 A
(1)     3ED :                    queue_remove:
(1)     3ED : E6                         mov     A, @R0            ; queue_len
(1)     3EE : 70 02                      jnz     queue_remove_elem ; queue_len > 0
(1)     3F0 : C3                         clr     C                 ; PSW.C=0
(1)     3F1 : 22                         ret
(1)     3F2 :                    queue_remove_elem:
(1)     3F2 : 16                         dec     @R0             ; queue_len-=1
(1)     3F3 : 08                         inc     R0
(1)     3F4 : 08                         inc     R0
(1)     3F5 : 08                         inc     R0
(1)     3F6 : E6                         mov     A, @R0          ; A=queue_get
(1)     3F7 : 08                         inc     R0
(1)     3F8 : 26                         add     A, @R0          ; A=lo(queue_buf)+queue_get
(1)     3F9 : F5 82                      mov     DPL, A
(1)     3FB : 08                         inc     R0
(1)     3FC : E6                         mov     A, @R0          ; A=hi(queue)
(1)     3FD : 34 00                      addc    A, #0
(1)     3FF : F5 83                      mov     DPH, A
(1)     401 : E0                         movx    A, @DPTR        ; read an element
(1)     402 : C0 E0                      push    ACC             ; save an element
(1)     404 : 18                         dec     R0
(1)     405 : 18                         dec     R0
(1)     406 : 06                         inc     @R0             ; queue_get+=1
(1)     407 : E6                         mov     A, @R0          ; A=queue_get
(1)     408 : 18                         dec     R0
(1)     409 : 18                         dec     R0
(1)     40A : 66                         xrl     A, @R0          ; queue_size
(1)     40B : 70 03                      jnz     queue_remove_end ; branch if queue_get != queue_size
(1)     40D : 08                         inc     R0
(1)     40E : 08                         inc     R0
(1)     40F : F6                         mov     @R0, A          ; queue_get=0
(1)     410 :                    queue_remove_end:
(1)     410 : D0 E0                      pop     ACC             ; restore an element
(1)     412 : D3                         setb    C
(1)     413 : 22                         ret
        414 :
        414 :                    isr_intr_rx:
        414 : C0 D0                      push    PSW
        416 : C2 D4                      clr     PSW.RS1
        418 : D2 D3                      setb    PSW.RS0         ; select BANK 1
        41A : A9 82                      mov     R1, DPL
        41C : AA 83                      mov     R2, DPH         ; save DPTR
        41E : FB                         mov     R3, A           ; save A
        41F : 90 FF F1                   mov     DPTR, #USARTS
        422 : E0                         movx    A, @DPTR
        423 : 30 E1 07                   jnb     ACC.ST_RxRDY_bp, isr_intr_exit
        426 : 15 82                      dec     DPL
        428 : E0                         movx    A, @DPTR
        429 : 78 30                      mov     R0, #rx_queue
        42B : 71 C2                      acall   queue_add
        42D :                    isr_intr_exit:
        42D : EB                         mov     A, R3           ; restore A
        42E : 8A 83                      mov     DPH, R2
        430 : 89 82                      mov     DPL, R1         ; restore DPTR
        432 : D0 D0                      pop     PSW
        434 : 32                         reti
        435 :
        435 :                    isr_intr_tx:
        435 : C0 D0                      push    PSW
        437 : C2 D4                      clr     PSW.RS1
        439 : D2 D3                      setb    PSW.RS0         ; select BANK 1
        43B : A9 82                      mov     R1, DPL
        43D : AA 83                      mov     R2, DPH         ; save DPTR
        43F : FB                         mov     R3, A           ; save A
        440 : 90 FF F1                   mov     DPTR, #USARTS
        443 : E0                         movx    A, @DPTR
        444 : 30 E0 E6                   jnb     ACC.ST_TxRDY_bp, isr_intr_exit
        447 : 78 36                      mov     R0, #tx_queue
        449 : 71 ED                      acall   queue_remove
        44B : 50 06                      jnc     isr_intr_tx_empty
        44D : 90 FF F0                   mov     DPTR, #USARTD
        450 : F0                         movx    @DPTR, A        ; send character
        451 : 80 DA                      sjmp    isr_intr_exit
        453 :                    isr_intr_tx_empty:
        453 : 90 FF F1                   mov     DPTR, #USARTC
        456 : 74 36                      mov     A, #RX_EN_TX_DIS
        458 : F0                         movx    @DPTR, A        ; disable Tx
        459 : 80 D2                      sjmp    isr_intr_exit
        45B :
        45B :                            end
