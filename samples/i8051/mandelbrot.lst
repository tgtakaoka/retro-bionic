          0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
          0 :                            cpu     8051
          0 :                            include "i8051.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                    ;;; i8051
(1)       0 :                    ;;; Interrupt origin
(1)       0 : =0                 ORG_RESET:      equ     000H    ; RESET
(1)       0 : =3                 ORG_IE0:        equ     003H    ; #INT0
(1)       0 : =B                 ORG_TF0:        equ     00BH    ; Timer 0 overflow
(1)       0 : =13                ORG_IE1:        equ     013H    ; #INT1
(1)       0 : =1B                ORG_TF1:        equ     01BH    ; Timer 1 overflow
(1)       0 : =23                ORG_RITI:       equ     023H    ; Receive & Transmit
(1)       0 :                    ;;; Register bank and internal memory
(1)       0 : =0                 BASE_BANK0:     equ     00H     ; Bank 0 R0-R7
(1)       0 : =8                 BASE_BANK1:     equ     08H     ; Bank 1 R0-R7
(1)       0 : =10                BASE_BANK2:     equ     10H     ; Bank 2 R0-R7
(1)       0 : =18                BASE_BANK3:     equ     18H     ; Bank 3 R0-R7
(1)       0 : =20                BASE_BIT:       equ     20H     ; Bit addressable memory
(1)       0 : =30                BASE_MEMORY:    equ     30H     ; general purpose memory
(1)       0 :                    ;;; Special function registers
(1)       0 : =E0                ACC:    equ     0E0H            ; Accumulator
(1)       0 : =F0                B:      equ     0F0H            ; B register
(1)       0 : =D0                PSW:    equ     0D0H            ; Program status word
(1)       0 : =81                SP:     equ     81H             ; Stack pointer
(1)       0 : =82                DPL:    equ     82H             ; DPTR low byte
(1)       0 : =83                DPH:    equ     83H             ; DPTR high byte
(1)       0 : =80                P0:     equ     80H             ; Port 0
(1)       0 : =90                P1:     equ     90H             ; Port 1
(1)       0 : =A0                P2:     equ     0A0H            ; Port 2
(1)       0 : =B0                P3:     equ     0B0H            ; Port 3
(1)       0 : =B8                IP:     equ     0B8H            ; Interrupt priority control
(1)       0 : =A8                IE:     equ     0A8H            ; Interrupt enable control
(1)       0 : =89                TMOD:   equ     89H             ; Timer/Counter mode control
(1)       0 : =88                TCON:   equ     88H             ; Timer/Counter control
(1)       0 : =8C                TH0:    equ     8CH             ; Timer/Counter 0 high byte
(1)       0 : =8A                TL0:    equ     8AH             ; Timer/Counter 0 low byte
(1)       0 : =8D                TH1:    equ     8DH             ; Timer/Counter 1 high byte
(1)       0 : =8B                TL1:    equ     8BH             ; Timer/Counter 1 low byte
(1)       0 : =98                SCON:   equ     98H             ; Serial control
(1)       0 : =99                SBUF:   equ     99H             ; Serial data buffer
(1)       0 : =87                PCON:   equ     87H             ; Power control
(1)       0 :                    ;;; PSW (0D0H) Program status word (bit addressable)
(1)       0 : =7                 CY:     equ     7              ; set to 1 if carry
(1)       0 : =6                 AC:     equ     6              ; set to 1 if auxillary carry
(1)       0 : =5                 F0:     equ     5              ; user flag 0
(1)       0 : =4                 RS1:    equ     4              ; register bank select
(1)       0 : =3                 RS0:    equ     3              ; register bank select
(1)       0 : =2                 OV:     equ     2              ; set to 1 if overflow
(1)       0 : =1                 F1:     equ     1              ; user flag 1
(1)       0 : =0                 P:      equ     0              ; parity bit
(1)       0 :                    ;;; IE (0A8H) Interrupt enable register
(1)       0 : =7                 EA:     equ     7               ; enable interrupt
(1)       0 : =4                 ES:     equ     4               ; Serial
(1)       0 : =3                 ET1:    equ     3               ; Timer 1 overflow
(1)       0 : =2                 EX1:    equ     2               ; #INT1
(1)       0 : =1                 ET0:    equ     1               ; Timer 0 overflow
(1)       0 : =0                 EX0:    equ     0               ; #INT0
(1)       0 :                    ;;; SCON (89H) Serial control (bit addressable)
(1)       0 : =7                 SM0:    equ     7               ; Serial mode SM[0:1:2]=010 8-bit UART
(1)       0 : =6                 SM1:    equ     6
(1)       0 : =5                 SM2:    equ     5
(1)       0 : =4                 REN:    equ     4               ; Enable reception
(1)       0 : =1                 TI:     equ     1               ; Transmit interrupt flag
(1)       0 : =0                 RI:     equ     0               ; Receive interrupt flag
(1)       0 :                    ;;; TCON (88H) Timer/Counter control register
(1)       0 : =7                 TF1:    equ     7               ; Timer 1 overflow flag
(1)       0 : =6                 TR1:    equ     6               ; Timer 1 run control
(1)       0 : =5                 TF0:    equ     5               ; Timer 0 overflow flag
(1)       0 : =4                 TR0:    equ     4               ; Timer 0 run control
(1)       0 :                    ;;; TMOD (89H) Timer/Counter mode control register
(1)       0 : =4                 T1MODE_gp:      equ     4       ; Timer 1 mode
(1)       0 : =0                 T0MODE_gp:      equ     0       ; Timer 0 mode
(1)       0 : =8                 TGATE:          equ     1000B
(1)       0 : =4                 TXPIN:          equ     0100B   ; Input from Tx pin
(1)       0 : =2                 T8MODE:         equ     0010B   ; 8-bit auto-reload timer/counter
(1)       0 :                    ;;; PCON (87H) Power control register
(1)       0 : =40                SMOD:   equ     1000000B        ; Double baudrate
          0 :
          0 :                    ;;; i8251 Universal Synchronous/Asynchronous Receiver/Transmitter
          0 : =FFF0              USART:          equ     0FFF0H
          0 : =FFF0              USARTD:         equ     USART+0 ; Receive/Transmit data
          0 : =FFF1              USARTS:         equ     USART+1 ; Srtatus register
          0 : =FFF1              USARTC:         equ     USART+1 ; Control register
          0 : =FFF2              USARTRV:        equ     USART+2 ; Receive interrupt vector (ORG_*)
          0 : =FFF3              USARTTV:        equ     USART+3 ; Transmit interrupt vector (ORG_*)
          0 :                            include "i8251.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :
(1)       0 :                    ;;; i8251 USART device emulator.
(1)       0 : =6                 MODE_STOP_gp:   equ     6
(1)       0 : =C0                MODE_STOP_gm:   equ     11000000B
(1)       0 : =40                MODE_STOP1_gc:  equ     (1 << MODE_STOP_gp)
(1)       0 : =80                MODE_STOP15_gc: equ     (2 << MODE_STOP_gp)
(1)       0 : =C0                MODE_STOP2_gc:  equ     (3 << MODE_STOP_gp)
(1)       0 : =20                MODE_EVEN_bm:   equ     00100000B
(1)       0 : =10                MODE_PARITY_bm: equ     00010000B
(1)       0 : =2                 MODE_LEN_gp:    equ     2
(1)       0 : =C                 MODE_LEN_gm:    equ     00001100B
(1)       0 : =0                 MODE_LEN5_gc:   equ     (0 << MODE_LEN_gp)
(1)       0 : =4                 MODE_LEN6_gc:   equ     (1 << MODE_LEN_gp)
(1)       0 : =8                 MODE_LEN7_gc:   equ     (2 << MODE_LEN_gp)
(1)       0 : =C                 MODE_LEN8_gc:   equ     (3 << MODE_LEN_gp)
(1)       0 : =0                 MODE_BAUD_gp:   equ     0
(1)       0 : =3                 MODE_BAUD_gm:   equ     00000011B
(1)       0 : =1                 MODE_BAUD_X1:   equ     (1 << MODE_BAUD_gp)
(1)       0 : =2                 MODE_BAUD_X16:  equ (2 << MODE_BAUD_gp)
(1)       0 : =3                 MODE_BAUD_X64:  equ (3 << MODE_BAUD_gp)
(1)       0 :                    ;;; Bit Definition of command register
(1)       0 : =80                CMD_EH_bm:      equ     10000000B   ; Enter hunt mode
(1)       0 : =40                CMD_IR_bm:      equ     01000000B   ; Internal Reset
(1)       0 : =20                CMD_RTS_bm:     equ     00100000B   ; Request To Send
(1)       0 : =10                CMD_ER_bm:      equ     00010000B   ; Error Reset
(1)       0 : =8                 CMD_SBRK_bm:    equ     00001000B   ; Send Break
(1)       0 : =4                 CMD_RxEN_bm:    equ     00000100B   ; Receive Enable
(1)       0 : =2                 CMD_DTR_bm:     equ     00000010B   ; Data Terminal Ready
(1)       0 : =1                 CMD_TxEN_bm:    equ     00000001B   ; Transmit enable
(1)       0 :
(1)       0 :                    ;;; Bit definition of status register
(1)       0 : =80                ST_DSR_bm:      equ     10000000B   ; Data Set Ready
(1)       0 : =40                ST_BRK_bm:      equ     01000000B   ; BREAK detected
(1)       0 : =20                ST_FE_bm:       equ     00100000B   ; Framing Error
(1)       0 : =10                ST_OE_bm:       equ     00010000B   ; Iverrun Error
(1)       0 : =8                 ST_PE_bm:       equ     00001000B   ; Parity Error
(1)       0 : =4                 ST_TxEMPTY_bm:  equ     00000100B   ; Transmitter empty
(1)       0 : =2                 ST_RxRDY_bm:    equ     00000010B   ; Receiver ready
(1)       0 : =1                 ST_TxRDY_bm:    equ     00000001B   ; Transmitter ready
(1)       0 : =1                 ST_RxRDY_bp:    equ     1           ; Receiver ready
(1)       0 : =0                 ST_TxRDY_bp:    equ     0           ; Transmitter ready
          0 :                    ;;; Async 1stop 8data x16
          0 : =4E                ASYNC_MODE:     equ     MODE_STOP1_gc|MODE_LEN8_gc|MODE_BAUD_X16
          0 :                    ;;; RTS/DTR, error reset, Rx enable, Tx enable
          0 : =37                RX_EN_TX_EN:    equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm|CMD_TxEN_bm
          0 : =36                RX_EN_TX_DIS:   equ     CMD_RTS_bm|CMD_DTR_bm|CMD_ER_bm|CMD_RxEN_bm
          0 :
          0 :                    ;;; External data memory
       2000 :                            org     2000H
       2000 : =80                rx_buffer_size: equ     128
       2000 :                    rx_buffer:
       2000 :                            ds      rx_buffer_size
       2080 : =80                tx_buffer_size: equ     128
       2080 :                    tx_buffer:
       2080 :                            ds      tx_buffer_size
       2100 :                    print_uint16_buf:
       2100 :                            ds      8
       2108 :
       2108 :                    ;;; Internal data memory
         30 :                            org     BASE_MEMORY
         30 :                    rx_queue:       ds      queue_work_size
         36 :                    tx_queue:       ds      queue_work_size
         3C :                    ;;; Work area for mandelbrot.inc
         3C :                    tmp:    ds      2
         3E :                    c229:   ds      2
         40 :                    c416:   ds      2
         42 :                    c100:   ds      2
         44 :                    vF:     ds      2
         46 :                    vC:     ds      2
         48 :                    vD:     ds      2
         4A :                    vA:     ds      2
         4C :                    vB:     ds      2
         4E :                    vP:     ds      2
         50 :                    vQ:     ds      2
         52 :                    vS:     ds      2
         54 :                    vT:     ds      2
         56 :                    vY:     ds      1
         57 :                    vX:     ds      1
         58 :                    vI:     ds      1
         59 : =59                stack:          equ     $
         59 :
          0 :                            org     ORG_RESET
          0 : 02 00 26                   ljmp    init
          3 :                            org     ORG_IE0
          3 : 02 04 2F                   ljmp    isr_intr_rx
          B :                            org     ORG_TF0
          B : 02 00 26                   ljmp    init
         13 :                            org     ORG_IE1
         13 : 02 04 50                   ljmp    isr_intr_tx
         1B :                            org     ORG_TF1
         1B : 02 00 26                   ljmp    init
         23 :                            org     ORG_RITI
         23 : 02 00 26                   ljmp    init
         26 :
         26 :                    init:
         26 : 75 81 58                   mov     SP, #stack-1
         29 : 78 30                      mov     R0, #rx_queue
         2B : 79 80                      mov     R1, #rx_buffer_size
         2D : 90 20 00                   mov     DPTR, #rx_buffer
         30 : 71 C8                      acall   queue_init
         32 : 78 36                      mov     R0, #tx_queue
         34 : 79 80                      mov     R1, #tx_buffer_size
         36 : 90 20 80                   mov     DPTR, #tx_buffer
         39 : 71 C8                      acall   queue_init
         3B :                    init_usart:
         3B : 90 FF F1                   mov     DPTR, #USARTC
         3E : E4                         clr     A
         3F : F0                         movx    @DPTR, A
         40 : F0                         movx    @DPTR, A
         41 : F0                         movx    @DPTR, A        ; safest way to sync mode
         42 : 74 40                      mov     a, #CMD_IR_bm
         44 : F0                         movx    @DPTR, A        ; reset
         45 : 00                         nop
         46 : 00                         nop
         47 : 74 4E                      mov     a, #ASYNC_MODE
         49 : F0                         movx    @DPTR, A
         4A : 00                         nop
         4B : 00                         nop
         4C : 74 37                      mov     a, #RX_EN_TX_EN
         4E : F0                         movx    @DPTR, A
         4F : A3                         inc     DPTR
         50 : 74 03                      mov     A, #ORG_IE0
         52 : F0                         movx    @DPTR, A        ; enable Rx interrupt using INT0
         53 : D2 A8                      setb    IE.EX0          ; enable INT0
         55 : 74 13                      mov     A, #ORG_IE1
         57 : A3                         inc     DPTR
         58 : F0                         movx    @DPTR, A        ; enable Tx interrupt using INT1
         59 : D2 AA                      setb    IE.EX1          ; enable INT1
         5B : D2 AF                      setb    IE.EA           ; enable interrupt
         5D :
         5D :                    loop:
         5D : 11 B0                      acall   mandelbrot
         5F : 11 7F                      acall   newline
         61 : 80 FA                      sjmp    loop
         63 :
         63 :                    ;;; Get character
         63 :                    ;;; @return A
         63 :                    ;;; @return PSW.C 0 if no character
         63 :                    getchar:
         63 : C0 83                      push    DPH
         65 : C0 82                      push    DPL
         67 : E8                         mov     A, R0
         68 : C0 E0                      push    ACC             ; save R0
         6A : 78 30                      mov     R0, #rx_queue
         6C : C2 AF                      clr     IE.EA
         6E : 91 08                      acall   queue_remove
         70 : D2 AF                      setb    IE.EA
         72 : C8                         xch     A, R0           ; R0=character
         73 : D0 E0                      pop     ACC
         75 : C8                         xch     A, R0           ; restore R0
         76 : D0 82                      pop     DPL
         78 : D0 83                      pop     DPH
         7A : 22                         ret
         7B :
         7B :                    ;;; Put space
         7B :                    ;;; @clobber A
         7B :                    putspace:
         7B : 74 20                      mov     A, #' '
         7D : 80 06                      sjmp    putchar
         7F :
         7F :                    ;;; Put newline
         7F :                    ;;; @clobber A
         7F :                    newline:
         7F : 74 0D                      mov     A, #0DH
         81 : 11 85                      acall   putchar
         83 : 74 0A                      mov     A, #0AH
         85 :
         85 :                    ;;; Put character
         85 :                    ;;; @param A
         85 :                    ;;; @clobber DPTR A
         85 :                    putchar:
         85 : C0 83                      push    DPH
         87 : C0 82                      push    DPL             ; save DPTR
         89 : C8                         xch     A, R0           ; save character
         8A : C0 E0                      push    ACC             ; save R0
         8C : E8                         mov     A, R0           ; restore character
         8D :                    putchar_loop:
         8D : 78 36                      mov     R0, #tx_queue
         8F : C2 AF                      clr     IE.EA
         91 : 71 DD                      acall   queue_add
         93 : D2 AF                      setb    IE.EA
         95 : 50 F6                      jnc     putchar_loop    ; branch if queue is full
         97 : 90 FF F1                   mov     DPTR, #USARTC
         9A : 74 37                      mov     A, #RX_EN_TX_EN ; enable Tx
         9C : F0                         movx    @DPTR, A
         9D : D0 E0                      pop     ACC
         9F : F8                         mov     R0, A           ; restore R0
         A0 : D0 82                      pop     DPL
         A2 : D0 83                      pop     DPH             ; restore DPTR
         A4 : 22                         ret
         A5 :
         A5 :                            include "mandelbrot.inc"
(1)      A5 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)      A5 :
(1)      A5 :                    ;;; Sign extend 8-bit to 16-bit
(1)      A5 :                    ;;; @param A 8-bit value
(1)      A5 :                    ;;; @return R5:R4 sign extended 16-bit value
(1)      A5 :                    ;;; @clobber A
(1)      A5 :                    sex_A:
(1)      A5 : FC                         mov     R4, A
(1)      A6 : 20 E7 03                   jb      ACC.7, sex_Aminus
(1)      A9 : E4                         clr     A
(1)      AA : 80 02                      sjmp    sex_Aend
(1)      AC :                    sex_Aminus:
(1)      AC : 74 FF                      mov     A, #-1
(1)      AE :                    sex_Aend:
(1)      AE : FD                         mov     R5, A
(1)      AF : 22                         ret
(1)      B0 :
(1)      B0 :                    mandelbrot:
(1)      B0 : 7C E5                      mov     R4, #LOW(229)
(1)      B2 : 7D 00                      mov     R5, #HIGH(229)
(1)      B4 : 7B 3E                      mov     R3, #c229
(1)      B6 : 31 F0                      acall   set             ; c229=229
(1)      B8 : 7C A0                      mov     R4, #LOW(416)
(1)      BA : 7D 01                      mov     R5, #HIGH(416)
(1)      BC : 7B 40                      mov     R3, #c416
(1)      BE : 31 F0                      acall   set             ; c416=416
(1)      C0 : 7C 64                      mov     R4, #LOW(100)
(1)      C2 : 7D 00                      mov     R5, #HIGH(100)
(1)      C4 : 7B 42                      mov     R3, #c100
(1)      C6 : 31 F0                      acall   set             ; c100=100
(1)      C8 : 7C 32                      mov     R4, #LOW(50)
(1)      CA : 7D 00                      mov     R5, #HIGH(50)
(1)      CC : 7B 44                      mov     R3, #vF         ; F=50
(1)      CE : 31 F0                      acall   set
(1)      D0 : 75 56 F4                   mov     vY, #-12        ; Y=-12
(1)      D3 :                    loop_y:
(1)      D3 : 75 57 CF                   mov     vX, #-49        ; X=-49
(1)      D6 :                    loop_x:
(1)      D6 : E5 57                      mov     A, vX
(1)      D8 : 11 A5                      acall   sex_A
(1)      DA : 7B 46                      mov     R3, #vC
(1)      DC : 31 F0                      acall   set             ; C=X
(1)      DE : 7A 46                      mov     R2, #vC
(1)      E0 : 7B 3E                      mov     R3, #c229
(1)      E2 : 51 E9                      acall   mulsi2          ; C=X*229
(1)      E4 : 7A 46                      mov     R2, #vC
(1)      E6 : 7B 42                      mov     R3, #c100
(1)      E8 : 71 8E                      acall   divsi2          ; C=X*229/100
(1)      EA : E5 56                      mov     A, vY
(1)      EC : 11 A5                      acall   sex_A
(1)      EE : 7B 48                      mov     R3, #vD
(1)      F0 : 31 F0                      acall   set             ; D=Y
(1)      F2 : 7A 48                      mov     R2, #vD
(1)      F4 : 7B 40                      mov     R3, #c416
(1)      F6 : 51 E9                      acall   mulsi2          ; D=Y*416
(1)      F8 : 7A 48                      mov     R2, #vD
(1)      FA : 7B 42                      mov     R3, #c100
(1)      FC : 71 8E                      acall   divsi2          ; D=Y*416/100
(1)      FE : 7A 4A                      mov     R2, #vA
(1)     100 : 7B 46                      mov     R3, #vC
(1)     102 : 31 F8                      acall   assign          ; A=C
(1)     104 : 7A 4C                      mov     R2, #vB
(1)     106 : 7B 48                      mov     R3, #vD
(1)     108 : 31 F8                      acall   assign          ; B=D
(1)     10A : 75 58 00                   mov     vI, #0          ; I=0
(1)     10D :
(1)     10D :                            ;; mov     R2, #vY
(1)     10D :                            ;; mov     A, #'Y'
(1)     10D :                            ;; acall   print8          print Y
(1)     10D :                            ;; mov     R2, #vX
(1)     10D :                            ;; mov     A, #'X'
(1)     10D :                            ;; acall   print8          print X
(1)     10D :                            ;; mov     R2, #vC
(1)     10D :                            ;; mov     A, #'C'
(1)     10D :                            ;; acall   print           print C
(1)     10D :                            ;; mov     R2, #vD
(1)     10D :                            ;; mov     A, #'D'
(1)     10D :                            ;; acall   print           print D
(1)     10D :                            ;; acall   newline
(1)     10D :
(1)     10D :                    loop_i:
(1)     10D : 7A 50                      mov     R2, #vQ
(1)     10F : 7B 4C                      mov     R3, #vB
(1)     111 : 31 F8                      acall   assign          ; Q=B
(1)     113 : 7B 44                      mov     R3, #vF
(1)     115 : 71 8E                      acall   divsi2          ; Q=B/F
(1)     117 : 7A 3C                      mov     R2, #tmp
(1)     119 : 7B 50                      mov     R3, #vQ
(1)     11B : 31 F8                      acall   assign          ; tmp=Q
(1)     11D : 7B 44                      mov     R3, #vF
(1)     11F : 51 E9                      acall   mulsi2          ; tmp=Q*F
(1)     121 : 7A 52                      mov     R2, #vS
(1)     123 : 7B 4C                      mov     R3, #vB
(1)     125 : 31 F8                      acall   assign          ; S=B
(1)     127 : 7B 3C                      mov     R3, #tmp
(1)     129 : 51 95                      acall   subsi2          ; S=B-Q*F
(1)     12B : 7A 3C                      mov     R2, #tmp
(1)     12D : 7B 4C                      mov     R3, #vB
(1)     12F : 31 F8                      acall   assign          ; tmp=B
(1)     131 : 51 E9                      acall   mulsi2          ; tmp=B*B
(1)     133 : 7A 54                      mov     R2, #vT
(1)     135 : 7B 4A                      mov     R3, #vA
(1)     137 : 31 F8                      acall   assign          ; T=A
(1)     139 : 51 E9                      acall   mulsi2          ; T=A*A
(1)     13B : 7A 54                      mov     R2, #vT
(1)     13D : 7B 3C                      mov     R3, #tmp
(1)     13F : 51 95                      acall   subsi2          ; T=A*A-B*B
(1)     141 : 7A 54                      mov     R2, #vT
(1)     143 : 7B 44                      mov     R3, #vF
(1)     145 : 71 8E                      acall   divsi2          ; T=(A*A-B*B)/F
(1)     147 : 7A 54                      mov     R2, #vT
(1)     149 : 7B 46                      mov     R3, #vC
(1)     14B : 51 85                      acall   addsi2          ; T=(A*A-B*B)/F+C
(1)     14D : 7A 3C                      mov     R2, #tmp
(1)     14F : 7B 4A                      mov     R3, #vA         ; tmp=A
(1)     151 : 31 F8                      acall   assign
(1)     153 : 7B 52                      mov     R3, #vS
(1)     155 : 51 E9                      acall   mulsi2          ; tmp=A*S
(1)     157 : 7A 3C                      mov     R2, #tmp
(1)     159 : 7B 44                      mov     R3, #vF
(1)     15B : 71 8E                      acall   divsi2          ; tmp=A*S/F
(1)     15D : 7A 4C                      mov     R2, #vB
(1)     15F : 7B 4A                      mov     R3, #vA
(1)     161 : 31 F8                      acall   assign          ; B=A
(1)     163 : 7B 50                      mov     R3, #vQ
(1)     165 : 51 E9                      acall   mulsi2          ; B=A*Q
(1)     167 : 7A 4C                      mov     R2, #vB
(1)     169 : 7B 3C                      mov     R3, #tmp
(1)     16B : 51 85                      acall   addsi2          ; B=A*Q+A*S/F
(1)     16D : 7A 4C                      mov     R2, #vB
(1)     16F : 7B 4C                      mov     R3, #vB
(1)     171 : 51 85                      acall   addsi2          ; B=2*(A*Q+A*S/F)
(1)     173 : 7A 4C                      mov     R2, #vB
(1)     175 : 7B 48                      mov     R3, #vD
(1)     177 : 51 85                      acall   addsi2          ; B=2*(A*Q+A*S/F)+D
(1)     179 : 7A 4A                      mov     R2, #vA
(1)     17B : 7B 54                      mov     R3, #vT
(1)     17D : 31 F8                      acall   assign          ; A=T
(1)     17F : 7A 4E                      mov     R2, #vP
(1)     181 : 31 F8                      acall   assign          ; P=A
(1)     183 : 7B 44                      mov     R3, #vF
(1)     185 : 71 8E                      acall   divsi2          ; P=A/F
(1)     187 : 7A 50                      mov     R2, #vQ
(1)     189 : 7B 4C                      mov     R3, #vB
(1)     18B : 31 F8                      acall   assign          ; Q=B
(1)     18D : 7B 44                      mov     R3, #vF
(1)     18F : 71 8E                      acall   divsi2          ; Q=B/F
(1)     191 : 7A 3C                      mov     R2, #tmp
(1)     193 : 7B 50                      mov     R3, #vQ
(1)     195 : 31 F8                      acall   assign          ; tmp=Q
(1)     197 : 51 E9                      acall   mulsi2          ; tmp=Q*Q
(1)     199 : 7A 54                      mov     R2, #vT
(1)     19B : 7B 4E                      mov     R3, #vP
(1)     19D : 31 F8                      acall   assign          ; T=P
(1)     19F : 51 E9                      acall   mulsi2          ; T=P*P
(1)     1A1 : 7A 54                      mov     R2, #vT
(1)     1A3 : 7B 3C                      mov     R3, #tmp
(1)     1A5 : 51 85                      acall   addsi2          ; T=P*P+Q*Q (T>=0)
(1)     1A7 :
(1)     1A7 :                            ;; acall   putspace
(1)     1A7 :                            ;; mov     R2, #vI
(1)     1A7 :                            ;; mov     A, #'I'
(1)     1A7 :                            ;; acall   print8          ; print I
(1)     1A7 :                            ;; mov     R2, #vA
(1)     1A7 :                            ;; mov     A, #'A'
(1)     1A7 :                            ;; acall   print           ; print A
(1)     1A7 :                            ;; mov     R2, #vB
(1)     1A7 :                            ;; mov     A, #'B'
(1)     1A7 :                            ;; acall   print           ; print B
(1)     1A7 :                            ;; mov     R2, #vP
(1)     1A7 :                            ;; mov     A, #'P'
(1)     1A7 :                            ;; acall   print           ; print P
(1)     1A7 :                            ;; mov     R2, #vQ
(1)     1A7 :                            ;; mov     A, #'Q'
(1)     1A7 :                            ;; acall   print           ; print Q
(1)     1A7 :                            ;; mov     R2, #vT
(1)     1A7 :                            ;; mov     A, #'T'
(1)     1A7 :                            ;; acall   print           ; print T
(1)     1A7 :                            ;; acall   newline
(1)     1A7 :
(1)     1A7 : E5 55                      mov     A, vT+1         ; A=hi(T)
(1)     1A9 : 70 15                      jnz     print_i         ; if T>=256
(1)     1AB : E5 54                      mov     A, vT           ; A=lo(T)
(1)     1AD : 24 FB                      add     A, #-(4+1)
(1)     1AF : 40 0F                      jc      print_i         ; if T>=5
(1)     1B1 : 05 58                      inc     vI              ; I+=1
(1)     1B3 : E5 58                      mov     A, vI           ; A=I (I>=0)
(1)     1B5 : B4 10 02                   cjne    A, #16, jmp_loop_i
(1)     1B8 : 80 02                      sjmp    print_space
(1)     1BA :                    jmp_loop_i:
(1)     1BA : 21 0D                      ajmp    loop_i          ; if I<16
(1)     1BC :                    print_space:
(1)     1BC : 74 20                      mov     A, #' '
(1)     1BE : 80 0A                      sjmp    print_char
(1)     1C0 :                    print_i:
(1)     1C0 : E5 58                      mov     A, vI
(1)     1C2 : 24 F6                      add     A, #-10
(1)     1C4 : 50 02                      jnc     print_dec       ; if I<10
(1)     1C6 : 24 07                      add     A, #'A'-('0'+10)
(1)     1C8 :                    print_dec:
(1)     1C8 : 24 3A                      add     A, #10+'0'
(1)     1CA :                    print_char:
(1)     1CA :                            ;; push    ACC             ; push A
(1)     1CA :                            ;; mov     A, #'@'
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; mov     A, #'='
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; pop     ACC
(1)     1CA :                            ;; push    ACC             ; restore A
(1)     1CA :                            ;; acall   putchar
(1)     1CA :                            ;; acall   newline
(1)     1CA :                            ;; pop     ACC             ; pop A
(1)     1CA :
(1)     1CA : 11 85                      acall   putchar
(1)     1CC : 11 63                      acall   getchar
(1)     1CE : 50 03                      jnc     next_x
(1)     1D0 : 70 01                      jnz     next_x
(1)     1D2 : A5                         db      0A5H            ; halt to system
(1)     1D3 :                    next_x:
(1)     1D3 : 05 57                      inc     vX               ; X+=1
(1)     1D5 : E5 57                      mov     A, vX
(1)     1D7 : 20 E7 04                   jb      ACC.7, jmp_loop_x ; if hi(X)<0
(1)     1DA : 24 E2                      add     A, #-30
(1)     1DC : 40 02                      jc      next_y
(1)     1DE :                    jmp_loop_x:
(1)     1DE : 01 D6                      ajmp    loop_x          ; if X<30
(1)     1E0 :                    next_y:
(1)     1E0 : 11 7F                      acall   newline
(1)     1E2 : 05 56                      inc     vY              ; Y+=1
(1)     1E4 : E5 56                      mov     A, vY
(1)     1E6 : 20 E7 04                   jb      ACC.7, jmp_loop_y ; if hi(Y)<0
(1)     1E9 : 24 F3                      add     A, #-13
(1)     1EB : 40 02                      jc      mandelbrot_end
(1)     1ED :                    jmp_loop_y:
(1)     1ED : 01 D3                      ajmp    loop_y          ; if Y<13
(1)     1EF :                    mandelbrot_end:
(1)     1EF : 22                         ret
(1)     1F0 :
(1)     1F0 :                    ;;; Set value to variable
(1)     1F0 :                    ;;; @param R5:R4 value
(1)     1F0 :                    ;;; @param R3 &variable
(1)     1F0 :                    ;;; @clobber A R0
(1)     1F0 :                    set:
(1)     1F0 : EB                         mov     A, R3
(1)     1F1 : F8                         mov     R0, A
(1)     1F2 : EC                         mov     A, R4
(1)     1F3 : F6                         mov     @R0, A
(1)     1F4 : ED                         mov     A, R5
(1)     1F5 : 08                         inc     R0
(1)     1F6 : F6                         mov     @R0, A
(1)     1F7 : 22                         ret
(1)     1F8 :
(1)     1F8 :                    ;;; Assign variable; v1 = v2
(1)     1F8 :                    ;;; @param R2 &v1
(1)     1F8 :                    ;;; @param R3 &v2
(1)     1F8 :                    ;;; @clobber A R0
(1)     1F8 :                    assign:
(1)     1F8 : EB                         mov     A, R3
(1)     1F9 : F8                         mov     R0, A           ; R0=&v2
(1)     1FA : E6                         mov     A, @R0
(1)     1FB : FB                         mov     R3, A           ; R3=lo(v2)
(1)     1FC : 08                         inc     R0              ; R0=&v2+1
(1)     1FD : E6                         mov     A, @R0          ; A=hi(v2)
(1)     1FE : CA                         xch     A, R2           ; R2=hi(v2), A=&v1
(1)     1FF : C8                         xch     A, R0           ; R0=&v1, A=&v2+1
(1)     200 : CB                         xch     A, R3           ; R3=&v2+1, A=lo(v2)
(1)     201 : 1B                         dec     R3              ; R3=&v2
(1)     202 : F6                         mov     @R0, A          ; lo(v1)=lo(v2)
(1)     203 : EA                         mov     A, R2           ; A=hi(v2)
(1)     204 : 08                         inc     R0              ; R0=&v1+1
(1)     205 : F6                         mov     @R0, A          ; hi(v1)=hi(v2)
(1)     206 : 18                         dec     R0              ; R0=&v1
(1)     207 : E8                         mov     A, R0
(1)     208 : FA                         mov     R2, A           ; R2=&v1
(1)     209 : 22                         ret
(1)     20A :
(1)     20A :                    ;;; Print 8-bit variable
(1)     20A :                    ;;; @param A: variable name
(1)     20A :                    ;;; @param R2: &variable
(1)     20A :                    ;;; @clobber A R0
(1)     20A :                    print8:
(1)     20A : C0 E0                      push    ACC
(1)     20C : EA                         mov     A, R2
(1)     20D : F8                         mov     R0, A
(1)     20E : E6                         mov     A, @R0
(1)     20F : 11 A5                      acall   sex_A
(1)     211 : 7B 3C                      mov     R3, #tmp
(1)     213 : 31 F0                      acall   set
(1)     215 : 7A 3C                      mov     R2, #tmp
(1)     217 : D0 E0                      pop     ACC
(1)     219 :
(1)     219 :                    ;;; Print variable
(1)     219 :                    ;;; @param A: variable name
(1)     219 :                    ;;; @param R2: &variable
(1)     219 :                    ;;; @clobber A R0
(1)     219 :                    print:
(1)     219 : 11 85                      acall   putchar
(1)     21B : 74 3D                      mov     A, #'='
(1)     21D : 11 85                      acall   putchar
(1)     21F : EA                         mov     A, R2
(1)     220 : F8                         mov     R0, A
(1)     221 : 51 25                      acall   print_int16
(1)     223 : 01 7B                      ajmp    putspace
        225 :                            include "arith.inc"
(1)     225 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     225 :                            cpu     8051
(1)     225 :
(1)     225 :                    ;;; Print signed 16-bit integer as decimal
(1)     225 :                    ;;; @param R0 &value
(1)     225 :                    ;;; @clobber A
(1)     225 :                    print_int16:
(1)     225 : E8                         mov     A, R0
(1)     226 : C0 E0                      push    ACC             ; save R0
(1)     228 : E6                         mov     A, @R0
(1)     229 : CA                         xch     A, R2
(1)     22A : C0 E0                      push    ACC             ; save R2
(1)     22C : 08                         inc     R0
(1)     22D : E6                         mov     A, @R0
(1)     22E : CB                         xch     A, R3
(1)     22F : C0 E0                      push    ACC             ; save R3
(1)     231 : EB                         mov     A, R3
(1)     232 : 30 E7 08                   jnb     ACC.7, print_uint16
(1)     235 : 74 2D                      mov     A, #'-'
(1)     237 : 12 00 85                   lcall   putchar         ; print '-'
(1)     23A : 12 02 64                   lcall   neg_R3R2        ; negate value
(1)     23D :                    ;;; Print unsigned 16-bit integer as decimal
(1)     23D :                    ;;; @param R3:R2 value
(1)     23D :                    ;;; @param print_uint16_buf external data memory
(1)     23D :                    ;;; @clobber A
(1)     23D :                    print_uint16:
(1)     23D : 90 21 00                   mov     DPTR, #print_uint16_buf
(1)     240 : E4                         clr     A
(1)     241 : F0                         movx    @DPTR, A        ; mark EOS
(1)     242 :                    print_uint16_loop:
(1)     242 : 7C 0A                      mov     R4, #10
(1)     244 : 12 03 2C                   lcall   udiv16_8        ; R2:R3/10=R2:R3...R4
(1)     247 : EC                         mov     A, R4           ; lo(remainder)
(1)     248 : 24 30                      add     A, #'0'
(1)     24A : A3                         inc     DPTR
(1)     24B : F0                         movx    @DPTR, A        ; write to buffer
(1)     24C : EA                         mov     A, R2
(1)     24D : 4B                         orl     A, R3
(1)     24E : 70 F2                      jnz     print_uint16_loop ; until value == 0
(1)     250 :                    print_uint16_out:
(1)     250 : E0                         movx    A, @DPTR
(1)     251 : 60 07                      jz      print_uint16_end
(1)     253 : 12 00 85                   lcall   putchar
(1)     256 : 15 82                      dec     DPL
(1)     258 : 80 F6                      sjmp    print_uint16_out
(1)     25A :                    print_uint16_end:
(1)     25A : D0 E0                      pop     ACC
(1)     25C : FB                         mov     R3, A           ; restore R3
(1)     25D : D0 E0                      pop     ACC
(1)     25F : FA                         mov     R2, A           ; restore R2
(1)     260 : D0 E0                      pop     ACC
(1)     262 : F8                         mov     R0, A           ; restore R0
(1)     263 : 22                         ret
(1)     264 :
(1)     264 :                    ;;; Negation; result = -result
(1)     264 :                    ;;; @param R3:R2 result
(1)     264 :                    ;;; @clobber A
(1)     264 :                    neg_R3R2:
(1)     264 : E4                         clr     A
(1)     265 : C3                         clr     C
(1)     266 : 9A                         subb    A, R2
(1)     267 : FA                         mov     R2, A
(1)     268 : E4                         clr     A
(1)     269 : 9B                         subb    A, R3
(1)     26A : FB                         mov     R3, A
(1)     26B : 22                         ret
(1)     26C :
(1)     26C :                    ;;; Negation; result = -result
(1)     26C :                    ;;; @param R5:R4 result
(1)     26C :                    ;;; @clobber A
(1)     26C :                    neg_R5R4:
(1)     26C : E4                         clr     A
(1)     26D : C3                         clr     C
(1)     26E : 9C                         subb    A, R4
(1)     26F : FC                         mov     R4, A
(1)     270 : E4                         clr     A
(1)     271 : 9D                         subb    A, R5
(1)     272 : FD                         mov     R5, A
(1)     273 : 22                         ret
(1)     274 :
(1)     274 :                    ;;; Negation; result = -value
(1)     274 :                    ;;; @param R2: &result
(1)     274 :                    ;;; @param R3: &value
(1)     274 :                    ;;; @clobber A R0 R2 R3
(1)     274 :                    negsi2:
(1)     274 : EB                         mov     A, R3
(1)     275 : F8                         mov     R0, A           ; R0=&value
(1)     276 : E4                         clr     A
(1)     277 : C3                         clr     C
(1)     278 : 96                         subb    A, @R0          ; A=lo(-value)
(1)     279 : FB                         mov     R3, A           ; R3=lo(-value)
(1)     27A : 08                         inc     R0
(1)     27B : E4                         clr     A
(1)     27C : 96                         subb    A, @R0          ; A=hi(-value)
(1)     27D : CA                         xch     A, R2           ; R2=hi(-value)
(1)     27E : F8                         mov     R0, A           ; R0=&result
(1)     27F : EB                         mov     A, R3
(1)     280 : F6                         mov     @R0, A          ; store lo(-value)
(1)     281 : 08                         inc     R0
(1)     282 : EA                         mov     A, R2
(1)     283 : F6                         mov     @R0, A          ; store hi(-value)
(1)     284 : 22                         ret
(1)     285 :
(1)     285 :                    ;;; Signed addition: summand += addend
(1)     285 :                    ;;; @param R2: &summand
(1)     285 :                    ;;; @param R3: &addend
(1)     285 :                    ;;; @clobber A R2 R3
(1)     285 :                    addsi2:
(1)     285 : EB                         mov     A, R3
(1)     286 : F8                         mov     R0, A           ; R0=&addend
(1)     287 : E6                         mov     A, @R0          ; A=lo(addend)
(1)     288 : FB                         mov     R3, A           ; R3=lo(addend)
(1)     289 : 08                         inc     R0
(1)     28A : E6                         mov     A, @R0          ; A=hi(addend)
(1)     28B : CA                         xch     A, R2           ; R2=hi(addend)
(1)     28C : F8                         mov     R0, A           ; R0=&summand
(1)     28D : E6                         mov     A, @R0          ; A=lo(summand)
(1)     28E : 2B                         add     A, R3           ; A=lo(summand+addend)
(1)     28F : F6                         mov     @R0, A
(1)     290 : 08                         inc     R0
(1)     291 : E6                         mov     A, @R0          ; A=hi(summand)
(1)     292 : 3A                         addc    A, R2           ; A=hi(summand+addend)
(1)     293 : F6                         mov     @R0, A
(1)     294 : 22                         ret
(1)     295 :
(1)     295 :                    ;;; Singed subtraction: minuend -= subtrahend
(1)     295 :                    ;;; @param R2: &minuend
(1)     295 :                    ;;; @param R3: &subtrahend
(1)     295 :                    ;;; @clobber A R0 R2 R3
(1)     295 :                    subsi2:
(1)     295 : EB                         mov     A, R3
(1)     296 : F8                         mov     R0, A           ; R0=&subtrahend
(1)     297 : E6                         mov     A, @R0          ; A=lo(subtrahend)
(1)     298 : FB                         mov     R3, A           ; R3=lo(subtrahend)
(1)     299 : 08                         inc     R0
(1)     29A : E6                         mov     A, @R0          ; A=hi(subtrahend)
(1)     29B : CA                         xch     A, R2           ; R2=hi(subtrahend)
(1)     29C : F8                         mov     R0, A           ; R0=&minuend
(1)     29D : E6                         mov     A, @R0          ; A=lo(minuend)
(1)     29E : C3                         clr     C
(1)     29F : 9B                         subb    A, R3           ; A=lo(minuend-subtrahend)
(1)     2A0 : F6                         mov     @R0, A
(1)     2A1 : 08                         inc     R0
(1)     2A2 : E6                         mov     A, @R0          ; A=hi(minuend)
(1)     2A3 : 9A                         subb    A, R2           ; A=hi(minuend-subtrahend)
(1)     2A4 : F6                         mov     @R0, A
(1)     2A5 : 22                         ret
(1)     2A6 :
(1)     2A6 :                    ;;; Signed comparison: minuend - subtrahend
(1)     2A6 :                    ;;; @param R2: &minuend
(1)     2A6 :                    ;;; @param R3: &subtrahend
(1)     2A6 :                    ;;; @return A  0: minuend == subtrahend
(1)     2A6 :                    ;;;         A  1: minuend >  subtrahend
(1)     2A6 :                    ;;;         A -1: minuend <  subtrahend
(1)     2A6 :                    ;;; @clobber A R0 R2 R3
(1)     2A6 :                    cmpsi2:
(1)     2A6 : EB                         mov     A, R3
(1)     2A7 : F8                         mov     R0, A           ; R0=&subtrahend
(1)     2A8 : E6                         mov     A, @R0          ; A=lo(subtrahend)
(1)     2A9 : FB                         mov     R3, A           ; R3=lo(subtrahend)
(1)     2AA : 08                         inc     R0
(1)     2AB : E6                         mov     A, @R0          ; A=hi(subtrahend)
(1)     2AC : C0 E0                      push    ACC             ; save hi(subtrahend)
(1)     2AE : CA                         xch     A, R2           ; R2=hi(subtrahend)
(1)     2AF : F8                         mov     R0, A           ; R0=&minuend
(1)     2B0 : E6                         mov     A, @R0          ; A=lo(minuend)
(1)     2B1 : C3                         clr     C
(1)     2B2 : 9B                         subb    A, R3
(1)     2B3 : FB                         mov     R3, A           ; A=lo(minuend-subtrahend)
(1)     2B4 : 08                         inc     R0
(1)     2B5 : E6                         mov     A, @R0          ; A=hi(minuend)
(1)     2B6 : 9A                         subb    A, R2
(1)     2B7 : FA                         mov     R2, A           ; R2=hi(minuend-subtrahend)
(1)     2B8 : 4B                         orl     A, R3
(1)     2B9 : 60 15                      jz      cmpsi2_eq       ; branch if minuend-subtrahend==0
(1)     2BB : D0 E0                      pop     ACC             ; restore hi(subtrahend)
(1)     2BD : 66                         xrl     A, @R0          ; A=hi(minuend^subtrahend)
(1)     2BE : C0 E0                      push    ACC             ; save hi(minuend^subtrahend)
(1)     2C0 : EA                         mov     A, R2
(1)     2C1 : 66                         xrl     A, @R0
(1)     2C2 : FB                         mov     R3, A           ; R3=hi(minuend-subtrahend)^minuend
(1)     2C3 : D0 E0                      pop     ACC             ; restore hi(minuend^subtrahend)
(1)     2C5 : 5B                         anl     A, R3           ; overflow flag
(1)     2C6 : 6A                         xrl     A, R2
(1)     2C7 : 20 E7 03                   jb      ACC.7, cmpsi2_lt
(1)     2CA :                    cmpsi2_gt:
(1)     2CA : 74 01                      mov     A, #1
(1)     2CC : 22                         ret
(1)     2CD :                    cmpsi2_lt:
(1)     2CD : 74 FF                      mov     A, #-1
(1)     2CF : 22                         ret
(1)     2D0 :                    cmpsi2_eq:
(1)     2D0 : 15 81                      dec     SP              ; discard hi(subtrahend)
(1)     2D2 : 22                         ret
(1)     2D3 :
(1)     2D3 :                    ;;; Unsigned multiplication: result = multiplicand * multiplier
(1)     2D3 :                    ;;; @param R3:R2 multiplicand
(1)     2D3 :                    ;;; @param R5:R4 multiplier
(1)     2D3 :                    ;;; @return R3:R2 result
(1)     2D3 :                    ;;; @clobber A R2 R3 R6 R7
(1)     2D3 :                    umul16:
(1)     2D3 : EA                         mov     A, R2           ; A=lo(multiplicand)
(1)     2D4 : 8C F0                      mov     B, R4           ; B=lo(multiplier)
(1)     2D6 : A4                         mul     AB              ; B:A
(1)     2D7 : FE                         mov     R6, A
(1)     2D8 : AF F0                      mov     R7, B           ; R7:R6=result
(1)     2DA : EA                         mov     A, R2           ; A=lo(multiplicand)
(1)     2DB : 8D F0                      mov     B, R5           ; B=hi(multiplier)
(1)     2DD : A4                         mul     AB
(1)     2DE : 2F                         add     A, R7
(1)     2DF : FF                         mov     R7, A           ; result+=lo(BA)
(1)     2E0 : EB                         mov     A, R3           ; A=hi(multiplicand)
(1)     2E1 : 8C F0                      mov     B, R4           ; B=lo(multiplier)
(1)     2E3 : A4                         mul     AB
(1)     2E4 : 2F                         add     A, R7
(1)     2E5 : FB                         mov     R3, A
(1)     2E6 : EE                         mov     A, R6
(1)     2E7 : FA                         mov     R2, A
(1)     2E8 : 22                         ret
(1)     2E9 :
(1)     2E9 :                    ;;; Signed multiplication: multiplicand *= multiplier
(1)     2E9 :                    ;;; @param R2: &multiplicand
(1)     2E9 :                    ;;; @param R3: &multiplier
(1)     2E9 :                    ;;; @clobber A R0 R2 R3 R4 R5 R6 R7
(1)     2E9 :                    mulsi2:
(1)     2E9 : EA                         mov     A, R2
(1)     2EA : C0 E0                      push    ACC             ; save &multiplicand
(1)     2EC : EB                         mov     A, R3
(1)     2ED : C0 E0                      push    ACC             ; save &multiplier
(1)     2EF : F8                         mov     R0, A           ; R0=&multiplier
(1)     2F0 : E6                         mov     A, @R0
(1)     2F1 : FC                         mov     R4, A
(1)     2F2 : 08                         inc     R0
(1)     2F3 : E6                         mov     A, @R0
(1)     2F4 : FD                         mov     R5, A           ; R5:R4=multiplier
(1)     2F5 : 30 E7 03                   jnb     ACC.7, mulsi2_multiplicand
(1)     2F8 : 12 02 6C                   lcall   neg_R5R4
(1)     2FB :                    mulsi2_multiplicand:
(1)     2FB : EA                         mov     A, R2
(1)     2FC : F8                         mov     R0, A           ; R0=&multiplicand
(1)     2FD : E6                         mov     A, @R0
(1)     2FE : FA                         mov     R2, A
(1)     2FF : 08                         inc     R0
(1)     300 : E6                         mov     A, @R0
(1)     301 : FB                         mov     R3, A
(1)     302 : 30 E7 03                   jnb     ACC.7, mulsi2_multiply
(1)     305 : 12 02 64                   lcall   neg_R3R2
(1)     308 :                    mulsi2_multiply:
(1)     308 : 12 02 D3                   lcall   umul16
(1)     30B : D0 E0                      pop     ACC
(1)     30D : F8                         mov     R0, A           ; R0=&multiplier
(1)     30E : 08                         inc     R0
(1)     30F : E6                         mov     A, @R0          ; A=hi(multiplier)
(1)     310 : FD                         mov     R5, A           ; R5=hi(multiplier)
(1)     311 : D0 E0                      pop     ACC
(1)     313 : F8                         mov     R0, A           ; R0=&multiplicand
(1)     314 : 08                         inc     R0
(1)     315 : E6                         mov     A, @R0          ; A=hi(multiplicand)
(1)     316 : 6D                         xrl     A, R5           ; A=hi(multiplicand^multiplier)
(1)     317 : 30 E7 03                   jnb     ACC.7, mulsi2_store
(1)     31A : 12 02 64                   lcall   neg_R3R2
(1)     31D :                    mulsi2_store:
(1)     31D : EB                         mov     A, R3
(1)     31E : F6                         mov     @R0, A
(1)     31F : 18                         dec     R0
(1)     320 : EA                         mov     A, R2
(1)     321 : F6                         mov     @R0, A
(1)     322 : 22                         ret
(1)     323 :
(1)     323 :                    ;;; Unsigned division: dividend / divisor = quotient ... remainder
(1)     323 :                    ;;; @praram R3:R2 dividend
(1)     323 :                    ;;; @praram R5:R4 divisor
(1)     323 :                    ;;; @return R3:R2 quotient
(1)     323 :                    ;;; @return R5:R4 remainder
(1)     323 :                    ;;; @clobber A R1 R2 R3 R4 R5 R6 R7
(1)     323 :                    udiv16:
(1)     323 : ED                         mov     A, R5
(1)     324 : 70 34                      jnz     udiv16_large    ; branch if divisor >= 256
(1)     326 : 4C                         orl     A, R4
(1)     327 : 60 29                      jz      udiv16_zero     ; divide by zero
(1)     329 : EB                         mov     A, R3
(1)     32A : 60 1E                      jz      udiv8_8         ; branch if divisor < 256
(1)     32C :                    ;;; Unsigned division: dividend / divisor = quotient ... remainder
(1)     32C :                    ;;; @praram R3:R2 dividend
(1)     32C :                    ;;; @praram R4 divisor
(1)     32C :                    ;;; @return R3:R2 quotient
(1)     32C :                    ;;; @return R4 remainder
(1)     32C :                    ;;; @clobber A B
(1)     32C :                    udiv16_8:
(1)     32C : EB                         mov     A, R3           ; high(dividend)
(1)     32D : 8C F0                      mov     B, R4           ; divisor
(1)     32F : 84                         div     AB              ; A=high(quotient), B=reminder of high
(1)     330 : FB                         mov     R3, A           ; R3=high(quotient)
(1)     331 :                            ;; Divide B:R2 by R4 where B<R4
(1)     331 : 78 08                      mov     R0, #8          ; loop counter
(1)     333 :                    udiv16_8_loop:
(1)     333 : EA                         mov     A, R2
(1)     334 : C3                         clr     C
(1)     335 : 33                         rlc     A
(1)     336 : FA                         mov     R2, A
(1)     337 : E5 F0                      mov     A, B
(1)     339 : 33                         rlc     A
(1)     33A : F5 F0                      mov     B, A            ; B:R2 <<= 1
(1)     33C :                            ;; Compare B with R4 (divisor)
(1)     33C : E5 F0                      mov     A, B
(1)     33E : C3                         clr     C
(1)     33F : 9C                         subb    A, R4           ; A=B-R4
(1)     340 : 40 03                      jc      udiv16_8_next   ; jump if B < R4
(1)     342 : F5 F0                      mov     B, A            ; update B
(1)     344 : 0A                         inc     R2              ; set lowest bit as part of low(quotient)
(1)     345 :                    udiv16_8_next:
(1)     345 : D8 EC                      djnz    R0, udiv16_8_loop
(1)     347 : AC F0                      mov     R4, B           ; R4=reminder
(1)     349 : 22                         ret
(1)     34A :                    ;;; Unsigned division: dividend / divisor = quotient ... remainder
(1)     34A :                    ;;; @praram R2 dividend
(1)     34A :                    ;;; @praram R4 divisor
(1)     34A :                    ;;; @return R2 quotient
(1)     34A :                    ;;; @return R4 remainder
(1)     34A :                    ;;; @clobber A B R2 R4
(1)     34A :                    udiv8_8:
(1)     34A : EA                         mov     A, R2
(1)     34B : 8C F0                      mov     B, R4           ; A=dividend, B=divisor
(1)     34D : 84                         div     AB              ; A=quotient, B=reminder
(1)     34E : FA                         mov     R2, A
(1)     34F : AC F0                      mov     R4, B
(1)     351 : 22                         ret
(1)     352 :                    udiv16_zero:
(1)     352 : EB                         mov     A, R3           ; remainder = dividend
(1)     353 : FD                         mov     R5, A
(1)     354 : EA                         mov     A, R2
(1)     355 : FC                         mov     R4, A
(1)     356 : E4                         clr     A               ; quotient = 0
(1)     357 : FB                         mov     R3, A
(1)     358 : FA                         mov     R2, A
(1)     359 : 22                         ret
(1)     35A :                    ;;; dividend > divisor
(1)     35A :                    udiv16_large:
(1)     35A : EB                         mov     A, R3
(1)     35B : C3                         clr     C
(1)     35C : 9D                         subb    A, R5
(1)     35D : 40 F3                      jc      udiv16_zero     ; branch if dividend < divisor
(1)     35F : 70 05                      jnz     udiv16_estimate ; branch if dividend > divisor
(1)     361 : EA                         mov     A, R2           ; compare lower byte
(1)     362 : C3                         clr     C
(1)     363 : 9C                         subb    A, R4
(1)     364 : 40 EC                      jc      udiv16_zero     ; branch if dividend < divisor
(1)     366 :                    udiv16_estimate:
(1)     366 : EB                         mov     A, R3
(1)     367 : 8D F0                      mov     B, R5
(1)     369 : 84                         div     AB              ; A=estimated quotient
(1)     36A : F9                         mov     R1, A           ; R1=estimated quotient
(1)     36B :                    udiv16_refine:
(1)     36B : E9                         mov     A, R1
(1)     36C : 8C F0                      mov     B, R4
(1)     36E : A4                         mul     AB              ; B:A=estimated*low(divisor)
(1)     36F : FE                         mov     R6, A           ; R6=low-low(product)
(1)     370 : AF F0                      mov     R7, B           ; R7=low-high(product)
(1)     372 : E9                         mov     A, R1
(1)     373 : 8D F0                      mov     B, R5
(1)     375 : A4                         mul     AB              ; B:A=estimate*high(divisor)
(1)     376 : 2F                         add     A, R7
(1)     377 : FF                         mov     R7, A           ; R7+=mid(product)
(1)     378 : EA                         mov     A, R2           ; dividend-product
(1)     379 : C3                         clr     C
(1)     37A : 9E                         subb    A, R6
(1)     37B : EB                         mov     A, R3
(1)     37C : 9F                         subb    A, R7
(1)     37D : 50 03                      jnc     udiv16_end
(1)     37F : 19                         dec     R1              ; decrease Q
(1)     380 : 80 E9                      sjmp    udiv16_refine
(1)     382 :                    udiv16_end:
(1)     382 : EA                         mov     A, R2
(1)     383 : C3                         clr     C
(1)     384 : 9E                         subb    A, R6
(1)     385 : FC                         mov     R4, A           ; low(remainder)
(1)     386 : EB                         mov     A, R3
(1)     387 : 9F                         subb    A, R7
(1)     388 : FD                         mov     R5, A           ; high(remainder)
(1)     389 : E9                         mov     A, R1
(1)     38A : FA                         mov     R2, A           ; low(quotient)
(1)     38B : 7B 00                      mov     R3, #0          ; high(quotient)
(1)     38D : 22                         ret
(1)     38E :
(1)     38E :                    ;;; Signed division: dividend /= divisor
(1)     38E :                    ;;; @param R2: &dividend
(1)     38E :                    ;;; @param R3: &divisor
(1)     38E :                    ;;; @clobber A R0 R2 R3 R4 R5 R6 R7
(1)     38E :                    divsi2:
(1)     38E : EA                         mov     A, R2
(1)     38F : C0 E0                      push    ACC             ; save &dividend
(1)     391 : EB                         mov     A, R3
(1)     392 : C0 E0                      push    ACC             ; save &divisor
(1)     394 : F8                         mov     R0, A           ; R0=&divisor
(1)     395 : E6                         mov     A, @R0
(1)     396 : FC                         mov     R4, A
(1)     397 : 08                         inc     R0
(1)     398 : E6                         mov     A, @R0
(1)     399 : FD                         mov     R5, A           ; R5:R4=divisor
(1)     39A : 30 E7 03                   jnb     ACC.7, divsi2_dividend
(1)     39D : 12 02 6C                   lcall   neg_R5R4
(1)     3A0 :                    divsi2_dividend:
(1)     3A0 : EA                         mov     A, R2
(1)     3A1 : F8                         mov     R0, A           ; R0=&dividend
(1)     3A2 : E6                         mov     A, @R0
(1)     3A3 : FA                         mov     R2, A
(1)     3A4 : 08                         inc     R0
(1)     3A5 : E6                         mov     A, @R0
(1)     3A6 : FB                         mov     R3, A
(1)     3A7 : 30 E7 03                   jnb     ACC.7, divsi2_divide
(1)     3AA : 12 02 64                   lcall   neg_R3R2
(1)     3AD :                    divsi2_divide:
(1)     3AD : 12 03 23                   lcall   udiv16
(1)     3B0 : D0 E0                      pop     ACC
(1)     3B2 : F8                         mov     R0, A           ; R0=&divisor
(1)     3B3 : 08                         inc     R0
(1)     3B4 : E6                         mov     A, @R0          ; A=hi(divisor)
(1)     3B5 : FD                         mov     R5, A           ; R5=hi(divisor)
(1)     3B6 : D0 E0                      pop     ACC
(1)     3B8 : F8                         mov     R0, A           ; R0=&dividend
(1)     3B9 : 08                         inc     R0
(1)     3BA : E6                         mov     A, @R0          ; A=hi(dividend)
(1)     3BB : 6D                         xrl     A, R5           ; A=hi(dividend^divisor)
(1)     3BC : 30 E7 03                   jnb     ACC.7, divsi2_store
(1)     3BF : 12 02 64                   lcall   neg_R3R2
(1)     3C2 :                    divsi2_store:
(1)     3C2 : EB                         mov     A, R3
(1)     3C3 : F6                         mov     @R0, A
(1)     3C4 : 18                         dec     R0
(1)     3C5 : EA                         mov     A, R2
(1)     3C6 : F6                         mov     @R0, A
(1)     3C7 : 22                         ret
        3C8 :                            include "queue.inc"
(1)     3C8 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)     3C8 :                    ;;; [queue] queue structure on internal data memory
(1)     3C8 : =0                 queue_len:      equ     0       ; queue length
(1)     3C8 : =1                 queue_size:     equ     1       ; buffer size
(1)     3C8 : =2                 queue_put:      equ     2       ; queue put index
(1)     3C8 : =3                 queue_get:      equ     3       ; queue get index
(1)     3C8 : =4                 queue_buf_lo:   equ     4       ; lo(queue buffer) pointer to  external data memory
(1)     3C8 : =5                 queue_buf_hi:   equ     5       ; hi(queue_buffer)
(1)     3C8 : =6                 queue_work_size: equ    6       ; queue work size
(1)     3C8 :
(1)     3C8 :                    ;;; [queue] Initialize queue
(1)     3C8 :                    ;;; @param R0 queue work space pointer
(1)     3C8 :                    ;;; @param R1 queue buffer size
(1)     3C8 :                    ;;; @param DPTR queue buffer pointer
(1)     3C8 :                    ;;; @clobber DPTR R0 R1 A
(1)     3C8 :                    queue_init:
(1)     3C8 : E4                         clr     A
(1)     3C9 : F6                         mov     @R0, A          ; clear queue_len
(1)     3CA : E9                         mov     A, R1
(1)     3CB : 08                         inc     R0
(1)     3CC : F6                         mov     @R0, A          ; save queue_size
(1)     3CD : E4                         clr     A
(1)     3CE : 08                         inc     R0
(1)     3CF : F6                         mov     @R0, A          ; clear queue_put
(1)     3D0 : 08                         inc     R0
(1)     3D1 : F6                         mov     @R0, A          ; clear queue_get
(1)     3D2 : 08                         inc     R0
(1)     3D3 : A6 82                      mov     @R0, DPL        ; lo(queue_buf)
(1)     3D5 : 08                         inc     R0
(1)     3D6 : A6 83                      mov     @R0, DPH        ; hi(queue_buf)
(1)     3D8 :                    queue_init_loop:
(1)     3D8 : F0                         movx    @DPTR, A
(1)     3D9 : A3                         inc     DPTR
(1)     3DA : D9 FC                      djnz    R1, queue_init_loop
(1)     3DC : 22                         ret
(1)     3DD :
(1)     3DD :                    ;;; [queue] Add an element to queue
(1)     3DD :                    ;;; @param R0 queue work space pointer
(1)     3DD :                    ;;; @param A an element
(1)     3DD :                    ;;; @return PSW.C 0 if queue is full
(1)     3DD :                    ;;; @clobber DPTR R0 A
(1)     3DD :                    queue_add:
(1)     3DD : C0 E0                      push    ACC             ; save an element
(1)     3DF : E6                         mov     A, @R0          ; A=queue_len
(1)     3E0 : 08                         inc     R0              ; R0=&queue_size
(1)     3E1 : 66                         xrl     A, @R0          ; queue_size
(1)     3E2 : 70 04                      jnz     queue_add_store ; branch if queue is not full
(1)     3E4 : D0 E0                      pop     ACC
(1)     3E6 : C3                         clr     C               ; PSW.C=0
(1)     3E7 : 22                         ret
(1)     3E8 :                    queue_add_store:
(1)     3E8 : 18                         dec     R0              ; R0=&queue_len
(1)     3E9 : 06                         inc     @R0             ; queue_len+=1
(1)     3EA : 08                         inc     R0
(1)     3EB : 08                         inc     R0
(1)     3EC : E6                         mov     A, @R0          ; A=queue_put
(1)     3ED : 08                         inc     R0
(1)     3EE : 08                         inc     R0
(1)     3EF : 26                         add     A, @R0          ; A=lo(queue_buf)+queue_put
(1)     3F0 : F5 82                      mov     DPL, A
(1)     3F2 : 08                         inc     R0
(1)     3F3 : E6                         mov     A, @R0          ; A=hi(queue_buf)
(1)     3F4 : 34 00                      addc    A, #0
(1)     3F6 : F5 83                      mov     DPH, A
(1)     3F8 : D0 E0                      pop     ACC             ; restore an element
(1)     3FA : F0                         movx    @DPTR, A        ; add an element
(1)     3FB : 18                         dec     R0
(1)     3FC : 18                         dec     R0
(1)     3FD : 18                         dec     R0
(1)     3FE : 06                         inc     @R0             ; queue_put+=1
(1)     3FF : E6                         mov     A, @R0          ; A=queue_put
(1)     400 : 18                         dec     R0
(1)     401 : 66                         xrl     A, @R0          ; queue_size
(1)     402 : 70 02                      jnz     queue_add_end   ; branch if queue_put != queue_size
(1)     404 : 08                         inc     R0
(1)     405 : F6                         mov     @R0, A          ; queue_put=0
(1)     406 :                    queue_add_end:
(1)     406 : D3                         setb    C
(1)     407 : 22                         ret
(1)     408 :
(1)     408 :                    ;;; [queue] Remove an element from queue
(1)     408 :                    ;;; @param R0 queue work space pointer
(1)     408 :                    ;;; @return A an element
(1)     408 :                    ;;; @return PSW.C 0 if queue is empty
(1)     408 :                    ;;; @clobber DPTR R0 A
(1)     408 :                    queue_remove:
(1)     408 : E6                         mov     A, @R0            ; queue_len
(1)     409 : 70 02                      jnz     queue_remove_elem ; queue_len > 0
(1)     40B : C3                         clr     C                 ; PSW.C=0
(1)     40C : 22                         ret
(1)     40D :                    queue_remove_elem:
(1)     40D : 16                         dec     @R0             ; queue_len-=1
(1)     40E : 08                         inc     R0
(1)     40F : 08                         inc     R0
(1)     410 : 08                         inc     R0
(1)     411 : E6                         mov     A, @R0          ; A=queue_get
(1)     412 : 08                         inc     R0
(1)     413 : 26                         add     A, @R0          ; A=lo(queue_buf)+queue_get
(1)     414 : F5 82                      mov     DPL, A
(1)     416 : 08                         inc     R0
(1)     417 : E6                         mov     A, @R0          ; A=hi(queue)
(1)     418 : 34 00                      addc    A, #0
(1)     41A : F5 83                      mov     DPH, A
(1)     41C : E0                         movx    A, @DPTR        ; read an element
(1)     41D : C0 E0                      push    ACC             ; save an element
(1)     41F : 18                         dec     R0
(1)     420 : 18                         dec     R0
(1)     421 : 06                         inc     @R0             ; queue_get+=1
(1)     422 : E6                         mov     A, @R0          ; A=queue_get
(1)     423 : 18                         dec     R0
(1)     424 : 18                         dec     R0
(1)     425 : 66                         xrl     A, @R0          ; queue_size
(1)     426 : 70 03                      jnz     queue_remove_end ; branch if queue_get != queue_size
(1)     428 : 08                         inc     R0
(1)     429 : 08                         inc     R0
(1)     42A : F6                         mov     @R0, A          ; queue_get=0
(1)     42B :                    queue_remove_end:
(1)     42B : D0 E0                      pop     ACC             ; restore an element
(1)     42D : D3                         setb    C
(1)     42E : 22                         ret
        42F :
        42F :                    isr_intr_rx:
        42F : C0 D0                      push    PSW
        431 : C2 D4                      clr     PSW.RS1
        433 : D2 D3                      setb    PSW.RS0         ; select BANK 1
        435 : A9 82                      mov     R1, DPL
        437 : AA 83                      mov     R2, DPH         ; save DPTR
        439 : FB                         mov     R3, A           ; save A
        43A : 90 FF F1                   mov     DPTR, #USARTS
        43D : E0                         movx    A, @DPTR
        43E : 30 E1 07                   jnb     ACC.ST_RxRDY_bp, isr_intr_exit
        441 : 15 82                      dec     DPL
        443 : E0                         movx    A, @DPTR
        444 : 78 30                      mov     R0, #rx_queue
        446 : 71 DD                      acall   queue_add
        448 :                    isr_intr_exit:
        448 : EB                         mov     A, R3           ; restore A
        449 : 8A 83                      mov     DPH, R2
        44B : 89 82                      mov     DPL, R1         ; restore DPTR
        44D : D0 D0                      pop     PSW
        44F : 32                         reti
        450 :
        450 :                    isr_intr_tx:
        450 : C0 D0                      push    PSW
        452 : C2 D4                      clr     PSW.RS1
        454 : D2 D3                      setb    PSW.RS0         ; select BANK 1
        456 : A9 82                      mov     R1, DPL
        458 : AA 83                      mov     R2, DPH         ; save DPTR
        45A : FB                         mov     R3, A           ; save A
        45B : 90 FF F1                   mov     DPTR, #USARTS
        45E : E0                         movx    A, @DPTR
        45F : 30 E0 E6                   jnb     ACC.ST_TxRDY_bp, isr_intr_exit
        462 : 78 36                      mov     R0, #tx_queue
        464 : 91 08                      acall   queue_remove
        466 : 50 06                      jnc     isr_intr_tx_empty
        468 : 90 FF F0                   mov     DPTR, #USARTD
        46B : F0                         movx    @DPTR, A        ; send character
        46C : 80 DA                      sjmp    isr_intr_exit
        46E :                    isr_intr_tx_empty:
        46E : 90 FF F1                   mov     DPTR, #USARTC
        471 : 74 36                      mov     A, #RX_EN_TX_DIS
        473 : F0                         movx    @DPTR, A        ; disable Tx
        474 : 80 D2                      sjmp    isr_intr_exit
        476 :
        476 :                            end
