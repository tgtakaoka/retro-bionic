          0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
          0 :                            cpu     tms7000
          0 :                            include "tms7000.inc"
(1)       0 :                            *** -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                            *** TMS7000
(1)       0 :                            *** Status Register
(1)       0 : =80                ST_CARRY:       equ  ?10000000  set to 1 if carry occurred
(1)       0 : =40                ST_NEGATIVE:    equ  ?01000000  set to 1 if result is negative
(1)       0 : =20                ST_ZERO:        equ  ?00100000  set to 1 if result is zero
(1)       0 : =10                ST_INT:         equ  ?00010000  if 1, interrupt is enabled
(1)       0 :                            *** Vector
(1)       0 : =FFF8              VEC_INT3:       equ     >FFF8   #INT3 interrupt
(1)       0 : =FFFC              VEC_INT1:       equ     >FFFC   #INT1 interrupt
(1)       0 : =FFFE              VEC_RESET:      equ     >FFFE   #RESET vector
(1)       0 :                            *** Trap Vector
(1)       0 : =FFFE              VEC_TRAP0:      equ     >FFFE
(1)       0 : =FFFC              VEC_TRAP1:      equ     >FFFC
(1)       0 : =FFFA              VEC_TRAP2:      equ     >FFFA
(1)       0 : =FFF8              VEC_TRAP3:      equ     >FFF8
(1)       0 : =FFF6              VEC_TRAP4:      equ     >FFF6
(1)       0 : =FFF4              VEC_TRAP5:      equ     >FFF4
(1)       0 : =FFF2              VEC_TRAP6:      equ     >FFF2
(1)       0 : =FFF0              VEC_TRAP7:      equ     >FFF0
(1)       0 : =FFEE              VEC_TRAP8:      equ     >FFEE
(1)       0 : =FFEC              VEC_TRAP9:      equ     >FFEC
(1)       0 : =FFEA              VEC_TRAP10:     equ     >FFEA
(1)       0 : =FFE8              VEC_TRAP11:     equ     >FFE8
(1)       0 : =FFE6              VEC_TRAP12:     equ     >FFE6
(1)       0 : =FFE4              VEC_TRAP13:     equ     >FFE4
(1)       0 : =FFE2              VEC_TRAP14:     equ     >FFE2
(1)       0 : =FFE0              VEC_TRAP15:     equ     >FFE0
(1)       0 : =FFDE              VEC_TRAP16:     equ     >FFDE
(1)       0 : =FFDC              VEC_TRAP17:     equ     >FFDC
(1)       0 : =FFDA              VEC_TRAP18:     equ     >FFDA
(1)       0 : =FFD8              VEC_TRAP19:     equ     >FFD8
(1)       0 : =FFD6              VEC_TRAP20:     equ     >FFD6
(1)       0 : =FFD4              VEC_TRAP21:     equ     >FFD4
(1)       0 : =FFD2              VEC_TRAP22:     equ     >FFD2
(1)       0 : =FFD0              VEC_TRAP23:     equ     >FFD0
(1)       0 :                            *** Internal Peripherals
(1)       0 : =100               IOCNT0: equ     >0100   I/O Control register
(1)       0 : =C0                MEMMODE_gm:     equ     ?11000000       Memory mode
(1)       0 :                            * 0=Single Chip, 1=Peripheral Expansion, 2=Full Expansion
(1)       0 : =20                INT3_F: equ     ?00100000       #INT3 flag
(1)       0 : =10                INT3_E: equ     ?00010000       #INT3 enable
(1)       0 : =2                 INT1_F: equ     ?00000010       #INT1 flag
(1)       0 : =1                 INT1_E: equ     ?00000001       #INT1 enable
(1)       0 :                            *** I/O Ports
(1)       0 : =104               APORT:  equ     >0104   Port A data
(1)       0 : =106               BPORT:  equ     >0106   Port B data
(1)       0 : =108               CPORT:  equ     >0108   Port C data
(1)       0 : =109               CDDR:   equ     >0109   Port C data direction register
(1)       0 : =10A               DPORT:  equ     >010A   Port D data
(1)       0 : =10B               DDDR:   equ     >010B   Port D data direction register
          0 :
          0 :                            *** MC6850 Asynchronous Communication Interface Adapter
          0 : =1F0               ACIA:   equ     >01F0
          0 :                            include "mc6850.inc"
(1)       0 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)       0 :                            *** MC6850
(1)       0 :                            *** Asynchronous Communication Interface Adapter
(1)       0 : =1F0               ACIA_control:   equ     ACIA+0
(1)       0 : =1F0               ACIA_status:    equ     ACIA+0
(1)       0 : =1F1               ACIA_data:      equ     ACIA+1
(1)       0 :                            **  Counter Divider Select Bits
(1)       0 : =3                 CDS_gm:         equ     ?11             Group mask
(1)       0 : =0                 CDS_DIV1_gc:    equ     ?00000000       /1
(1)       0 : =0                 CDS_DIV16_gc:   equ     ?00000001       /16
(1)       0 : =0                 CDS_DIV64_gc:   equ     ?00000010       /64
(1)       0 : =3                 CDS_RESET_gc:   equ     ?00000011       Master Reset
(1)       0 :                            **  Word Select Bits
(1)       0 : =1C                WSB_gm:         equ     ?00011100       Group mask
(1)       0 : =0                 WSB_7E2_gc:     equ     ?00000000       7 Bits + Even Parity + 2 Stop Bits
(1)       0 : =4                 WSB_7O2_gc:     equ     ?00000100       7 bits + Odd Parity  + 2 Stop Bits
(1)       0 : =8                 WSB_7E1_gc:     equ     ?00001000       7 bits + Even Parity + 1 Stop Bits
(1)       0 : =C                 WSB_7O1_gc:     equ     ?00001100       7 bits + Odd Parity  + 1 Stop Bits
(1)       0 : =10                WSB_8N2_gc:     equ     ?00010000       8 bits + No Parity   + 2 Stop Bits
(1)       0 : =14                WSB_8N1_gc:     equ     ?00010100       8 bits + No Parity   + 1 Stop Bits
(1)       0 : =18                WSB_8E1_gc:     equ     ?00011000       8 bits + Even Parity + 1 Stop Bits
(1)       0 : =1C                WSB_8O1_gc:     equ     ?00011100       8 bits + Odd Parity  + 1 Stop Bits
(1)       0 :                            **  Transmit Control Bits
(1)       0 : =60                TCB_gm:         equ     ?01100000       Group mask
(1)       0 : =0                 TCB_DI_gc:      equ     ?00000000       RTS=Low,  Tx Interrupt Disabled
(1)       0 : =20                TCB_EI_gc:      equ     ?00100000       RTS=Low,  Tx Interrupt Enabled
(1)       0 : =40                TCB_RTS_gc:     equ     ?01000000       RTS=High, Tx Interrupt Disabled
(1)       0 : =60                TCB_BREAK_gc:   equ     ?01100000       RTS=Low,  Tx Interrupt Disabled
(1)       0 :                            *                               Transmit Break Level
(1)       0 : =80                RIEB_bm:        equ     ?10000000       Receive Interrupt Enable Bit mask
(1)       0 :                            *** Status register
(1)       0 : =1                 RDRF_bm:        equ     ?00000001       Receive Data Register Full
(1)       0 : =2                 TDRE_bm:        equ     ?00000010       Transmit Data Register Empty
(1)       0 : =4                 DCDF_bm:        equ     ?00000100       Data Carrier Detect Flag
(1)       0 : =8                 CTSF_bm:        equ     ?00001000       Clear To Send Flag
(1)       0 : =10                FERR_bm:        equ     ?00010000       Frame Error Flag
(1)       0 : =20                OVRN_bm:        equ     ?00100000       Receiver Overrun Flag
(1)       0 : =40                PERR_bm:        equ     ?01000000       Parity Error Flag
(1)       0 : =80                IRQF_bm:        equ     ?10000000       Interrupt Request Flag
          0 : =94                RX_INT_TX_NO:   equ     WSB_8N1_gc|RIEB_bm
          0 : =B4                RX_INT_TX_INT:  equ     WSB_8N1_gc|RIEB_bm|TCB_EI_gc
          0 :
       2000 :                            org     >2000
       2000 : =80                rx_queue_size:  equ     128
       2000 :                    rx_queue:       bss     rx_queue_size
       2080 : =80                tx_queue_size:  equ     128
       2080 :                    tx_queue:       bss     tx_queue_size
       2100 :
       2100 :                            * Internal registers
          4 :                            org     >0004
          4 :                    RdH:    bss     1
          5 :                    RdL:    bss     1
          6 : =5                 Rd:     equ     RdL             ; R4:R5
          6 :                    RsH:    bss     1
          7 :                    RsL:    bss     1
          8 : =7                 Rs:     equ     RsL             ; R6:R7
          8 :                            bss     1
          9 :                    tmp:    bss     1
          A :                            bss     1
          B :                    vC:     bss     1
          C :                            bss     1
          D :                    vD:     bss     1
          E :                            bss     1
          F :                    vA:     bss     1
         10 :                            bss     1
         11 :                    vB:     bss     1
         12 :                            bss     1
         13 :                    vP:     bss     1
         14 :                            bss     1
         15 :                    vQ:     bss     1
         16 :                            bss     1
         17 :                    vS:     bss     1
         18 :                    vTH     bss     1
         19 :                    vTL:    bss     1
         1A : =19                vT:     equ     vTL
         1A : =32                cF:     equ     50
         1A :                    vY:     bss     1
         1B :                    vX:     bss     1
         1C :                    vI:     bss     1
         1D :                            * TMS7000's SP is pre-increment/post-decrement
         1D :                    stack:
         1D :
       FFFC :                            org     VEC_INT1
       FFFC : 13 6A                      data    isr_int1
       FFFE :
       FFFE :                            org     VEC_RESET
       FFFE : 10 00                      data    initialize
      10000 :
       1000 :                            org     >1000
       1000 :                    initialize:
       1000 : 52 1D                      mov     %stack, B
       1002 : 0D                         ldsp
       1003 : 88 20 00 03                movd    %rx_queue, R3
       1007 : 52 80                      mov     %rx_queue_size, B
       1009 : 8E 12 F2                   call    @queue_init
       100C : 88 20 80 03                movd    %tx_queue, R3
       1010 : 52 80                      mov     %tx_queue_size, B
       1012 : 8E 12 F2                   call    @queue_init
       1015 :                            ** initialize ACIA
       1015 : A2 03 F0                   movp    %CDS_RESET_gc, ACIA_control     Master reset
       1018 : A2 94 F0                   movp    %RX_INT_TX_NO, ACIA_control
       101B : A2 01 F2                   movp    %1, ACIA+2                      #INT1 for Rx/Tx
       101E : A2 23 00                   movp    %INT3_F|INT1_E|INT1_F, IOCNT0   enable #INT1 and #INT1
       1021 :
       1021 :                    loop:
       1021 : 8E 10 6A                   call    @mandelbrot
       1024 : 8E 10 3C                   call    @newline
       1027 : E0 F8                      jmp     loop
       1029 :
       1029 :                            *** Get character
       1029 :                            *** @return A
       1029 :                            *** @return ST.C 0 if no character
       1029 :                            *** @clobber R2:R3
       1029 :                    getchar:
       1029 : 88 20 00 03                movd    %rx_queue, R3
       102D : 06                         dint
       102E : 8E 13 3D                   call    @queue_remove
       1031 : E7 02                      jnc     getchar_empty
       1033 : 05                         eint                    ST.C=1
       1034 : 0A                         rets
       1035 :                    getchar_empty:
       1035 : 05                         eint                    ST.C=1
       1036 : B0                         clrc
       1037 : 0A                         rets
       1038 :
       1038 :                            *** Put character
       1038 :                            *** @param A
       1038 :                            *** @clobber R2:R3
       1038 :                    putspace:
       1038 : 22 20                      mov     %' ', A
       103A : E0 07                      jmp     putchar
       103C :                    newline:
       103C : 22 0D                      mov     %>0D, A
       103E : 8E 10 43                   call    @putchar
       1041 : 22 0A                      mov     %>0A, A
       1043 :                    putchar:
       1043 : 05                         eint
       1044 : 88 20 80 03                movd    %tx_queue, R3
       1048 : 06                         dint
       1049 : 8E 13 08                   call    @queue_add
       104C : E7 F5                      jnc     putchar
       104E : 05                         eint
       104F : A2 B4 F0                   movp    %RX_INT_TX_INT, ACIA_control    enable Tx interrupt
       1052 : 0A                         rets
       1053 :
       1053 :                            include "mandelbrot.inc"
(1)    1053 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    1053 :                            cpu     tms7000
(1)    1053 :
(1)    1053 :                            *** Print variable: "A=variable "
(1)    1053 :                            *** @param Rd variable
(1)    1053 :                            *** @param A variable letter
(1)    1053 :                            *** @clobber A Rd Rs
(1)    1053 :                    print:
(1)    1053 : 8E 10 43                   call    @putchar         print variable letter
(1)    1056 : 22 3D                      mov     %'=', A
(1)    1058 : 8E 10 43                   call    @putchar
(1)    105B : 8E 11 A7                   call    @print_int16
(1)    105E : 8C 10 38                   br      @putspace
(1)    1061 :
(1)    1061 :                            *** Sign extend
(1)    1061 :                            *** @param A 8-bit value
(1)    1061 :                            *** @return Rd signed extended 16-bit value
(1)    1061 :                    sex:
(1)    1061 : D5 04                      clr     RdH
(1)    1063 : D0 05                      mov     A, RdL
(1)    1065 : E5 02                      jpz     sex_end
(1)    1067 : D4 04                      inv     RdH
(1)    1069 :                    sex_end:
(1)    1069 : 0A                         rets
(1)    106A :
(1)    106A :                    mandelbrot:
(1)    106A : 72 F4 1A                   mov     %-12, vY        ; Y=-12
(1)    106D :                    loop_y:
(1)    106D : 72 CF 1B                   mov     %-49, vX        ; X=-49
(1)    1070 :                    loop_x:
(1)    1070 : 12 1B                      mov     vX, A
(1)    1072 : 8E 10 61                   call    @sex            ; Rd=extend(X)
(1)    1075 : 88 00 E5 07                movd    %229, Rs
(1)    1079 : 8E 12 40                   call    @mul16          ; Rd=X*229
(1)    107C : 88 00 64 07                movd    %100, Rs
(1)    1080 : 8E 12 C0                   call    @div16          ; Rd=X*229/100
(1)    1083 : 98 05 0B                   movd    Rd, vC          ; C=X*229/100
(1)    1086 : 98 0B 0F                   movd    vC, vA          ; A=C
(1)    1089 : 12 1A                      mov     vY, A
(1)    108B : 8E 10 61                   call    @sex            ; Rd=extend(Y)
(1)    108E : 88 01 A0 07                movd    %416, Rs
(1)    1092 : 8E 12 40                   call    @mul16          ; Rd=Y*416
(1)    1095 : 88 00 64 07                movd    %100, Rs
(1)    1099 : 8E 12 C0                   call    @div16          ; Rd=Y*416/100
(1)    109C : 98 05 0D                   movd    Rd, vD          ; D=Y*416/100
(1)    109F : 98 0D 11                   movd    vD, vB          ; B=D
(1)    10A2 : D5 1C                      clr     vI              ; I=0
(1)    10A4 :
(1)    10A4 :                            ;; mov     vY, A
(1)    10A4 :                            ;; call    @sex            ; Rd=Y
(1)    10A4 :                            ;; mov     %'Y', A
(1)    10A4 :                            ;; call    @print
(1)    10A4 :                            ;; mov     vX, A
(1)    10A4 :                            ;; call    @sex            ; Rd=X
(1)    10A4 :                            ;; mov     %'X', A
(1)    10A4 :                            ;; call    @print
(1)    10A4 :                            ;; movd    vC, Rd          ; C
(1)    10A4 :                            ;; mov     %'C', A
(1)    10A4 :                            ;; call    @print
(1)    10A4 :                            ;; movd    vD, Rd          ; D
(1)    10A4 :                            ;; mov     %'D', A
(1)    10A4 :                            ;; call    @print
(1)    10A4 :                            ;; call    @newline
(1)    10A4 :
(1)    10A4 :                    loop_i:
(1)    10A4 : 98 11 05                   movd    vB, Rd          ; Rd=B
(1)    10A7 : 88 00 32 07                movd    %cF, Rs
(1)    10AB : 8E 12 C0                   call    @div16          ; Rd=B/F
(1)    10AE : 98 05 15                   movd    Rd, vQ          ; Q=B/F
(1)    10B1 : 88 00 32 07                movd    %cF, Rs
(1)    10B5 : 8E 12 40                   call    @mul16          ; Rd=Q*F
(1)    10B8 : 98 11 17                   movd    vB, vS          ; S=B
(1)    10BB : 4A 05 17                   sub     RdL, vS
(1)    10BE : 4B 04 16                   sbb     RdH, vS-1       ; S=B-Q*F
(1)    10C1 : 98 11 05                   movd    vB, Rd
(1)    10C4 : 98 11 07                   movd    vB, Rs
(1)    10C7 : 8E 12 40                   call    @mul16          ; Rd=B*B
(1)    10CA : D8 04                      push    RdH
(1)    10CC : D8 05                      push    RdL             ; push B*B
(1)    10CE : 98 0F 05                   movd    vA, Rd
(1)    10D1 : 98 0F 07                   movd    vA, Rs
(1)    10D4 : 8E 12 40                   call    @mul16          ; Rd=A*A
(1)    10D7 : D9 07                      pop     RsL
(1)    10D9 : D9 06                      pop     RsH             ; Rs=B*B
(1)    10DB : 4A 07 05                   sub     RsL, RdL
(1)    10DE : 4B 06 04                   sbb     RsH, RdH        ; Rd=A*A-B*B
(1)    10E1 : 88 00 32 07                movd    %cF, Rs
(1)    10E5 : 8E 12 C0                   call    @div16          ; Rd=(A*A-B*B)/F
(1)    10E8 : 48 0B 05                   add     vC, RdL
(1)    10EB : 49 0A 04                   adc     vC-1, RdH       ; Rd=(A*A-B*B)/F+C
(1)    10EE : D8 04                      push    RdH
(1)    10F0 : D8 05                      push    RdL             ; push (A*A-B*B)/F+C
(1)    10F2 : 98 0F 05                   movd    vA, Rd
(1)    10F5 : 98 15 07                   movd    vQ, Rs
(1)    10F8 : 8E 12 40                   call    @mul16          ; Rd=A*Q
(1)    10FB : D8 04                      push    RdH
(1)    10FD : D8 05                      push    RdL             ; push A*Q
(1)    10FF : 98 0F 05                   movd    vA, Rd
(1)    1102 : 98 17 07                   movd    vS, Rs
(1)    1105 : 8E 12 40                   call    @mul16          ; Rd=A*S
(1)    1108 : 88 00 32 07                movd    %cF, Rs
(1)    110C : 8E 12 C0                   call    @div16          ; Rd=A*S/F
(1)    110F : D9 07                      pop     RsL
(1)    1111 : D9 06                      pop     RsH             ; pop A*Q
(1)    1113 : 48 07 05                   add     RsL, RdL
(1)    1116 : 49 06 04                   adc     RsH, RdH        ; Rd=A*Q+A*S/F
(1)    1119 : B0                         clrc
(1)    111A : DF 05                      rlc     RdL
(1)    111C : DF 04                      rlc     RdH             ; Rd=2*(A*Q+A*S/F)
(1)    111E : 48 0D 05                   add     vD, RdL
(1)    1121 : 49 0C 04                   adc     vD-1, RdH       ; Rd=2*(A*Q+A*S/F)+D
(1)    1124 : 98 05 11                   movd    Rd, vB          ; B=2*(A*Q+A*S/F)+D
(1)    1127 : D9 05                      pop     RdL
(1)    1129 : D9 04                      pop     RdH             ; pop (A*A-B*B)/F+C
(1)    112B : 98 05 0F                   movd    Rd, vA          ; A=(A*A-B*B)/F+C
(1)    112E : 88 00 32 07                movd    %cF, Rs
(1)    1132 : 8E 12 C0                   call    @div16          ; Rd=A/F
(1)    1135 : 98 05 13                   movd    Rd, vP          ; P=A/F
(1)    1138 : 98 05 07                   movd    Rd, Rs
(1)    113B : 8E 12 40                   call    @mul16          ; P*P
(1)    113E : D8 04                      push    RdH
(1)    1140 : D8 05                      push    RdL             ; push P*P
(1)    1142 : 98 11 05                   movd    vB, Rd
(1)    1145 : 88 00 32 07                movd    %cF, Rs
(1)    1149 : 8E 12 C0                   call    @div16          ; Rd=B/F
(1)    114C : 98 05 15                   movd    Rd, vQ          ; Q=B/F
(1)    114F : 98 05 07                   movd    Rd, Rs
(1)    1152 : 8E 12 40                   call    @mul16          ; Q*Q
(1)    1155 : D9 07                      pop     RsL
(1)    1157 : D9 06                      pop     RsH             ; pop P*P
(1)    1159 : 48 07 05                   add     RsL, RdL
(1)    115C : 49 06 04                   adc     RsH, RdH        ; Rd=Q*Q+P*P
(1)    115F : 98 05 19                   movd    Rd, vT          ; T=Q*Q+P*P
(1)    1162 :
(1)    1162 :                            ;; call    @putspace
(1)    1162 :                            ;; mov     vI, A
(1)    1162 :                            ;; call    @sex            ; Rd=I
(1)    1162 :                            ;; mov     %'I', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; movd    vA, Rd          ; A
(1)    1162 :                            ;; mov     %'A', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; movd    vB, Rd          ; B
(1)    1162 :                            ;; mov     %'B', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; movd    vP, Rd          ; P
(1)    1162 :                            ;; mov     %'P', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; movd    vQ, Rd          ; Q
(1)    1162 :                            ;; mov     %'Q', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; movd    vT, Rd          ; T
(1)    1162 :                            ;; mov     %'T', A
(1)    1162 :                            ;; call    @print
(1)    1162 :                            ;; call    @newline
(1)    1162 :
(1)    1162 : 12 18                      mov     vT-1, A
(1)    1164 : E6 13                      jnz     print_i         ; if hi(T)>0
(1)    1166 : 7D 04 19                   cmp     %4, vT
(1)    1169 : E4 0E                      jgt     print_i         ; if T>4
(1)    116B : D3 1C                      inc     vI              ; I+=1
(1)    116D : 7D 10 1C                   cmp     %16, vI
(1)    1170 : E5 03                      jpz     print_space     ; if I>=16
(1)    1172 : 8C 10 A4                   br      @loop_i         ; if I<16
(1)    1175 :                    print_space:
(1)    1175 : 22 20                      mov     %' ', A
(1)    1177 : E0 0A                      jmp     print_char
(1)    1179 :                    print_i:
(1)    1179 : 12 1C                      mov     vI, A
(1)    117B : 2D 0A                      cmp     %10, A
(1)    117D : E1 02                      jlt     print_i2        ; if I<10
(1)    117F : 28 07                      add     %'A'-'0'-10, A
(1)    1181 :                    print_i2:
(1)    1181 : 28 30                      add     %'0', A
(1)    1183 :                    print_char:
(1)    1183 :                            ;; push    A
(1)    1183 :                            ;; mov     %'@', A
(1)    1183 :                            ;; call    @putchar
(1)    1183 :                            ;; mov     %'=', A
(1)    1183 :                            ;; call    @putchar
(1)    1183 :                            ;; pop     A
(1)    1183 :                            ;; call    @putchar
(1)    1183 :                            ;; call    @newline
(1)    1183 :
(1)    1183 : 8E 10 43                   call    @putchar
(1)    1186 : 8E 10 29                   call    @getchar
(1)    1189 : E7 04                      jnc     next_x
(1)    118B : B0                         tsta
(1)    118C : E6 01                      jnz     next_x
(1)    118E : 01                         idle                    ; halt to system
(1)    118F :                    next_x:
(1)    118F : D3 1B                      inc     vX              ; X+=1
(1)    1191 : 7D 1E 1B                   cmp     %30, vX
(1)    1194 : E5 03                      jge     next_y          ; if X>=30
(1)    1196 : 8C 10 70                   br      @loop_x         ; if X<30
(1)    1199 :                    next_y:
(1)    1199 : 8E 10 3C                   call    @newline
(1)    119C : D3 1A                      inc     vY              ; Y+=1
(1)    119E : 7D 0D 1A                   cmp     %13, vY
(1)    11A1 : E5 03                      jge     mandelbrot_end  ; if Y>=13
(1)    11A3 : 8C 10 6D                   br      @loop_y         ; if Y<13
(1)    11A6 :                    mandelbrot_end:
(1)    11A6 : 0A                         rets
       11A7 :                            include "arith.inc"
(1)    11A7 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    11A7 :                            cpu     tms7000
(1)    11A7 :
(1)    11A7 :                            *** Print signed 16-bit integer as decimal
(1)    11A7 :                            *** @param R4:R5 value
(1)    11A7 :                            *** @clobber A R4:R5 R6:R7
(1)    11A7 :                    print_int16:
(1)    11A7 : 77 80 04 0F                btjz    %>80, R4, print_uint16
(1)    11AB : 22 2D                      mov     %'-', A
(1)    11AD : 8E 10 43                   call    @putchar
(1)    11B0 : D4 04                      inv     R4
(1)    11B2 : D4 05                      inv     R5
(1)    11B4 : D3 05                      inc     R5
(1)    11B6 : E7 02                      jnc     print_uint16
(1)    11B8 : D3 04                      inc     R4              ; negate R4:R5
(1)    11BA :                            *** Print unsigned 16-bit integer as decimal
(1)    11BA :                            *** @param R4:R5 value
(1)    11BA :                            *** @clobber A R4:R5 R6:R7
(1)    11BA :                    print_uint16:
(1)    11BA : 12 04                      mov     R4, A
(1)    11BC : 14 05                      or      R5, A
(1)    11BE : E2 13                      jz      print_uint16_zero
(1)    11C0 :                    print_uint16_loop:
(1)    11C0 : 12 04                      mov     R4, A
(1)    11C2 : 14 05                      or      R5, A
(1)    11C4 : E2 12                      jz      print_uint16_end ; branch if value == 0
(1)    11C6 : 88 00 0A 07                movd    %10, R7          ; R6:R7=10
(1)    11CA : 8E 12 72                   call    @udiv16          ; R4:R5=value/10
(1)    11CD : D8 07                      push    R7               ; push reminder
(1)    11CF : 8E 11 C0                   call    @print_uint16_loop
(1)    11D2 : B9                         pop     A
(1)    11D3 :                    print_uint16_zero:
(1)    11D3 : 24 30                      or      %'0', A
(1)    11D5 : 8C 10 43                   br      @putchar
(1)    11D8 :                    print_uint16_end:
(1)    11D8 : 0A                         rets
(1)    11D9 :
(1)    11D9 :                            *** Addition: R4:R5 += R6:R7
(1)    11D9 :                    add16:
(1)    11D9 : 48 07 05                   add     R7, R5
(1)    11DC : 49 06 04                   adc     R6, R4
(1)    11DF : 0A                         rets
(1)    11E0 :
(1)    11E0 :                            *** Subtraction: R4:R5 -= R6:R7
(1)    11E0 :                    sub16:
(1)    11E0 : 4A 07 05                   sub     R7, R5
(1)    11E3 : 4B 06 04                   sbb     R6, R4
(1)    11E6 : 0A                         rets
(1)    11E7 :
(1)    11E7 :                            *** Signed compare A=sign(minuend-subtrahend)
(1)    11E7 :                            *** @param R4:R5 minuend
(1)    11E7 :                            *** @param R6:R7 subtrahend
(1)    11E7 :                            *** @return A=0  JEQ (minuend == subtrahend)
(1)    11E7 :                            ***         A=1  JGT (minuend > subtrahend)
(1)    11E7 :                            ***         A=-1 JLT (minuend < subtrahend)
(1)    11E7 :                            *** @clobber A
(1)    11E7 :                    cmp16:
(1)    11E7 : D8 03                      push    R3
(1)    11E9 : D8 02                      push    R2
(1)    11EB : 98 05 03                   movd    R5, R3          ; R2:R3=minuend
(1)    11EE : 4A 07 03                   sub     R7, R3
(1)    11F1 : 4B 06 02                   sbb     R6, R2          ; R2:R3=minuend-subtrahend
(1)    11F4 : 12 02                      mov     R2, A
(1)    11F6 : 14 03                      or      R3, A
(1)    11F8 : E2 16                      jeq     cmp16_end       ; return with A=0
(1)    11FA : 12 02                      mov     R2, A           ; A=hi(minuend-subtrahend)
(1)    11FC : 15 04                      xor     R4, A           ; A=hi((minuend-subtrahend)^minuend)
(1)    11FE : D0 03                      mov     A, R3           ; R3=hi((minuend-subtrahend)^minuend)
(1)    1200 : 12 04                      mov     R4, A           ; A=hi(minuend)
(1)    1202 : 15 06                      xor     R6, A           ; A=hi(minuend^subtrahend)
(1)    1204 : 13 03                      and     R3, A           ; A=overflow flag
(1)    1206 : 15 02                      xor     R2, A           ; A=V^N
(1)    1208 : E1 04                      jn      cmp16_lt        ; branch if minuend < subtrahend
(1)    120A :                    cmp16_gt:
(1)    120A : 22 01                      mov     %1, A
(1)    120C : E0 02                      jmp     cmp16_end
(1)    120E :                    cmp16_lt:
(1)    120E : 22 FF                      mov     %-1, A
(1)    1210 :                    cmp16_end:
(1)    1210 : D9 02                      pop     R2
(1)    1212 : D9 03                      pop     R3
(1)    1214 : B0                         tsta
(1)    1215 : 0A                         rets
(1)    1216 :
(1)    1216 :                            *** Unsigned multiplication: result = multiplicand * multiplier
(1)    1216 :                            *** @param R4:R5 multiplicand
(1)    1216 :                            *** @param R6:R7 multiplier
(1)    1216 :                            *** @return R4:R5 result
(1)    1216 :                            *** @clobber A R4:R5 R6:R7
(1)    1216 :                    umul16:
(1)    1216 : D8 03                      push    R3
(1)    1218 : D8 02                      push    R2
(1)    121A : 98 05 03                   movd    R5, R3          ; R2:R3=multiplicand
(1)    121D : 88 00 00 05                movd    %0, R5          ; R4:R5=result=0
(1)    1221 : E0 12                      jmp     umul16_check
(1)    1223 :                    umul16_loop:
(1)    1223 : B0                         clrc
(1)    1224 : DD 06                      rrc     R6
(1)    1226 : DD 07                      rrc     R7              ; multiplier >>= 1
(1)    1228 : E7 06                      jnc     umul16_next     ; if lsb(multiplier) == 0
(1)    122A : 48 03 05                   add     R3, R5
(1)    122D : 49 02 04                   adc     R2, R4          ; result += multiplicand
(1)    1230 :                    umul16_next:
(1)    1230 : B0                         clrc
(1)    1231 : DF 03                      rlc     R3
(1)    1233 : DF 02                      rlc     R2              ; multiplicand <<= 1
(1)    1235 :                    umul16_check:
(1)    1235 : 12 06                      mov     R6, A
(1)    1237 : 14 07                      or      R7, A
(1)    1239 : E6 E8                      jnz     umul16_loop     ; while multiplier != 0
(1)    123B :                    umul16_end:
(1)    123B : D9 02                      pop     R2
(1)    123D : D9 03                      pop     R3
(1)    123F : 0A                         rets
(1)    1240 :
(1)    1240 :                            *** Multiply: result = multiplicand * multiplier
(1)    1240 :                            *** @param R4:R5 multiplicand
(1)    1240 :                            *** @param R6:R7 multiplier
(1)    1240 :                            *** @return R4:R5 result
(1)    1240 :                            *** @clobber A R6:R7
(1)    1240 :                    mul16:
(1)    1240 : 12 04                      mov     R4, A
(1)    1242 : 15 06                      xor     R6, A
(1)    1244 : B8                         push    A               ; save hi(multiplicand^multiplier)
(1)    1245 : 77 80 06 0A                btjz    %>80, R6, mul16_multiplicand
(1)    1249 : D4 06                      inv     R6
(1)    124B : D4 07                      inv     R7
(1)    124D : D3 07                      inc     R7
(1)    124F : E7 02                      jnc     mul16_multiplicand
(1)    1251 : D3 06                      inc     R6              ; negate multiplier
(1)    1253 :                    mul16_multiplicand:
(1)    1253 : 77 80 04 0A                btjz    %>80, R4, mul16_multiply
(1)    1257 : D4 04                      inv     R4
(1)    1259 : D4 05                      inv     R5
(1)    125B : D3 05                      inc     R5
(1)    125D : E7 02                      jnc     mul16_multiply
(1)    125F : D3 04                      inc     R4              ; negate multiplicand
(1)    1261 :                    mul16_multiply:
(1)    1261 : 8E 12 16                   call    @umul16         ; R4:R5=result
(1)    1264 : B9                         pop     A               ; A=(multiplicand^multiplier)
(1)    1265 : E5 0A                      jpz     mul16_end
(1)    1267 : D4 04                      inv     R4
(1)    1269 : D4 05                      inv     R5
(1)    126B : D3 05                      inc     R5
(1)    126D : E7 02                      jnc     mul16_end
(1)    126F : D3 04                      inc     R4              ; negate result
(1)    1271 :                    mul16_end:
(1)    1271 : 0A                         rets
(1)    1272 :
(1)    1272 :                            *** Unsigned division: dividend / divisor = quotient ... reminder
(1)    1272 :                            *** @praram R4:R5 dividend
(1)    1272 :                            *** @praram R6:R7 divisor
(1)    1272 :                            *** @return R4:R5 quotient
(1)    1272 :                            *** @return R6:R7 reminder
(1)    1272 :                            *** @clobber A
(1)    1272 :                    udiv16:
(1)    1272 : 12 06                      mov     R6, A
(1)    1274 : 14 07                      or      R7, A
(1)    1276 : E2 47                      jz      udiv16_end      ; branch if divisor==0
(1)    1278 : D8 08                      push    R8
(1)    127A : 72 01 08                   mov     %1, R8          ; R8=bits
(1)    127D : E0 07                      jmp     udiv16_prep
(1)    127F :                    udiv16_prep_loop:
(1)    127F : B0                         clrc
(1)    1280 : DF 07                      rlc     R7
(1)    1282 : DF 06                      rlc     R6              ; divisor <<= 1
(1)    1284 : D3 08                      inc     R8              ; ++bits
(1)    1286 :                    udiv16_prep:
(1)    1286 : 77 80 06 F5                btjz    %>80, R6, udiv16_prep_loop ; while msb(divisor) == 0
(1)    128A : D8 03                      push    R3
(1)    128C : D8 02                      push    R2
(1)    128E : 88 00 00 03                movd    %0, R3          ; R2:R3=quotient=0
(1)    1292 : E0 0A                      jmp     udiv16_enter_loop
(1)    1294 :                    udiv16_loop:
(1)    1294 : B0                         clrc
(1)    1295 : DD 06                      rrc     R6
(1)    1297 : DD 07                      rrc     R7              ; divisor >>= 1
(1)    1299 : B0                         clrc
(1)    129A : DF 03                      rlc     R3
(1)    129C : DF 02                      rlc     R2              ; quotient <<= 1
(1)    129E :                    udiv16_enter_loop:
(1)    129E : 4A 07 05                   sub     R7, R5
(1)    12A1 : 4B 06 04                   sbb     R6, R4          ; dividend -= divisor
(1)    12A4 : E7 04                      jl      udiv16_readd
(1)    12A6 : D3 03                      inc     R3              ; quotient |= 1
(1)    12A8 : E0 06                      jmp     udiv16_next
(1)    12AA :                    udiv16_readd:
(1)    12AA : 48 07 05                   add     R7, R5
(1)    12AD : 49 06 04                   adc     R6, R4          ; dividend += divisor
(1)    12B0 :                    udiv16_next:
(1)    12B0 : DA 08 E1                   djnz    R8, udiv16_loop ; while bits-- != 0
(1)    12B3 : 98 05 07                   movd    R5, R7          ; R6:R7=reminder
(1)    12B6 : 98 03 05                   movd    R3, R5          ; R4:R5=quotient
(1)    12B9 : D9 02                      pop     R2
(1)    12BB : D9 03                      pop     R3
(1)    12BD : D9 08                      pop     R8
(1)    12BF :                    udiv16_end:
(1)    12BF : 0A                         rets
(1)    12C0 :
(1)    12C0 :                            *** Division: dividend / divisor = quotient ... reminder
(1)    12C0 :                            *** @param R4:R5 dividend
(1)    12C0 :                            *** @param R6:R7 divisor
(1)    12C0 :                            *** @return R4:R5 quotient
(1)    12C0 :                            *** @return R6:R7 reminder
(1)    12C0 :                            *** @clobber A
(1)    12C0 :                    div16:
(1)    12C0 : 12 04                      mov     R4, A
(1)    12C2 : 15 06                      xor     R6, A
(1)    12C4 : B8                         push    A               ; save hi(dividend^divisor)
(1)    12C5 : 77 80 06 0A                btjz    %>80, R6, div16_dividend
(1)    12C9 : D4 06                      inv     R6
(1)    12CB : D4 07                      inv     R7
(1)    12CD : D3 07                      inc     R7
(1)    12CF : E7 02                      jnc     div16_dividend
(1)    12D1 : D3 06                      inc     R6              ; negate divisor
(1)    12D3 :                    div16_dividend:
(1)    12D3 : 77 80 04 0A                btjz    %>80, R4, div16_divide
(1)    12D7 : D4 04                      inv     R4
(1)    12D9 : D4 05                      inv     R5
(1)    12DB : D3 05                      inc     R5
(1)    12DD : E7 02                      jnc     div16_divide
(1)    12DF : D3 04                      inc     R4
(1)    12E1 :                    div16_divide:
(1)    12E1 : 8E 12 72                   call    @udiv16         ; R4:R5=quotient
(1)    12E4 : B9                         pop     A               ; A=(dividend^divisor)
(1)    12E5 : E5 0A                      jpz     div16_end
(1)    12E7 : D4 04                      inv     R4
(1)    12E9 : D4 05                      inv     R5
(1)    12EB : D3 05                      inc     R5
(1)    12ED : E7 02                      jnc     div16_end
(1)    12EF : D3 04                      inc     R4              ; negate quotient
(1)    12F1 :                    div16_end:
(1)    12F1 : 0A                         rets
       12F2 :                            include "queue.inc"
(1)    12F2 :                    ;;; -*- mode: asm; mode: flyspell-prog; -*-
(1)    12F2 :                            *** [queue] queue structure
(1)    12F2 : =0                 queue_len:      equ     0       queue length
(1)    12F2 : =1                 queue_size:     equ     1       buffer size
(1)    12F2 : =2                 queue_put:      equ     2       queue put index
(1)    12F2 : =3                 queue_get:      equ     3       queue get index
(1)    12F2 : =4                 queue_buf:      equ     4       buffer start offset
(1)    12F2 :
(1)    12F2 :                            *** [queue] Initialize queue
(1)    12F2 :                            *** @param R2:R3 queue work space pointer
(1)    12F2 :                            *** @param B queue work space size
(1)    12F2 :                            *** @clobber A B R2:R3
(1)    12F2 :                    queue_init:
(1)    12F2 : B5                         clr     A
(1)    12F3 : 9B 03                      sta     *R3             queue_len
(1)    12F5 : 62                         mov     B, A
(1)    12F6 : 2A 04                      sub     %queue_buf, A
(1)    12F8 : D3 03                      inc     R3
(1)    12FA : 9B 03                      sta     *R3             queue_size
(1)    12FC : 5A 02                      sub     %queue_put, B   offset queue_len and queue_size
(1)    12FE : D3 03                      inc     R3              R2:R3=&queue_put
(1)    1300 : B5                         clr     A
(1)    1301 :                    queue_init_loop:
(1)    1301 : 9B 03                      sta     *R3
(1)    1303 : D3 03                      inc     R3
(1)    1305 : CA FA                      djnz    B, queue_init_loop
(1)    1307 : 0A                         rets
(1)    1308 :
(1)    1308 :                            *** [queue] Add an element to queue
(1)    1308 :                            *** @param R2:R3 queue work space pointer
(1)    1308 :                            *** @param A an element
(1)    1308 :                            *** @return ST.C 0 if queue is full
(1)    1308 :                            *** @clobber R2:R3
(1)    1308 :                    queue_add:
(1)    1308 : B8                         push    A
(1)    1309 : 9A 03                      lda     *R3             A=queue_len
(1)    130B : D3 03                      inc     R3              R2:R3=&queue_size
(1)    130D : 9D 03                      cmpa    *R3
(1)    130F : E7 02                      jl      queue_add_element
(1)    1311 : B9                         pop     A               ST.C=0
(1)    1312 : 0A                         rets
(1)    1313 :                    queue_add_element:
(1)    1313 : B3                         inc     A
(1)    1314 : D2 03                      dec     R3
(1)    1316 : 9B 03                      sta     *R3             queue_len++
(1)    1318 : B9                         pop     A
(1)    1319 : 78 02 03                   add     %queue_put-queue_len, R3        R2:R3=&queue_put
(1)    131C : D8 03                      push    R3
(1)    131E : B8                         push    A
(1)    131F : 9A 03                      lda     *R3             A=queue_put
(1)    1321 : 28 02                      add     %queue_buf-queue_put, A
(1)    1323 : 48 00 03                   add     A, R3           R2:R3=&queue[queue_put]
(1)    1326 : B9                         pop     A
(1)    1327 : 9B 03                      sta     *R3             store element
(1)    1329 : D9 03                      pop     R3              R2:R3=&queue_put
(1)    132B : B8                         push    A
(1)    132C : 9A 03                      lda     *R3
(1)    132E : B3                         inc     A
(1)    132F : D2 03                      dec     R3              R2:R3=&queue_size
(1)    1331 : 9D 03                      cmpa    *R3
(1)    1333 : E7 01                      jl      queue_add_return
(1)    1335 : B5                         clr     A               wraparound
(1)    1336 :                    queue_add_return:
(1)    1336 : D3 03                      inc     R3              R2:R3=&queue_put
(1)    1338 : 9B 03                      sta     *R3             update queue_put
(1)    133A : B9                         pop     A
(1)    133B : 07                         setc                    ST.C=1
(1)    133C : 0A                         rets
(1)    133D :
(1)    133D :                            *** [queue] Remove an element from queue
(1)    133D :                            *** @param R2:R3 queue work space pointer
(1)    133D :                            *** @return A an element
(1)    133D :                            *** @return ST.C 0 if queue is empty
(1)    133D :                    queue_remove:
(1)    133D : 9A 03                      lda     *R3             A=queue_len
(1)    133F : E6 02                      jnz     queue_remove_elem
(1)    1341 : B0                         clrc
(1)    1342 : 0A                         rets
(1)    1343 :                    queue_remove_elem:
(1)    1343 : B2                         dec     A
(1)    1344 : 9B 03                      sta     *R3             queue_len--
(1)    1346 : 78 03 03                   add     %queue_get-queue_len, R3        R2:R3=&queue_get
(1)    1349 : D8 03                      push    R3
(1)    134B : 9A 03                      lda     *R3             A=queue_get
(1)    134D : 28 01                      add     %queue_buf-queue_get, A
(1)    134F : 48 00 03                   add     A, R3           R2:R3=&queue_buf[queue_get]
(1)    1352 : 9A 03                      lda     *R3             remove element
(1)    1354 : D9 03                      pop     R3              R2:R3=&queue_get
(1)    1356 : B8                         push    A
(1)    1357 : 9A 03                      lda     *R3
(1)    1359 : B3                         inc     A
(1)    135A : 7A 02 03                   sub     %queue_get-queue_size, R3
(1)    135D : 9D 03                      cmpa    *R3
(1)    135F : E7 01                      jl      queue_remove_return
(1)    1361 : B5                         clr     A               wraparound
(1)    1362 :                    queue_remove_return:
(1)    1362 : 78 02 03                   add     %queue_get-queue_size, R3
(1)    1365 : 9B 03                      sta     *R3             update queue_get
(1)    1367 : B9                         pop     A
(1)    1368 : 07                         setc
(1)    1369 : 0A                         rets
       136A :
       136A :                    isr_int1:
       136A : A7 80 F0 17                btjzp   %IRQF_bm, ACIA_status, isr_int1_return
       136E : B8                         push    A
       136F : D8 02                      push    R2
       1371 : D8 03                      push    R3
       1373 : A7 01 F0 0F                btjzp   %RDRF_bm, ACIA_status, isr_tx
       1377 : 80 F1                      movp    ACIA_data, A
       1379 : 88 20 00 03                movd    %rx_queue, R3
       137D : 8E 13 08                   call    @queue_add
       1380 :                    isr_int1_exit:
       1380 : D9 03                      pop     R3
       1382 : D9 02                      pop     R2
       1384 : B9                         pop     A
       1385 :                    isr_int1_return:
       1385 : 0B                         reti
       1386 :                    isr_tx:
       1386 : A7 02 F0 F6                btjzp   %TDRE_bm, ACIA_status, isr_int1_exit
       138A : 88 20 80 03                movd    %tx_queue, R3
       138E : 8E 13 3D                   call    @queue_remove
       1391 : E7 04                      jnc     isr_tx_empty
       1393 : 82 F1                      movp    A, ACIA_data    send character
       1395 : E0 E9                      jmp     isr_int1_exit
       1397 :                    isr_tx_empty:
       1397 : A2 94 F0                   movp    %RX_INT_TX_NO, ACIA_control     disable Tx interrupt
       139A : E0 E4                      jmp     isr_int1_exit
